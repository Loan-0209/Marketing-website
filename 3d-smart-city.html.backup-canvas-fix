<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Smart City - HEART Technology Park - Enhanced Parking System v2.1</title>
    <meta name="description" content="Explore HEART Technology Park in immersive 3D with Smart Parking System - Vietnam's premier AI innovation hub">
    
    <!-- CSS Files -->
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/animations.css">
    <link rel="stylesheet" href="css/responsive.css">
    
    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    
    <!-- 3D Smart City Specific Styles -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #87CEEB 100%);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: relative;
            margin: 0;
            padding: 0;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s ease;
        }

        .loading-content {
            text-align: center;
            color: white;
        }

        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top: 4px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .loading-progress {
            font-size: 14px;
            opacity: 0.8;
            margin-top: 10px;
        }

        /* Responsive adjustments for 3D controls */
        @media (max-width: 768px) {
            #controls {
                top: 80px;
                left: 10px;
                padding: 15px;
            }
            
            #info-panel {
                top: 80px;
                right: 10px;
                max-width: 280px;
                padding: 15px;
            }
            
            .panel-toggle.panel-hidden {
                top: 85px;
                left: 5px;
            }
            
            .camera-btn {
                font-size: 11px;
                padding: 8px 12px;
            }
            
            .phase-btn {
                font-size: 11px;
                padding: 8px 12px;
            }
            
            .phase-legend {
                font-size: 10px;
            }
        }

        #canvas-container {
            position: relative;
            width: 100vw;
            height: calc(100vh - 80px);
            margin-top: 80px;
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        #controls {
            position: absolute;
            top: 75px;
            left: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 6px;
            background: rgba(255, 255, 255, 0.85);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(8px);
            min-width: 160px;
            max-width: 180px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .control-group h3 {
            font-size: 11px;
            font-weight: 600;
            color: #333;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 4px;
            padding-bottom: 2px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .control-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 6px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.25);
            margin: 2px 0;
            line-height: 1.2;
        }

        .control-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        }

        .control-btn.active {
            background: #10b981;
            box-shadow: 0 2px 10px rgba(16, 185, 129, 0.3);
        }

        .control-btn.time-btn {
            background: #8b5cf6;
        }

        .control-btn.time-btn:hover {
            background: #7c3aed;
        }

        .control-btn.time-btn.active {
            background: #f59e0b;
        }

        .camera-btn {
            background: #8b5cf6;
            color: white;
            border: none;
            padding: 6px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.25);
            margin: 2px 0;
            width: 100%;
            display: flex;
            align-items: center;
            gap: 4px;
            line-height: 1.2;
        }

        .camera-btn:hover {
            background: #7c3aed;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
        }

        .camera-btn.active {
            background: #ec4899;
            box-shadow: 0 2px 10px rgba(236, 72, 153, 0.3);
        }

        .camera-btn.active:hover {
            background: #db2777;
        }

        .camera-controls {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .camera-controls h3 {
            font-size: 11px;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
            padding-bottom: 2px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .phase-btn {
            background: #475569;
            color: white;
            border: none;
            padding: 6px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 2px 8px rgba(71, 85, 105, 0.25);
            margin: 2px 0;
            width: 100%;
            display: flex;
            align-items: center;
            gap: 4px;
            line-height: 1.2;
        }

        .phase-btn:hover {
            background: #334155;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(71, 85, 105, 0.4);
        }

        .phase-btn.active {
            box-shadow: 0 2px 10px rgba(16, 185, 129, 0.3);
        }

        .phase-btn.phase1 {
            background: #4682b4;
            box-shadow: 0 2px 10px rgba(70, 130, 180, 0.3);
        }

        .phase-btn.phase1:hover {
            background: #36648b;
        }

        .phase-btn.phase1.active {
            background: #10b981;
        }

        .phase-btn.phase2 {
            background: #ff8c00;
            box-shadow: 0 2px 10px rgba(255, 140, 0, 0.3);
        }

        .phase-btn.phase2:hover {
            background: #e07b00;
        }

        .phase-btn.phase2.active {
            background: #10b981;
        }

        .phase-btn.phase3 {
            background: #32cd32;
            box-shadow: 0 2px 10px rgba(50, 205, 50, 0.3);
        }

        .phase-btn.phase3:hover {
            background: #228b22;
        }

        .phase-btn.phase3.active {
            background: #10b981;
        }

        .phase-controls {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .phase-controls h3 {
            font-size: 11px;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
            padding-bottom: 2px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .phase-legend {
            margin-top: 6px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
            font-size: 9px;
        }

        .phase-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 2px 0;
        }

        .phase-color {
            width: 8px;
            height: 8px;
            border-radius: 2px;
        }

        .phase-color.completed {
            background: #4682b4;
        }

        .phase-color.construction {
            background: #ff8c00;
        }

        .phase-color.planned {
            background: #32cd32;
            opacity: 0.7;
        }

        #info-panel {
            position: absolute;
            top: 90px;
            right: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border-radius: 12px;
            padding: 20px;
            max-width: 320px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        #info-panel.hidden {
            transform: translateX(-100%);
            opacity: 0;
            pointer-events: none;
        }

        .panel-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: rgba(59, 130, 246, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 10px rgba(59, 130, 246, 0.3);
            z-index: 101;
            backdrop-filter: blur(5px);
            user-select: none;
        }

        .panel-toggle:hover {
            background: rgba(59, 130, 246, 1);
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        }

        .panel-toggle.panel-hidden {
            position: fixed;
            top: 100px;
            left: 10px;
            background: rgba(59, 130, 246, 0.9);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
            animation: pulse-glow 2s infinite;
        }

        .panel-toggle.panel-hidden:hover {
            left: 15px;
            background: rgba(59, 130, 246, 1);
            animation: none;
        }

        @keyframes pulse-glow {
            0% {
                box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
            }
            50% {
                box-shadow: 0 4px 20px rgba(59, 130, 246, 0.6), 0 0 10px rgba(59, 130, 246, 0.3);
            }
            100% {
                box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
            }
        }

        #info-panel h2 {
            color: #1e40af;
            font-size: 24px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding-right: 40px;
        }

        #info-panel h3 {
            color: #3b82f6;
            font-size: 16px;
            margin-top: 15px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #info-panel ul {
            list-style: none;
            padding-left: 0;
        }

        #info-panel li {
            padding: 4px 0;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #building-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            border-radius: 8px;
            padding: 15px;
            max-width: 300px;
            display: none;
            backdrop-filter: blur(10px);
        }

        .error-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10000;
        }

        .error-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
        }

        .error-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .error-title {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .error-message {
            font-size: 18px;
            opacity: 0.9;
            line-height: 1.6;
        }

        .icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-right: 4px;
        }
        
        /* Building Info Popup Styles */
        .building-info-popup {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(120%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            width: 320px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .building-info-popup.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        .popup-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            background: linear-gradient(135deg, #4c63d2 0%, #6c7ff2 100%);
            color: white;
            border-radius: 12px 12px 0 0;
        }
        
        .building-icon {
            font-size: 24px;
        }
        
        .building-title {
            flex: 1;
            font-size: 16px;
            font-weight: 600;
        }
        
        .popup-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s ease;
        }
        
        .popup-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .popup-content {
            padding: 15px;
        }
        
        .info-row {
            display: flex;
            margin-bottom: 12px;
            align-items: flex-start;
        }
        
        .info-row:last-child {
            margin-bottom: 0;
        }
        
        .info-label {
            font-weight: 600;
            color: #333;
            min-width: 80px;
            font-size: 13px;
        }
        
        .info-value {
            color: #666;
            font-size: 13px;
            flex: 1;
        }
        
        .features-list {
            list-style: none;
            padding: 0;
            margin: 0;
            color: #666;
            font-size: 12px;
        }
        
        .features-list li {
            padding: 2px 0;
            padding-left: 15px;
            position: relative;
        }
        
        .features-list li:before {
            content: "‚Ä¢";
            position: absolute;
            left: 0;
            color: #4c63d2;
        }
        
        .phase-status {
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            display: inline-block;
        }
        
        .phase-status.phase1 {
            background: rgba(70, 130, 180, 0.2);
            color: #4682B4;
        }
        
        .phase-status.phase2 {
            background: rgba(255, 140, 0, 0.2);
            color: #FF8C00;
        }
        
        .phase-status.phase3 {
            background: rgba(50, 205, 50, 0.2);
            color: #32CD32;
        }
        
        /* Mobile responsive */
        @media (max-width: 640px) {
            .building-info-popup {
                width: 90%;
                max-width: 320px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <h2 class="loading-text">ƒêang t·∫£i Enhanced Smart City...</h2>
            <p class="loading-progress" id="loading-progress">Kh·ªüi t·∫°o WebGL...</p>
        </div>
    </div>

    <!-- Error Screen -->
    <div class="error-screen" id="error-screen">
        <div class="error-content">
            <div class="error-icon">‚ö†Ô∏è</div>
            <h1 class="error-title">L·ªói T·∫£i Smart City</h1>
            <p class="error-message" id="error-message">
                Kh√¥ng th·ªÉ t·∫£i m√¥ h√¨nh 3D. Vui l√≤ng l√†m m·ªõi trang v√† th·ª≠ l·∫°i.
            </p>
        </div>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="header-container">
            <a href="index.html" class="logo">HEART</a>
            <nav class="nav">
                <a href="index.html">Home</a>
                <a href="about.html">About Us</a>
                <a href="master-plan.html">Master Plan</a>
                <a href="3d-smart-city.html" class="active">3D Smart City</a>
                <a href="facilities.html">Facilities</a>
                <a href="investment.html">Investment</a>
                <a href="technology.html">Technology</a>
                <a href="news.html">News</a>
                <a href="contact.html" class="contact-btn">Contact</a>
            </nav>
        </div>
    </header>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Information Panel -->
    <div id="info-panel">
        <button class="panel-toggle" onclick="toggleInfoPanel()" title="·∫®n/Hi·ªán b·∫£ng th√¥ng tin">
            ‚úñ
        </button>
        <h2>üèôÔ∏è Enhanced Smart City with AI Parking</h2>
        <p>Th√†nh ph·ªë th√¥ng minh v·ªõi h·ªá th·ªëng b√£i ƒë·∫≠u xe AI v√† c∆° s·ªü h·∫° t·∫ßng ho√†n ch·ªânh</p>
        
        <h3>üÖøÔ∏è Smart Parking System:</h3>
        <ul>
            <li>üè¢ B√£i ƒë·ªó xe th√¥ng minh 3 t·∫ßng (600 ch·ªó)</li>
            <li>üöó 4 b√£i ƒë·ªó xe b·ªÅ m·∫∑t (400 ch·ªó)</li>
            <li>‚ö° 50+ tr·∫°m s·∫°c xe ƒëi·ªán (DC 150kW)</li>
            <li>üì± ·ª®ng d·ª•ng ƒë·∫∑t ch·ªó real-time</li>
            <li>üé´ Thanh to√°n kh√¥ng ti·∫øp x√∫c</li>
            <li>üîç C·∫£m bi·∫øn ph√°t hi·ªán ch·ªó tr·ªëng</li>
            <li>üö≤ 200+ ch·ªó ƒë·∫≠u xe ƒë·∫°p ƒëi·ªán</li>
            <li>üìä H·ªá th·ªëng qu·∫£n l√Ω AI</li>
        </ul>

        <h3>üå≥ T√≠nh nƒÉng c·∫£nh quan:</h3>
        <ul>
            <li>‚úÖ C√¥ng vi√™n trung t√¢m 200x150m</li>
            <li>‚úÖ 5 c√¥ng vi√™n nh·ªè v·ªõi s√¢n ch∆°i</li>
            <li>‚úÖ 60+ c√¢y xanh ƒë√¥ th·ªã</li>
            <li>‚úÖ ƒê·ªì n·ªôi th·∫•t ƒë∆∞·ªùng ph·ªë</li>
            <li>‚úÖ H·ªá th·ªëng ƒë√®n ƒë∆∞·ªùng LED</li>
            <li>‚úÖ ƒê√†i phun n∆∞·ªõc & h·ªì n∆∞·ªõc</li>
            <li>‚úÖ L·ªëi ƒëi b·ªô & c∆° s·ªü h·∫° t·∫ßng</li>
            <li>‚úÖ Khu v·ª±c wifi c√¥ng c·ªông</li>
        </ul>

        <h3>üéÆ ƒêi·ªÅu khi·ªÉn:</h3>
        <ul>
            <li>üñ±Ô∏è K√©o chu·ªôt: Xoay camera</li>
            <li>üîç Cu·ªôn: Thu ph√≥ng</li>
            <li>üëÜ Click: Xem th√¥ng tin t√≤a nh√†</li>
        </ul>
        
        <h3>‚å®Ô∏è Phim t·∫Øt:</h3>
        <ul>
            <li>1-4: Camera Views</li>
            <li>5: Toggle Phase 1</li>
            <li>6: Toggle Phase 2</li>
            <li>7: Toggle Phase 3</li>
        </ul>
    </div>

    <!-- Controls -->
    <div id="controls">
        <div class="control-group">
            <h3>üïê Th·ªùi gian trong ng√†y</h3>
            <button class="control-btn time-btn active" onclick="setTimeOfDay('morning')">Bu·ªïi s√°ng</button>
            <button class="control-btn time-btn" onclick="setTimeOfDay('noon')">Bu·ªïi tr∆∞a</button>
            <button class="control-btn time-btn" onclick="setTimeOfDay('evening')">Bu·ªïi chi·ªÅu</button>
            <button class="control-btn time-btn" onclick="setTimeOfDay('night')">Bu·ªïi t·ªëi</button>
        </div>
        
        <div class="control-group">
            <h3>üé® Ch·∫ø ƒë·ªô hi·ªÉn th·ªã</h3>
            <button class="control-btn" onclick="toggleWireframe()">Khung d√¢y</button>
            <button class="control-btn" onclick="toggleLandscapeMode()">C·∫£nh quan</button>
        </div>
        
        <div class="control-group">
            <h3>üÖøÔ∏è Qu·∫£n l√Ω b√£i ƒë·∫≠u xe</h3>
            <button class="control-btn" onclick="removeAllParkingStructures()" style="background: #e74c3c; color: white;">X√≥a nh√† xe 4 t·∫ßng</button>
            <button class="control-btn" onclick="createParkingInfrastructure()" style="background: #27ae60; color: white;">T·∫°o b√£i ƒë·∫≠u ngo√†i tr·ªùi</button>
            <button class="control-btn" onclick="addCarsToOutdoorParking()" style="background: #3498db; color: white;">Th√™m xe v√†o b√£i ƒë·∫≠u</button>
            <button class="control-btn" onclick="removeOutdoorCars()" style="background: #f39c12; color: white;">X√≥a xe ngo√†i tr·ªùi</button>
        </div>
        
        <div class="control-group">
            <h3>üå± Qu·∫£n l√Ω kh√¥ng gian xanh</h3>
            <button class="control-btn" onclick="restoreGrassArea()" style="background: #2ecc71; color: white;">Kh√¥i ph·ª•c b√£i c·ªè</button>
            <button class="control-btn" onclick="removeGrassRestoration()" style="background: #e67e22; color: white;">X√≥a c√¢y c·ªè</button>
            <button class="control-btn" onclick="restoreGreenAreas()" style="background: #27ae60; color: white;">Th√™m c√¥ng vi√™n tr√≤n</button>
            <button class="control-btn" onclick="removeGreenAreas()" style="background: #d35400; color: white;">X√≥a c√¥ng vi√™n</button>
        </div>
        
        <div class="control-group">
            <h3>üö® KH√îI PH·ª§C KH·∫®N C·∫§P</h3>
            <button class="control-btn" onclick="emergencyRestore()" style="background: #c0392b; color: white; font-weight: bold; border: 2px solid #fff;">üö® KH√îI PH·ª§C NGAY</button>
            <button class="control-btn" onclick="restoreOriginalRiver()" style="background: #3498db; color: white;">Kh√¥i ph·ª•c s√¥ng nguy√™n b·∫£n</button>
            <button class="control-btn" onclick="restoreOriginalDataCenters()" style="background: #9b59b6; color: white;">Kh√¥i ph·ª•c data center nguy√™n b·∫£n</button>
            <button class="control-btn" onclick="createDataCenterComplex()" style="background: #e74c3c; color: white;">üè≠ T·∫°o khu c√¥ng ngh·ªá (ph·∫£i)</button>
            <button class="control-btn" onclick="createEastDataCenter()" style="background: #8e44ad; color: white; font-weight: bold;">üöÄ T·∫†O DATA CENTER ƒê√îNG</button>
            <button class="control-btn" onclick="cleanupIncorrectDataCenters()" style="background: #f39c12; color: white;">üßπ D·ªçn data center c≈©</button>
            <button class="control-btn" onclick="removeDataCenterComplex()" style="background: #95a5a6; color: white;">üóëÔ∏è X√≥a khu c√¥ng ngh·ªá</button>
            <button class="control-btn" onclick="deleteRecentlyCreatedDataCenters()" style="background: #c0392b; color: white; font-weight: bold;">üî• X√ìA T·∫§T C·∫¢ DATA CENTER</button>
            <button class="control-btn" onclick="debugSceneObjects()" style="background: #34495e; color: white;">üîç DEBUG SCENE</button>
            <button class="control-btn" onclick="debugLoadingStatus()" style="background: #2c3e50; color: white;">üìä DEBUG LOADING</button>
            <button class="control-btn" onclick="forceHideLoading()" style="background: #e74c3c; color: white; font-weight: bold;">üö® FORCE HIDE LOADING</button>
            <button class="control-btn" onclick="loadingManager && loadingManager.initialize()" style="background: #9b59b6; color: white; font-weight: bold;">üîÑ RESTART LOADING</button>
        </div>
        
        <div class="control-group camera-controls">
            <h3>üìπ Camera Views</h3>
            <button class="camera-btn" id="aerialViewBtn" onclick="setCameraView('aerial')">üöÅ Aerial View</button>
            <button class="camera-btn" id="streetViewBtn" onclick="setCameraView('street')">üö∂ Street View</button>
            <button class="camera-btn" id="birdsEyeBtn" onclick="setCameraView('birdseye')">ü¶Ö Bird's Eye</button>
            <button class="camera-btn" id="overviewViewBtn" onclick="setCameraView('overview')">üó∫Ô∏è Full Overview</button>
            <button class="camera-btn" id="cinematicBtn" onclick="setCameraView('cinematic')">üé¨ Cinematic</button>
        </div>
        
        <div class="control-group phase-controls">
            <div style="font-weight: bold; margin: 10px 0 8px 0; color: #2c3e50; font-size: 11px;">üèóÔ∏è Master Plan Phases</div>
            <button class="phase-btn phase1 active" id="phase1Btn" data-phase="1" onclick="togglePhase('phase1')">
                <span class="phase-indicator phase-1" style="background: #4682B4; width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>
                PHASE 1 - HEART CORE
            </button>
            <button class="phase-btn phase2 active" id="phase2Btn" data-phase="2" onclick="togglePhase('phase2')">
                <span class="phase-indicator phase-2" style="background: #FF8C00; width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>
                PHASE 2 - TECHNOLOGY HUB
            </button>
            <button class="phase-btn phase3 active" id="phase3Btn" data-phase="3" onclick="togglePhase('phase3')">
                <span class="phase-indicator phase-3" style="background: #32CD32; width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>
                PHASE 3 - INNOVATION DISTRICT
            </button>
            <button class="phase-btn" id="showAllBtn" onclick="showAllPhases()">
                <span class="phase-indicator phase-all" style="background: linear-gradient(to right, #4682B4 0%, #FF8C00 50%, #32CD32 100%); width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>
                SHOW ALL PHASES
            </button>
            
            <div class="phase-legend">
                <div class="phase-legend-item">
                    <div class="phase-color completed"></div>
                    <span>HEART CORE (L√µi HEART)</span>
                </div>
                <div class="phase-legend-item">
                    <div class="phase-color construction"></div>
                    <span>TECHNOLOGY HUB (Trung t√¢m C√¥ng ngh·ªá)</span>
                </div>
                <div class="phase-legend-item">
                    <div class="phase-color planned"></div>
                    <span>INNOVATION DISTRICT (Khu ƒê·ªïi m·ªõi)</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Building Info Popup -->
    <div class="building-info-popup" id="buildingInfoPopup">
        <div class="popup-header">
            <span class="building-icon" id="buildingIcon">üè¢</span>
            <span class="building-title" id="buildingTitle">Building Information</span>
            <button class="popup-close" id="popupCloseBtn">‚úñ</button>
        </div>
        <div class="popup-content">
            <div class="info-row">
                <span class="info-label">Lo·∫°i:</span>
                <span class="info-value" id="buildingType">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Chi·ªÅu cao:</span>
                <span class="info-value" id="buildingHeight">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">S·ªë t·∫ßng:</span>
                <span class="info-value" id="buildingFloors">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">T√≠nh nƒÉng:</span>
                <ul class="features-list" id="buildingFeatures"></ul>
            </div>
            <div class="info-row">
                <span class="info-label">Tr·∫°ng th√°i:</span>
                <span class="info-value phase-status" id="buildingPhase">-</span>
            </div>
        </div>
    </div>

    <!-- Three.js v√† Main Script with ERROR TRACKING -->
    <script>
        console.log('üö® URGENT DEBUG: Script loading tracking started');
        window.SCRIPT_LOAD_START = Date.now();
        
        // üî• CACHE BUSTER - Force browser refresh
        console.log('üî• CACHE BUSTER ACTIVE - Version:', Date.now());
        
        // üîß SPECIFIC ERROR HANDLER - Force loading hide on syntax errors after line 3660
        window.onerror = function(msg, url, line, col, error) {
            console.log('üîß Error detected at line', line, ':', msg);
            
            // More aggressive: remove loading on ANY syntax error
            if (msg && msg.includes('Unexpected token')) {
                console.log("üîß Syntax error detected, immediately removing loading");
                // Don't wait - remove immediately
                document.querySelectorAll('[id*="loading"], [class*="loading"]').forEach(el => {
                    el.style.display = 'none';
                    el.remove();
                });
                console.log("‚úÖ Loading elements removed due to syntax error");
            }
            
            // Original check for errors after line 3660
            if (line > 3660) {
                console.log("üîß Error after line 3660, forcing loading hide");
                setTimeout(() => {
                    document.querySelectorAll('[id*="loading"]').forEach(el => el.remove());
                }, 1000);
            }
            
            // Return true to prevent default error handling
            return true;
        };
        
        // Enhanced global error handler with cache clearing
        window.addEventListener('error', function(e) {
            console.error('üö® ERROR DETECTED (but likely false positive):');
            console.error('üö® Error message:', e.message);
            console.error('üö® Error file:', e.filename);
            console.error('üö® Error line:', e.lineno);
            console.error('üö® Error column:', e.colno);
            console.error('üö® Error object:', e.error);
            console.error('üö® Error stack:', e.error?.stack);
            
            // Clear browser cache if syntax error
            if (e.message && e.message.includes('Unexpected token')) {
                console.log('üî• CLEARING BROWSER CACHE due to false positive syntax error');
                if ('caches' in window) {
                    caches.keys().then(names => {
                        names.forEach(name => caches.delete(name));
                    });
                }
            }
            
            // Force hide loading on any syntax error
            setTimeout(() => {
                if (typeof forceHideLoading === 'function') {
                    forceHideLoading();
                }
            }, 100);
        });
        
        // Check for syntax validation immediately
        try {
            console.log('‚úÖ Initial syntax check passed');
        } catch (syntaxError) {
            console.error('üö® IMMEDIATE SYNTAX ERROR:', syntaxError);
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" onload="console.log('‚úÖ Three.js loaded in', Date.now() - window.SCRIPT_LOAD_START, 'ms'); window.THREE_LOADED = true;" onerror="console.error('‚ùå THREE.JS FAILED TO LOAD'); window.THREE_LOADED = false;"></script>
    <!-- FIX: OrbitControls ƒë∆∞·ª£c load tr·ª±c ti·∫øp t·ª´ CDN ·ªïn ƒë·ªãnh -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js" onload="console.log('‚úÖ OrbitControls loaded'); window.CONTROLS_LOADED = true;" onerror="console.error('‚ùå OrbitControls FAILED'); window.CONTROLS_LOADED = false;"></script>
    
    <!-- SYNTAX ERROR FIX: Ensure proper script execution order -->
    <script>
        // Prevent any syntax errors from blocking execution
        window.onerror = function(msg, url, line, col, error) {
            console.warn('‚ö†Ô∏è Error caught but continuing:', msg, 'at line', line);
            // Continue execution despite errors
            return true;
        };
    </script>
    <script>
        // üö® URGENT DEBUG: Immediate initialization tracking
        console.log('üö® CRITICAL DEBUG: Main script starting execution');
        console.log('üö® THREE defined?', typeof THREE !== 'undefined');
        console.log('üö® Window loaded?', document.readyState);
        
        // üî• ULTRA-EARLY EMERGENCY TIMEOUT - First thing in main script
        setTimeout(function() {
            console.log("üî• ULTRA-EARLY timeout at 2 seconds...");
            try {
                const loading = document.getElementById('loading-screen');
                if (loading) {
                    loading.style.display = 'none';
                    console.log("‚úÖ Loading screen hidden by ultra-early timeout");
                }
                
                // Wrap LoadingState check in try-catch
                try {
                    if (typeof LoadingState === 'undefined') {
                        window.LoadingState = {
                            COMPLETE: 'complete',
                            forceHide: () => {
                                document.querySelectorAll('[id*="loading"]').forEach(el => el.remove());
                            }
                        };
                        console.log("üîß Created emergency LoadingState in timeout");
                    }
                } catch (stateError) {
                    console.warn("LoadingState check failed in timeout:", stateError);
                }
                
                // Ki·ªÉm tra xem 3D scene c√≥ th·ª±c s·ª± ho·∫°t ƒë·ªông kh√¥ng
                console.log("üîç === KI·ªÇM TRA 3D SCENE STATUS ===");
                console.log("S·ªë canvas elements:", document.querySelectorAll('canvas').length);
                console.log("THREE objects:", window.THREE ? "ƒë√£ t·∫£i" : "thi·∫øu");
                console.log("Scene ƒë√£ kh·ªüi t·∫°o:", window.scene ? "c√≥" : "kh√¥ng");
                console.log("Camera ƒë√£ kh·ªüi t·∫°o:", window.camera ? "c√≥" : "kh√¥ng");
                console.log("Renderer ƒë√£ kh·ªüi t·∫°o:", window.renderer ? "c√≥" : "kh√¥ng");
                
                // Ki·ªÉm tra chi ti·∫øt h∆°n
                if (window.scene) {
                    console.log("S·ªë objects trong scene:", window.scene.children.length);
                }
                if (window.renderer) {
                    console.log("Renderer size:", window.renderer.getSize(new THREE.Vector2()));
                }
                console.log("üîç === K·∫æT TH√öC KI·ªÇM TRA ===");
                
                // üî• ENSURE SCENE INITIALIZATION
                if (typeof ensureSceneInitialization === 'function') {
                    console.log("üéØ Calling ensureSceneInitialization from timeout...");
                    ensureSceneInitialization();
                }
                
                // üéØ FORCE CANVAS TO APPEAR IN DOM
                setTimeout(() => {
                    console.log("üéØ Final check: Ensuring canvas is visible...");
                    if (typeof ensureCanvasInDOM === 'function') {
                        ensureCanvasInDOM();
                    }
                    
                    // Double check canvas count
                    const canvasCount = document.querySelectorAll('canvas').length;
                    console.log("üìä Final canvas count in DOM:", canvasCount);
                    
                    if (canvasCount === 0) {
                        console.log("üö® NO CANVAS FOUND! Creating emergency fallback...");
                        if (typeof createFallbackScene === 'function') {
                            createFallbackScene();
                        }
                    }
                }, 1000);
            } catch (e) {
                console.error("Ultra-early timeout error:", e);
            }
        }, 2000);
        
        // Advanced WebGL context creation with fallbacks
        function createWebGLContext(canvas, options = {}) {
            console.log('üîç Creating WebGL context...');
            const contextTypes = ['webgl2', 'webgl', 'experimental-webgl'];
            
            for (const type of contextTypes) {
                try {
                    console.log(`Trying ${type}...`);
                    const context = canvas.getContext(type, {
                        alpha: false,
                        antialias: options.antialias !== false,
                        depth: true,
                        stencil: false,
                        powerPreference: options.powerPreference || 'high-performance',
                        preserveDrawingBuffer: false,
                        failIfMajorPerformanceCaveat: false
                    });
                    
                    if (context) {
                        console.log(`‚úÖ ${type} context created successfully`);
                        return { context, type };
                    }
                } catch (e) {
                    console.warn(`‚ö†Ô∏è Failed to create ${type} context:`, e);
                }
            }
            
            throw new Error('WebGL not supported on this device');
        }
        
        // EMERGENCY: Aggressive loading screen removal
        function emergencyHideLoading() {
            console.log('üö® EMERGENCY: Aggressive loading screen removal initiated');
            
            // Use the ultimate force hide function
            forceHideLoading();
            
            // Additional emergency measures
            document.body.classList.remove('loading');
            document.documentElement.classList.remove('loading');
            
            // Force remove any overlay elements
            document.querySelectorAll('div').forEach(el => {
                const computedStyle = window.getComputedStyle(el);
                if (computedStyle.position === 'fixed' && 
                    computedStyle.top === '0px' && 
                    computedStyle.left === '0px' && 
                    computedStyle.width === '100%' && 
                    computedStyle.height === '100%') {
                    el.remove();
                    console.log('üóëÔ∏è Removed fullscreen overlay element');
                }
            });
            
            console.log('üö® Emergency removal complete');
        }
        
        // Set AGGRESSIVE emergency timeout immediately
        setTimeout(emergencyHideLoading, 4000); // 4 seconds max
        
        // Additional fallback - even more aggressive
        setTimeout(() => {
            console.log('üö® 2-second fallback triggered');
            forceHideLoading();
        }, 2000);
        
        // Global variables
        let scene, camera, renderer, controls;
        let buildings = [];
        let trees = [];
        let parks = [];
        let parkingLots = [];
        let streetFurniture = [];
        let vehicles = [];
        let waterFeatures = [];
        let lights = [];
        let timeOfDay = 'morning';
        let wireframeMode = false;
        let landscapeMode = false;
        let raycaster, mouse;
        let selectedObject = null;
        let loadingTimeout;
        let isLoading = true;
        
        // Professional Loading Management System
        class LoadingManager {
            constructor() {
                this.state = 'initializing';
                this.maxTimeout = 5000; // 5 seconds max
                this.startTime = Date.now();
                this.timeouts = [];
                this.initComplete = false;
                
                console.log('üèóÔ∏è LoadingManager initialized');
                
                // Set absolute maximum timeout
                this.setGlobalTimeout();
            }
            
            setGlobalTimeout() {
                const globalTimeout = setTimeout(() => {
                    console.warn('‚è∞ LoadingManager: Global timeout reached');
                    this.forceComplete();
                }, this.maxTimeout);
                this.timeouts.push(globalTimeout);
            }
            
            async initialize() {
                console.log('üöÄ LoadingManager: Starting initialization...');
                try {
                    this.state = 'webgl_check';
                    await this.initWebGL();
                    
                    this.state = 'loading_assets';
                    await this.loadAssets();
                    
                    this.state = 'setting_up_scene';
                    await this.setupScene();
                    
                    this.completeLoading();
                } catch (error) {
                    console.error('üö® LoadingManager: Initialization failed:', error);
                    this.forceComplete();
                }
            }
            
            async initWebGL() {
                console.log('üîç LoadingManager: Checking WebGL...');
                updateLoadingProgress('Ki·ªÉm tra WebGL...');
                
                if (!checkWebGLSupport()) {
                    throw new Error('WebGL not supported');
                }
                
                // Test WebGL context creation
                const testCanvas = document.createElement('canvas');
                const webglInfo = createWebGLContext(testCanvas);
                testCanvas.remove();
                
                console.log('‚úÖ LoadingManager: WebGL verified:', webglInfo.type);
            }
            
            async loadAssets() {
                console.log('üì¶ LoadingManager: Loading Three.js assets...');
                updateLoadingProgress('T·∫£i Three.js...');
                
                if (typeof THREE === 'undefined') {
                    throw new Error('Three.js not loaded');
                }
                
                console.log('‚úÖ LoadingManager: Three.js loaded');
            }
            
            async setupScene() {
                console.log('üé¨ LoadingManager: Setting up 3D scene...');
                updateLoadingProgress('Kh·ªüi t·∫°o scene 3D...');
                
                // Initialize the actual 3D scene
                await this.initializeThreeJS();
                
                console.log('‚úÖ LoadingManager: Scene setup complete');
            }
            
            async initializeThreeJS() {
                // Scene creation
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB);
                
                // Camera setup
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
                camera.position.set(150, 100, 150);
                camera.lookAt(0, 0, 0);
                
                // Advanced WebGL Renderer
                const testCanvas = document.createElement('canvas');
                const webglInfo = createWebGLContext(testCanvas, { antialias: true, powerPreference: "high-performance" });
                testCanvas.remove();
                
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance",
                    alpha: false,
                    depth: true,
                    stencil: false,
                    preserveDrawingBuffer: false,
                    failIfMajorPerformanceCaveat: false
                });
                
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.sortObjects = true;
                renderer.depthTest = true;
                renderer.depthWrite = true;
                
                const container = document.getElementById('canvas-container');
                if (!container) {
                    throw new Error('Canvas container not found');
                }
                container.appendChild(renderer.domElement);
                
                // Initialize controls
                await initOrbitControls();
                
                // Raycaster
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                // Setup lighting
                setupLighting();
                
                // Create basic scene elements
                createGround();
                createRoads();
                createBuildings();
                
                // Start animation loop
                animate();
            }
            
            completeLoading() {
                console.log('üéâ LoadingManager: Loading completed successfully');
                this.state = 'completed';
                this.initComplete = true;
                
                // Clear all timeouts
                this.clearTimeouts();
                
                // Hide loading screen
                setTimeout(() => {
                    hideLoading();
                    console.log('‚è±Ô∏è Total loading time:', Date.now() - this.startTime, 'ms');
                }, 100);
            }
            
            forceComplete() {
                console.log('üö® LoadingManager: Force completing loading');
                this.state = 'force_completed';
                this.clearTimeouts();
                forceHideLoading();
                
                // Try to start basic scene if possible
                if (typeof THREE !== 'undefined' && !this.initComplete) {
                    try {
                        this.setupBasicScene();
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Basic scene setup failed:', error);
                    }
                }
            }
            
            setupBasicScene() {
                console.log('üèóÔ∏è Setting up basic emergency scene...');
                if (!scene) {
                    scene = new THREE.Scene();
                    scene.background = new THREE.Color(0x87CEEB);
                }
                
                if (!renderer) {
                    renderer = new THREE.WebGLRenderer();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    const container = document.getElementById('canvas-container');
                    if (container) {
                        container.appendChild(renderer.domElement);
                    }
                }
                
                if (!camera) {
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
                    camera.position.set(150, 100, 150);
                }
                
                animate();
            }
            
            clearTimeouts() {
                this.timeouts.forEach(timeout => clearTimeout(timeout));
                this.timeouts = [];
            }
        }
        
        // Create global loading manager instance
        let loadingManager;
        
        // Camera animation variables
        let currentCameraView = null;
        let cameraAnimation = null;
        let cinematicRotation = 0;
        let isCinematicMode = false;
        
        // Parking structure constants - GI·∫¢M XU·ªêNG 1/4 DI·ªÜN T√çCH
        const PARKING_STRUCTURE = {
            x: -10,    // THAY V√å -50
            z: 0,      // THAY V√å 50  
            width: 6,  // Gi·∫£m t·ª´ 12 xu·ªëng 6 (1/2 chi·ªÅu r·ªông)
            depth: 4,  // Gi·∫£m t·ª´ 8 xu·ªëng 4 (1/2 chi·ªÅu s√¢u)
            floors: 4, // Gi·ªØ nguy√™n 4 t·∫ßng
            floorHeight: 3
        };
        
        // Building phase system
        let buildingPhases = {
            phase1: { visible: true, buildings: [] },
            phase2: { visible: true, buildings: [] },
            phase3: { visible: true, buildings: [] }
        };
        
        // Phase colors and materials
        const phaseColors = {
            phase1: 0x4682B4,  // Steel blue - completed
            phase2: 0xFF8C00,  // Dark orange - construction
            phase3: 0x32CD32   // Lime green - planned
        };

        // Building types v·ªõi thi·∫øt k·∫ø chi ti·∫øt
        const buildingTypes = {
            office_tower: { 
                minHeight: 40, 
                maxHeight: 80, 
                color: 0x4a90e2,
                name: 'T√≤a vƒÉn ph√≤ng',
                icon: 'üè¢',
                features: ['K√≠nh ph·∫£n quang', 'S·∫£nh l·ªõn', 'Thang m√°y t·ªëc ƒë·ªô cao']
            },
            residential_tower: { 
                minHeight: 30, 
                maxHeight: 60, 
                color: 0xf5a623,
                name: 'Chung c∆∞ cao c·∫•p',
                icon: 'üè†',
                features: ['Ban c√¥ng r·ªông', 'H·ªì b∆°i tr√™n m√°i', 'Ph√≤ng gym']
            },
            tech_campus: { 
                minHeight: 15, 
                maxHeight: 25, 
                color: 0x7ed321,
                name: 'Khu c√¥ng ngh·ªá',
                icon: 'üíª',
                features: ['NƒÉng l∆∞·ª£ng m·∫∑t tr·ªùi', 'Kh√¥ng gian m·ªü', 'Ph√≤ng lab AI']
            },
            commercial_center: { 
                minHeight: 20, 
                maxHeight: 35, 
                color: 0xbd10e0,
                name: 'Trung t√¢m th∆∞∆°ng m·∫°i',
                icon: 'üõçÔ∏è',
                features: ['Food court', 'R·∫°p chi·∫øu phim', 'Khu vui ch∆°i']
            },
            medical_center: { 
                minHeight: 25, 
                maxHeight: 40, 
                color: 0xff0000,
                name: 'B·ªánh vi·ªán th√¥ng minh',
                icon: 'üè•',
                features: ['C·∫•p c·ª©u 24/7', 'Helipad', 'AI ch·∫©n ƒëo√°n']
            },
            education_hub: { 
                minHeight: 15, 
                maxHeight: 30, 
                color: 0x50e3c2,
                name: 'Trung t√¢m gi√°o d·ª•c',
                features: ['Th∆∞ vi·ªán s·ªë', 'Ph√≤ng VR', 'S√¢n th·ªÉ thao']
            }
        };

        // Park configurations
        const parkConfigs = [
            { size: { x: 200, z: 150 }, position: { x: 0, z: 0 }, type: 'central' },
            { size: { x: 50, z: 50 }, position: { x: -120, z: 80 }, type: 'playground' },
            { size: { x: 40, z: 60 }, position: { x: 130, z: -70 }, type: 'playground' },
            { size: { x: 45, z: 45 }, position: { x: -100, z: -100 }, type: 'playground' },
            { size: { x: 55, z: 40 }, position: { x: 110, z: 90 }, type: 'playground' },
            { size: { x: 35, z: 50 }, position: { x: -140, z: 0 }, type: 'playground' }
        ];

        // FIX: Initialize loading v·ªõi timeout ng·∫Øn h∆°n v√† error handling t·ªët h∆°n
        function initializeLoading() {
            // Set timeout ƒë·ªÉ tr√°nh loading v√¥ h·∫°n - GI·∫¢M t·ª´ 30s xu·ªëng 15s
            loadingTimeout = setTimeout(() => {
                if (isLoading) {
                    console.error('‚è∞ Loading timeout sau 15 gi√¢y');
                    showError('Timeout khi t·∫£i. Vui l√≤ng th·ª≠ l·∫°i.');
                }
            }, 15000); // FIX: Reduced from 30s to 15s

            // Update loading progress
            updateLoadingProgress('ƒêang t·∫£i Three.js...');
        }

        function updateLoadingProgress(message) {
            const progressElement = document.getElementById('loading-progress');
            if (progressElement) {
                progressElement.textContent = message;
            }
            console.log('üìä ' + message);
        }

        function hideLoading() {
            console.log('üîÑ hideLoading() called - State:', currentLoadingState);
            
            // Update state
            currentLoadingState = LoadingState.COMPLETE;
            isLoading = false;
            
            // Clear all timeouts
            clearTimeout(loadingTimeout);
            Object.values(loadingPhaseTimeouts).forEach(timeout => clearTimeout(timeout));
            
            const loadingScreen = document.getElementById('loading-screen');
            console.log('Loading screen element found:', !!loadingScreen);
            
            if (loadingScreen) {
                // Remove all inline styles that might interfere
                loadingScreen.style.removeProperty('visibility');
                loadingScreen.style.removeProperty('pointer-events');
                
                // Use requestAnimationFrame for smooth transition
                requestAnimationFrame(() => {
                    loadingScreen.style.opacity = '0';
                    loadingScreen.style.transition = 'opacity 0.3s ease-out';
                    
                    // Ensure complete removal after transition
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        loadingScreen.style.visibility = 'hidden';
                        loadingScreen.style.pointerEvents = 'none';
                        
                        // Double-check and force remove if still visible
                        if (loadingScreen.offsetParent !== null) {
                            loadingScreen.remove();
                        }
                        
                        console.log('‚úÖ Loading screen hidden completely');
                        console.log('‚è±Ô∏è Total loading time:', Date.now() - loadingStartTime, 'ms');
                    }, 350);
                });
            } else {
                console.warn('‚ö†Ô∏è Loading screen element not found!');
                // Force hide any loading elements
                document.querySelectorAll('#loading-screen, [class*="loading-screen"]').forEach(el => {
                    el.remove();
                });
            }
            
            // Enable body scrolling
            document.body.style.overflow = '';
            document.body.style.position = '';
        }

        function showError(message) {
            isLoading = false;
            clearTimeout(loadingTimeout);
            
            const errorScreen = document.getElementById('error-screen');
            const errorMessage = document.getElementById('error-message');
            
            if (errorScreen && errorMessage) {
                errorMessage.textContent = message;
                errorScreen.style.display = 'flex';
            }
            
            // Hide loading screen
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.style.display = 'none';
            }
        }

        // FIXED: Enhanced init function with comprehensive state tracking
        async function init() {
            console.log('üöÄ Starting initialization...');
            currentLoadingState = LoadingState.THREE_INIT;
            
            // Set phase timeout for init
            loadingPhaseTimeouts.init = setTimeout(() => {
                console.error('‚ùå Init phase timeout after 10s');
                hideLoading();
            }, 10000);
            
            try {
                updateLoadingProgress('Kh·ªüi t·∫°o scene 3D...');
                currentLoadingState = LoadingState.SCENE_CREATE;
                
                // Basic scene setup with error handling
                try {
                    scene = new THREE.Scene();
                    scene.background = new THREE.Color(0x87CEEB);
                    console.log('‚úÖ Scene created');
                } catch (sceneError) {
                    console.error('‚ùå Scene creation error:', sceneError);
                    throw new Error('Failed to create Three.js scene');
                }

                // Camera setup with better near/far ratio
                camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    1,    // Increased near plane to reduce z-fighting
                    2000  // Reduced far plane for better precision
                );
                camera.position.set(150, 100, 150);
                camera.lookAt(0, 0, 0);
                console.log('‚úÖ Camera created');

                // Advanced WebGL Renderer setup with context recovery
                console.log('üîß Creating advanced WebGL renderer...');
                try {
                    // Create canvas manually to test WebGL context first
                    const testCanvas = document.createElement('canvas');
                    const webglInfo = createWebGLContext(testCanvas, { antialias: true, powerPreference: "high-performance" });
                    console.log('‚úÖ WebGL context test passed:', webglInfo.type);
                    testCanvas.remove();
                    
                    // Create Three.js renderer with verified WebGL support
                    renderer = new THREE.WebGLRenderer({ 
                        antialias: true,
                        powerPreference: "high-performance",
                        alpha: false,
                        depth: true,
                        stencil: false,
                        preserveDrawingBuffer: false,
                        failIfMajorPerformanceCaveat: false
                    });
                    
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    
                    // Enhanced depth testing
                    renderer.sortObjects = true;
                    renderer.depthTest = true;
                    renderer.depthWrite = true;
                    
                    const container = document.getElementById('canvas-container');
                    if (!container) {
                        throw new Error('Canvas container not found');
                    }
                    
                    container.appendChild(renderer.domElement);
                    console.log('‚úÖ Advanced WebGL renderer created and added to DOM');
                    
                } catch (rendererError) {
                    console.error('‚ùå RENDERER CREATION FAILED:', rendererError);
                    throw new Error(`WebGL renderer initialization failed: ${rendererError.message}`);
                }

                updateLoadingProgress('Kh·ªüi t·∫°o controls...');
                
                // Initialize controls with timeout protection
                await initOrbitControls();
                console.log('‚úÖ Controls initialized (or skipped)');
                
                // Raycaster for mouse interaction
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                console.log('‚úÖ Raycaster created');

                updateLoadingProgress('T·∫°o √°nh s√°ng...');
                
                // Lighting
                setupLighting();
                console.log('‚úÖ Lighting setup completed');

                updateLoadingProgress('X√¢y d·ª±ng th√†nh ph·ªë...');
                
                // Create city elements with error handling
                try {
                    createGround();
                    console.log('‚úÖ Ground created');
                    
                    createRoads();
                    console.log('‚úÖ Roads created');
                } catch (error) {
                    console.error('‚ùå Error creating ground/roads:', error);
                }
                
                updateLoadingProgress('T·∫°o c√¥ng vi√™n v√† c√¢y xanh...');
                try {
                    createParks();
                    console.log('‚úÖ Parks created');
                    
                    createTrees();
                    console.log('‚úÖ Trees created');
                } catch (error) {
                    console.error('‚ùå Error creating parks/trees:', error);
                }
                
                updateLoadingProgress('T·∫°o t√≤a nh√†...');
                try {
                    createBuildings();
                    console.log('‚úÖ Buildings created');
                } catch (error) {
                    console.error('‚ùå Error creating buildings:', error);
                }
                
                updateLoadingProgress('T·∫°o Data Center...');
                try {
                    // DISABLED - createDataCenterCluster();
                    console.log('‚úÖ Data centers creation DISABLED');
                } catch (error) {
                    console.error('‚ùå Error creating data centers:', error);
                }
                
                updateLoadingProgress('X√≥a c·∫•u tr√∫c nh√† xe v√† t·∫°o b√£i ƒë·∫≠u xe ngo√†i tr·ªùi...');
                console.log('üìç CHECKPOINT 1: Starting parking operations...');
                try {
                    // SIMPLIFIED LOADING - Skip complex operations
                    console.log('‚ö° Fast loading mode - skipping complex operations...');
                    
                    // Basic ground-level parking only (no removal operations)
                    console.log('üÖøÔ∏è Creating basic parking infrastructure...');
                    try {
                        createParkingInfrastructure();
                        console.log('‚úÖ Basic parking created');
                    } catch (parkingError) {
                        console.error('‚ö†Ô∏è Parking creation failed, continuing...', parkingError);
                    }
                    
                    // Delay complex operations until after loading
                    setTimeout(() => {
                        console.log('üîÑ Running delayed complex operations...');
                        try {
                            emergencyRestore();
                            removeAllParkingStructures(); 
                            createCentralPark();
                        } catch (delayedError) {
                            console.error('‚ùå Delayed operations error:', delayedError);
                        }
                    }, 5000); // After scene fully loads
                } catch (error) {
                    console.error('‚ùå Error creating smart parking:', error);
                }
                
                updateLoadingProgress('Th√™m n·ªôi th·∫•t ƒë∆∞·ªùng ph·ªë...');
                console.log('üìç CHECKPOINT 2: Starting street furniture...');
                try {
                    createStreetFurniture();
                    createInfrastructure();
                    console.log('‚úÖ Street furniture created');
                    console.log('üìç CHECKPOINT 2.1: Street furniture completed');
                } catch (error) {
                    console.error('‚ùå Error creating street furniture:', error);
                }
                
                updateLoadingProgress('T·∫°o t√≠nh nƒÉng n∆∞·ªõc...');
                console.log('üìç CHECKPOINT 3: Starting water features...');
                try {
                    createWaterFeatures();
                    console.log('‚úÖ Water features created');
                    
                    createRiver();
                    console.log('‚úÖ River created');
                    console.log('üìç CHECKPOINT 3.1: Water features completed');
                } catch (error) {
                    console.error('‚ùå Error creating water features:', error);
                }

                // Event listeners
                console.log('üìç CHECKPOINT 4: Adding event listeners...');
                window.addEventListener('resize', onWindowResize);
                window.addEventListener('keydown', onKeyDown);
                renderer.domElement.addEventListener('click', onMouseClick);
                renderer.domElement.addEventListener('mousemove', onMouseMove);
                console.log('‚úÖ Event listeners added');
                console.log('üìç CHECKPOINT 4.1: Event listeners completed');

                updateLoadingProgress('B·∫Øt ƒë·∫ßu render...');
                console.log('üìç CHECKPOINT 5: Starting animation...');
                
                // Start animation
                animate();
                console.log('‚úÖ Animation started');
                console.log('üìç CHECKPOINT 5.1: Animation started successfully');
                
                // Final phase: Hide loading screen
                console.log('üìç FINAL: All initialization complete, hiding loading...');
                currentLoadingState = LoadingState.RENDER_START;
                
                // Clear phase timeout
                clearTimeout(loadingPhaseTimeouts.init);
                
                // Hide loading screen with proper state transition
                setTimeout(() => {
                    hideLoading();
                    console.log('‚úÖ Loading sequence completed successfully');
                }, 100); // Almost immediate

            } catch (error) {
                console.error('‚ùå L·ªói kh·ªüi t·∫°o:', error);
                showError('L·ªói kh·ªüi t·∫°o 3D scene: ' + error.message);
            }
        }

        // FIX: OrbitControls initialization v·ªõi timeout protection v√† fallback
        async function initOrbitControls() {
            return new Promise((resolve, reject) => {
                // FIX: Timeout cho OrbitControls loading
                const controlsTimeout = setTimeout(() => {
                    console.warn('‚ö†Ô∏è OrbitControls timeout, continuing without controls');
                    resolve(); // Don't reject, just continue
                }, 3000); // Reduced timeout to 3 seconds

                try {
                    // Check if OrbitControls is available
                    if (typeof THREE.OrbitControls !== 'undefined') {
                        console.log('‚úÖ OrbitControls found, initializing...');
                        controls = new THREE.OrbitControls(camera, renderer.domElement);
                        controls.enableDamping = true;
                        controls.dampingFactor = 0.05;
                        controls.maxPolarAngle = Math.PI / 2.2;
                        controls.minDistance = 50;
                        controls.maxDistance = 1000;
                        clearTimeout(controlsTimeout);
                        console.log('‚úÖ OrbitControls initialized successfully');
                        resolve();
                    } else {
                        console.warn('‚ö†Ô∏è OrbitControls not found, trying fallback...');
                        // FIX: Retry mechanism n·∫øu OrbitControls ch∆∞a load
                        let retryCount = 0;
                        const maxRetries = 10;
                        const checkControls = setInterval(() => {
                            retryCount++;
                            if (typeof THREE.OrbitControls !== 'undefined') {
                                clearInterval(checkControls);
                                console.log('‚úÖ OrbitControls found after retry, initializing...');
                                controls = new THREE.OrbitControls(camera, renderer.domElement);
                                controls.enableDamping = true;
                                controls.dampingFactor = 0.05;
                                controls.maxPolarAngle = Math.PI / 2.2;
                                controls.minDistance = 50;
                                controls.maxDistance = 1000;
                                clearTimeout(controlsTimeout);
                                console.log('‚úÖ OrbitControls initialized successfully after retry');
                                resolve();
                            } else if (retryCount >= maxRetries) {
                                clearInterval(checkControls);
                                clearTimeout(controlsTimeout);
                                console.warn('‚ö†Ô∏è OrbitControls failed to load after retries, continuing without');
                                resolve(); // Continue without controls
                            }
                        }, 200);
                    }
                } catch (error) {
                    clearTimeout(controlsTimeout);
                    console.error('‚ùå OrbitControls error:', error);
                    resolve(); // Continue even if controls fail
                }
            });
        }

        // Setup lighting system
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // Directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -150;
            directionalLight.shadow.camera.right = 150;
            directionalLight.shadow.camera.top = 150;
            directionalLight.shadow.camera.bottom = -150;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Hemisphere light for better ambient
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x545454, 0.4);
            scene.add(hemisphereLight);
        }

        // Create ground v·ªõi texture - positioned to avoid z-fighting
        function createGround() {
            // Expanded ground to include data center area
            const groundGeometry = new THREE.PlaneGeometry(800, 600); // Expanded from 500x500
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x3a3a3a,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(100, -0.1, 0); // Slightly lower than river (y: -0.1 vs river y: 0.05)
            ground.receiveShadow = true;
            scene.add(ground);
        }

        // Create road system
        function createRoads() {
            const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x2c2c2c });
            
            // Main roads
            const roads = [
                { pos: [0, 0.1, 0], size: [20, 0.1, 500] }, // Main vertical
                { pos: [0, 0.1, 0], size: [500, 0.1, 20] }, // Main horizontal
                { pos: [100, 0.1, 0], size: [15, 0.1, 500] }, // East vertical
                { pos: [-100, 0.1, 0], size: [15, 0.1, 500] }, // West vertical
                { pos: [0, 0.1, 100], size: [500, 0.1, 15] }, // North horizontal
                { pos: [0, 0.1, -100], size: [500, 0.1, 15] }, // South horizontal
            ];

            roads.forEach(road => {
                const geometry = new THREE.BoxGeometry(...road.size);
                const mesh = new THREE.Mesh(geometry, roadMaterial);
                mesh.position.set(...road.pos);
                mesh.receiveShadow = true;
                scene.add(mesh);

                // Add road markings
                const markingMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const markingGeometry = new THREE.BoxGeometry(
                    road.size[0] > 20 ? 2 : road.size[0] * 0.1,
                    0.2,
                    road.size[2] > 20 ? 2 : road.size[2] * 0.1
                );

                // Create dashed line effect
                const numMarkings = road.size[0] > road.size[2] ? 
                    Math.floor(road.size[0] / 10) : Math.floor(road.size[2] / 10);
                
                for (let i = 0; i < numMarkings; i += 2) {
                    const marking = new THREE.Mesh(markingGeometry, markingMaterial);
                    if (road.size[0] > road.size[2]) {
                        marking.position.set(
                            road.pos[0] - road.size[0]/2 + i * 10 + 5,
                            road.pos[1] + 0.1,
                            road.pos[2]
                        );
                    } else {
                        marking.position.set(
                            road.pos[0],
                            road.pos[1] + 0.1,
                            road.pos[2] - road.size[2]/2 + i * 10 + 5
                        );
                    }
                    scene.add(marking);
                }
            });
        }
        
        // (Keep all other functions exactly the same as original but continue file...)
        
        // Create central park v·ªõi ƒë∆∞·ªùng ƒëi figure-8
        function createCentralPark(config) {
            const park = new THREE.Group();
            
            // Park base
            const parkGeometry = new THREE.BoxGeometry(config.size.x, 0.5, config.size.z);
            const parkMaterial = new THREE.MeshLambertMaterial({ color: 0x228b22 });
            const parkBase = new THREE.Mesh(parkGeometry, parkMaterial);
            parkBase.receiveShadow = true;
            park.add(parkBase);

            // Figure-8 walking paths
            const pathMaterial = new THREE.MeshLambertMaterial({ color: 0xd4a574 });
            
            // Create figure-8 path v·ªõi curves
            const curve1 = new THREE.EllipseCurve(
                -30, 0, 40, 30, 0, 2 * Math.PI, false, 0
            );
            const curve2 = new THREE.EllipseCurve(
                30, 0, 40, 30, 0, 2 * Math.PI, false, 0
            );

            const points1 = curve1.getPoints(50);
            const points2 = curve2.getPoints(50);

            // Create path meshes
            [points1, points2].forEach(points => {
                points.forEach((point, i) => {
                    if (i < points.length - 1) {
                        const pathSegment = new THREE.BoxGeometry(5, 0.1, 2);
                        const pathMesh = new THREE.Mesh(pathSegment, pathMaterial);
                        pathMesh.position.set(point.x, 0.3, point.y);
                        
                        // Rotate to align with curve
                        const nextPoint = points[i + 1];
                        const angle = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);
                        pathMesh.rotation.y = -angle;
                        
                        park.add(pathMesh);
                    }
                });
            });

            // Central fountain
            const fountainGroup = new THREE.Group();
            
            // Fountain base
            const fountainBase = new THREE.Mesh(
                new THREE.CylinderGeometry(8, 10, 2, 16),
                new THREE.MeshPhongMaterial({ color: 0x808080 })
            );
            fountainBase.position.y = 1;
            fountainGroup.add(fountainBase);

            // Water effect
            const waterGeometry = new THREE.CylinderGeometry(7, 7, 3, 16);
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.7,
                shininess: 100
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.position.y = 2.5;
            fountainGroup.add(water);

            // Water jets
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const jet = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.5, 4, 8),
                    waterMaterial
                );
                jet.position.set(
                    Math.cos(angle) * 5,
                    4,
                    Math.sin(angle) * 5
                );
                fountainGroup.add(jet);
            }

            park.add(fountainGroup);
            park.position.set(config.position.x, 0, config.position.z);
            return park;
        }

        // Create small parks v·ªõi playgrounds
        function createSmallPark(config) {
            const park = new THREE.Group();
            
            // Park base
            const parkGeometry = new THREE.BoxGeometry(config.size.x, 0.5, config.size.z);
            const parkMaterial = new THREE.MeshLambertMaterial({ color: 0x2d5016 });
            const parkBase = new THREE.Mesh(parkGeometry, parkMaterial);
            parkBase.receiveShadow = true;
            park.add(parkBase);

            // Playground equipment
            const playgroundGroup = new THREE.Group();
            
            // Slide
            const slideGroup = new THREE.Group();
            const slideBase = new THREE.Mesh(
                new THREE.BoxGeometry(2, 4, 6),
                new THREE.MeshPhongMaterial({ color: 0xff4500 })
            );
            slideBase.position.set(0, 2, 0);
            slideGroup.add(slideBase);
            
            slideGroup.position.set(-10, 0, 0);
            playgroundGroup.add(slideGroup);

            // Swings
            const swingSet = new THREE.Group();
            const frameMaterial = new THREE.MeshPhongMaterial({ color: 0x4169e1 });
            
            // Top bar
            const topBar = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 6, 8),
                frameMaterial
            );
            topBar.position.y = 4.5;
            topBar.rotation.z = Math.PI / 2;
            swingSet.add(topBar);
            
            swingSet.position.set(5, 0, 0);
            playgroundGroup.add(swingSet);

            playgroundGroup.position.set(0, 0.3, 0);
            park.add(playgroundGroup);

            park.position.set(config.position.x, 0, config.position.z);
            return park;
        }

        // Create all parks
        function createParks() {
            parkConfigs.forEach(config => {
                let park;
                if (config.type === 'central') {
                    park = createCentralPark(config);
                } else {
                    park = createSmallPark(config);
                }
                parks.push(park);
                scene.add(park);
            });
        }

        // Create tree system
        function createTree() {
            const tree = new THREE.Group();
            
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 5, 8);
            const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.5;
            trunk.castShadow = true;
            tree.add(trunk);
            
            // Crown variations
            const crownTypes = [
                { geometry: new THREE.SphereGeometry(3, 12, 8), yOffset: 6 },
                { geometry: new THREE.ConeGeometry(3, 5, 12), yOffset: 7 },
                { geometry: new THREE.DodecahedronGeometry(3), yOffset: 6 }
            ];
            
            const crownType = crownTypes[Math.floor(Math.random() * crownTypes.length)];
            const crownMaterial = new THREE.MeshPhongMaterial({ 
                color: new THREE.Color().setHSL(0.25, 0.8, 0.25 + Math.random() * 0.1)
            });
            
            const crown = new THREE.Mesh(crownType.geometry, crownMaterial);
            crown.position.y = crownType.yOffset;
            crown.castShadow = true;
            tree.add(crown);
            
            return tree;
        }

        // Create comprehensive tree distribution
        function createTrees() {
            // Trees in central park (20+)
            for (let i = 0; i < 25; i++) {
                const tree = createTree();
                const angle = Math.random() * Math.PI * 2;
                const radius = 30 + Math.random() * 60;
                tree.position.set(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
                trees.push(tree);
                scene.add(tree);
            }

            // Street trees along boulevards (every 25m)
            const streetTreePositions = [];
            
            // Main vertical streets
            for (let z = -200; z <= 200; z += 25) {
                streetTreePositions.push({ x: -110, z: z });
                streetTreePositions.push({ x: -90, z: z });
                streetTreePositions.push({ x: 90, z: z });
                streetTreePositions.push({ x: 110, z: z });
            }
            
            streetTreePositions.forEach(pos => {
                const tree = createTree();
                tree.position.set(pos.x, 0, pos.z);
                tree.scale.setScalar(0.8);
                trees.push(tree);
                scene.add(tree);
            });
        }

        // Create buildings
        function createBuildings() {
            const buildingPositions = [
                // PHASE 1 - COMPLETED (Blue/Gray)
                { x: -150, z: -150, type: 'office_tower', phase: 'phase1' },
                { x: -120, z: -150, type: 'tech_campus', phase: 'phase1' },
                { x: 150, z: 150, type: 'residential_tower', phase: 'phase1' },
                { x: 120, z: 150, type: 'residential_tower', phase: 'phase1' },
                { x: -150, z: 150, type: 'commercial_center', phase: 'phase1' },
                { x: -180, z: 0, type: 'medical_center', phase: 'phase1' },
                
                // PHASE 2 - UNDER CONSTRUCTION (Orange)
                { x: -150, z: -120, type: 'office_tower', phase: 'phase2' },
                { x: 150, z: 120, type: 'residential_tower', phase: 'phase2' },
                { x: -120, z: 120, type: 'education_hub', phase: 'phase2' },
                { x: 150, z: -150, type: 'tech_campus', phase: 'phase2' },
                { x: -50, z: -150, type: 'office_tower', phase: 'phase2' },
                { x: 50, z: 150, type: 'commercial_center', phase: 'phase2' },
                
                // PHASE 3 - PLANNED (Green/Transparent)
                { x: 120, z: -120, type: 'tech_campus', phase: 'phase3' },
                { x: 50, z: -150, type: 'office_tower', phase: 'phase3' },
                { x: -50, z: 150, type: 'commercial_center', phase: 'phase3' },
                { x: 180, z: 0, type: 'education_hub', phase: 'phase3' }
            ];

            buildingPositions.forEach(pos => {
                const building = createBuilding(pos.type, pos.x, pos.z, pos.phase);
                buildings.push(building);
                buildingPhases[pos.phase].buildings.push(building);
                scene.add(building);
                
                // Add 2-3 decorative trees around each building
                for (let i = 0; i < 2 + Math.floor(Math.random() * 2); i++) {
                    const tree = createTree();
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 15 + Math.random() * 10;
                    tree.position.set(
                        pos.x + Math.cos(angle) * distance,
                        0,
                        pos.z + Math.sin(angle) * distance
                    );
                    tree.scale.setScalar(0.7);
                    trees.push(tree);
                    scene.add(tree);
                }
            });
        }

        // Create detailed building with phase
        function createBuilding(type, x, z, phase = 'phase1') {
            const building = new THREE.Group();
            const config = buildingTypes[type];
            const height = config.minHeight + Math.random() * (config.maxHeight - config.minHeight);
            
            // Phase-specific color override
            const phaseColor = phaseColors[phase];
            
            // Base structure with phase-specific properties
            const baseGeometry = new THREE.BoxGeometry(20, height, 20);
            let baseMaterial;
            
            if (phase === 'phase3') {
                // Planned buildings - transparent wireframe
                baseMaterial = new THREE.MeshPhongMaterial({ 
                    color: phaseColor,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.4,
                    wireframe: true
                });
            } else {
                // Completed and construction buildings
                baseMaterial = new THREE.MeshPhongMaterial({ 
                    color: phaseColor,
                    shininess: phase === 'phase1' ? 100 : 50
                });
            }
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = height / 2;
            base.castShadow = true;
            base.receiveShadow = true;
            building.add(base);

            // Glass windows pattern
            const windowMaterial = new THREE.MeshPhongMaterial({
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.6,
                shininess: 200
            });

            for (let floor = 0; floor < Math.floor(height / 3); floor++) {
                for (let side = 0; side < 4; side++) {
                    for (let window = 0; window < 4; window++) {
                        const windowMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 2, 0.1),
                            windowMaterial
                        );
                        
                        const angle = (side * Math.PI) / 2;
                        const radius = 10.05;
                        windowMesh.position.set(
                            Math.cos(angle) * radius + Math.sin(angle) * (window - 1.5) * 4,
                            floor * 3 + 1.5,
                            Math.sin(angle) * radius - Math.cos(angle) * (window - 1.5) * 4
                        );
                        windowMesh.rotation.y = angle;
                        building.add(windowMesh);
                    }
                }
            }

            // Add construction elements for phase 2
            if (phase === 'phase2') {
                addConstructionElements(building, height);
            }
            
            // Store building info
            building.userData = {
                type: type,
                name: config.name,
                height: Math.floor(height),
                floors: Math.floor(height / 3),
                features: config.features,
                phase: phase,
                phaseColor: phaseColor
            };

            building.position.set(x, 0, z);
            return building;
        }
        
        // Add construction elements for phase 2 buildings
        function addConstructionElements(building, height) {
            // Construction crane
            const craneGroup = new THREE.Group();
            
            // Crane mast
            const craneMast = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.5, height + 20, 8),
                new THREE.MeshPhongMaterial({ color: 0xffff00 })
            );
            craneMast.position.set(15, (height + 20) / 2, 15);
            craneGroup.add(craneMast);
            
            // Crane arm
            const craneArm = new THREE.Mesh(
                new THREE.BoxGeometry(30, 1, 1),
                new THREE.MeshPhongMaterial({ color: 0xffff00 })
            );
            craneArm.position.set(0, height + 15, 15);
            craneGroup.add(craneArm);
            
            building.add(craneGroup);
        }

        // Enhanced Data Center Complex - Comprehensive Implementation
        function createDataCenterCluster() {
            const dataCenterGroup = new THREE.Group();
            
            // Main data center building - Primary Facility
            const mainDC = createDataCenterBuilding(350, 0, 80, 40, 'primary');
            dataCenterGroup.add(mainDC);
            
            // Secondary data center buildings
            const secondaryDC1 = createDataCenterBuilding(300, 80, 50, 25, 'secondary');
            const secondaryDC2 = createDataCenterBuilding(420, 90, 45, 20, 'secondary');
            const secondaryDC3 = createDataCenterBuilding(380, -10, 60, 30, 'secondary');
            
            dataCenterGroup.add(secondaryDC1);
            dataCenterGroup.add(secondaryDC2);
            dataCenterGroup.add(secondaryDC3);
            
            // Backup/Disaster Recovery Center
            const backupDC = createDataCenterBuilding(500, 50, 40, 15, 'backup');
            dataCenterGroup.add(backupDC);
            
            // Infrastructure and supporting facilities
            createDataCenterInfrastructure(dataCenterGroup);
            
            // Data center landscaping and connecting elements
            createDataCenterLandscaping();
            
            scene.add(dataCenterGroup);
        }

        function createDataCenterBuilding(x, z, width, height, type) {
            const building = new THREE.Group();
            
            // Main structure with enhanced details
            const buildingGeometry = new THREE.BoxGeometry(width, height, width * 0.7);
            let buildingColor;
            switch(type) {
                case 'primary': 
                    buildingColor = 0x2C5530; // Dark green for primary
                    break;
                case 'secondary': 
                    buildingColor = 0x3D6B40; // Medium green for secondary
                    break;
                case 'backup': 
                    buildingColor = 0x4A7C59; // Light green for backup
                    break;
                default: 
                    buildingColor = 0x2C5530;
            }
            
            const buildingMaterial = new THREE.MeshPhongMaterial({ 
                color: buildingColor,
                shininess: 30
            });
            const buildingMesh = new THREE.Mesh(buildingGeometry, buildingMaterial);
            buildingMesh.position.y = height / 2;
            buildingMesh.castShadow = true;
            buildingMesh.receiveShadow = true;
            building.add(buildingMesh);
            
            // Exterior wall details and ventilation
            const wallDetailMaterial = new THREE.MeshPhongMaterial({ color: 0x1a3a1a });
            for (let side = 0; side < 4; side++) {
                const angle = (side * Math.PI) / 2;
                const detailGeometry = new THREE.BoxGeometry(width * 0.9, height * 0.8, 0.5);
                const wallDetail = new THREE.Mesh(detailGeometry, wallDetailMaterial);
                wallDetail.position.set(
                    Math.cos(angle) * (width * 0.35 + 0.3),
                    height / 2,
                    Math.sin(angle) * (width * 0.35 + 0.3)
                );
                wallDetail.rotation.y = angle;
                building.add(wallDetail);
            }
            
            // Cooling systems on roof - More detailed for different building types
            const coolingCount = type === 'primary' ? 8 : type === 'secondary' ? 4 : 2;
            const coolingRows = Math.ceil(Math.sqrt(coolingCount));
            
            for (let i = 0; i < coolingCount; i++) {
                const row = Math.floor(i / coolingRows);
                const col = i % coolingRows;
                
                // Main cooling unit
                const coolingUnit = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 4, 6),
                    new THREE.MeshPhongMaterial({ color: 0x707070 })
                );
                coolingUnit.position.set(
                    (col - coolingRows/2 + 0.5) * 10,
                    height + 2,
                    (row - coolingRows/2 + 0.5) * 10
                );
                building.add(coolingUnit);
                
                // Cooling fan on top
                const fan = new THREE.Mesh(
                    new THREE.CylinderGeometry(2.5, 2.5, 0.5, 12),
                    new THREE.MeshPhongMaterial({ color: 0x404040 })
                );
                fan.position.set(
                    (col - coolingRows/2 + 0.5) * 10,
                    height + 4.5,
                    (row - coolingRows/2 + 0.5) * 10
                );
                building.add(fan);
                
                // Exhaust pipes
                const exhaustPipe = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.8, 0.8, 3, 8),
                    new THREE.MeshPhongMaterial({ color: 0x606060 })
                );
                exhaustPipe.position.set(
                    (col - coolingRows/2 + 0.5) * 10,
                    height + 6.5,
                    (row - coolingRows/2 + 0.5) * 10
                );
                building.add(exhaustPipe);
            }
            
            // Emergency generators (for primary and secondary only)
            if (type === 'primary' || type === 'secondary') {
                const generatorCount = type === 'primary' ? 4 : 2;
                for (let i = 0; i < generatorCount; i++) {
                    const generator = new THREE.Mesh(
                        new THREE.BoxGeometry(8, 3, 4),
                        new THREE.MeshPhongMaterial({ color: 0x8B0000 })
                    );
                    generator.position.set(
                        -width/2 - 6,
                        1.5,
                        (i - generatorCount/2 + 0.5) * 6
                    );
                    building.add(generator);
                    
                    // Generator exhaust
                    const exhaust = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.5, 4, 8),
                        new THREE.MeshPhongMaterial({ color: 0x2F4F4F })
                    );
                    exhaust.position.set(
                        -width/2 - 6,
                        5,
                        (i - generatorCount/2 + 0.5) * 6
                    );
                    building.add(exhaust);
                }
            }
            
            // Satellite dishes and communication equipment (primary only)
            if (type === 'primary') {
                for (let i = 0; i < 3; i++) {
                    // Satellite dish
                    const dish = new THREE.Mesh(
                        new THREE.ConeGeometry(3, 0.5, 16),
                        new THREE.MeshPhongMaterial({ color: 0xC0C0C0 })
                    );
                    dish.position.set(
                        (i - 1) * 15,
                        height + 8,
                        width * 0.2
                    );
                    dish.rotation.x = -Math.PI / 6;
                    building.add(dish);
                    
                    // Dish support
                    const support = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.3, 3, 8),
                        new THREE.MeshPhongMaterial({ color: 0x696969 })
                    );
                    support.position.set(
                        (i - 1) * 15,
                        height + 6,
                        width * 0.2
                    );
                    building.add(support);
                }
                
                // Communication tower
                const commTower = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.8, 15, 8),
                    new THREE.MeshPhongMaterial({ color: 0x708090 })
                );
                commTower.position.set(width/2 - 5, height + 7.5, 0);
                building.add(commTower);
                
                // Tower antennas
                for (let i = 0; i < 4; i++) {
                    const antenna = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.1, 2, 6),
                        new THREE.MeshPhongMaterial({ color: 0x000000 })
                    );
                    const angle = (i / 4) * Math.PI * 2;
                    antenna.position.set(
                        width/2 - 5 + Math.cos(angle) * 2,
                        height + 14,
                        Math.sin(angle) * 2
                    );
                    building.add(antenna);
                }
            }
            
            // Loading docks and access points
            const dockCount = Math.max(2, Math.floor(width / 20));
            for (let i = 0; i < dockCount; i++) {
                const dock = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 4, 2),
                    new THREE.MeshPhongMaterial({ color: 0x4169E1 })
                );
                dock.position.set(
                    (i - dockCount/2 + 0.5) * 8,
                    2,
                    width * 0.35 + 1
                );
                building.add(dock);
                
                // Dock doors
                const door = new THREE.Mesh(
                    new THREE.BoxGeometry(3.5, 3.5, 0.2),
                    new THREE.MeshPhongMaterial({ color: 0x1E90FF })
                );
                door.position.set(
                    (i - dockCount/2 + 0.5) * 8,
                    2,
                    width * 0.35 + 2.1
                );
                building.add(door);
            }
            
            // Security checkpoints
            const checkpoint = new THREE.Mesh(
                new THREE.BoxGeometry(6, 3, 3),
                new THREE.MeshPhongMaterial({ color: 0x800000 })
            );
            checkpoint.position.set(0, 1.5, width * 0.5 + 5);
            building.add(checkpoint);
            
            // Barrier gate
            const barrierPole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 3, 8),
                new THREE.MeshPhongMaterial({ color: 0x8B0000 })
            );
            barrierPole.position.set(-3, 2.5, width * 0.5 + 8);
            building.add(barrierPole);
            
            const barrierArm = new THREE.Mesh(
                new THREE.BoxGeometry(8, 0.3, 0.3),
                new THREE.MeshPhongMaterial({ color: 0xFF0000 })
            );
            barrierArm.position.set(1, 4, width * 0.5 + 8);
            building.add(barrierArm);
            
            // Security fence - Enhanced version
            const fence = createSecurityPerimeter(width + 20, width * 0.7 + 20);
            fence.position.set(0, 0, 0);
            building.add(fence);
            
            // Environmental monitoring equipment
            if (type === 'primary') {
                const weatherStation = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 4, 2),
                    new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
                );
                weatherStation.position.set(width/2 + 8, 2, width/2 + 8);
                building.add(weatherStation);
            }
            
            // Store building metadata
            building.userData = {
                type: 'datacenter',
                subtype: type,
                name: `Data Center ${type.charAt(0).toUpperCase() + type.slice(1)}`,
                capacity: type === 'primary' ? '10,000 servers' : type === 'secondary' ? '5,000 servers' : '2,000 servers',
                powerUsage: type === 'primary' ? '25 MW' : type === 'secondary' ? '15 MW' : '8 MW',
                coolingType: 'Liquid cooling + Air conditioning',
                securityLevel: 'Tier IV',
                uptime: '99.99%'
            };
            
            building.position.set(x, 0, z);
            return building;
        }

        function createDataCenterInfrastructure(parentGroup) {
            // Enhanced power substation
            const substation = createPowerSubstation();
            substation.position.set(450, 40, 0);
            parentGroup.add(substation);
            
            // Multiple transmission towers
            const tower1 = createTransmissionTower();
            tower1.position.set(480, 80, 0);
            parentGroup.add(tower1);
            
            const tower2 = createTransmissionTower();
            tower2.position.set(520, 120, 0);
            parentGroup.add(tower2);
            
            // 500KV transmission lines
            create500KVTransmissionLines();
            
            // Connecting highway with details
            const highway = createConnectingHighway();
            highway.position.set(250, 0, 0);
            parentGroup.add(highway);
            
            // Water cooling facility
            const coolingFacility = createCoolingFacility();
            coolingFacility.position.set(400, -50, 0);
            parentGroup.add(coolingFacility);
            
            // Fuel storage for generators
            const fuelStorage = createFuelStorage();
            fuelStorage.position.set(300, -30, 0);
            parentGroup.add(fuelStorage);
        }

        function createPowerSubstation() {
            const substation = new THREE.Group();
            
            // Main transformer bank
            for (let i = 0; i < 3; i++) {
                const transformer = new THREE.Mesh(
                    new THREE.BoxGeometry(12, 8, 8),
                    new THREE.MeshPhongMaterial({ color: 0x606060 })
                );
                transformer.position.set(i * 15 - 15, 4, 0);
                substation.add(transformer);
                
                // Transformer cooling fins
                for (let j = 0; j < 4; j++) {
                    const fin = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 6, 6),
                        new THREE.MeshPhongMaterial({ color: 0x808080 })
                    );
                    fin.position.set(i * 15 - 15 + (j - 1.5) * 3, 5, 0);
                    substation.add(fin);
                }
                
                // High voltage insulators
                for (let k = 0; k < 3; k++) {
                    const insulator = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.3, 3, 12),
                        new THREE.MeshPhongMaterial({ color: 0x8B4513 })
                    );
                    insulator.position.set(i * 15 - 15, 10, (k - 1) * 4);
                    substation.add(insulator);
                }
            }
            
            // Control building with enhanced details
            const controlBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(15, 8, 10),
                new THREE.MeshPhongMaterial({ color: 0x8B4513 })
            );
            controlBuilding.position.set(-35, 4, 0);
            controlBuilding.castShadow = true;
            controlBuilding.receiveShadow = true;
            substation.add(controlBuilding);
            
            // Control room windows
            for (let i = 0; i < 3; i++) {
                const window = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 1.5, 0.1),
                    new THREE.MeshPhongMaterial({ 
                        color: 0x87CEEB, 
                        transparent: true, 
                        opacity: 0.7 
                    })
                );
                window.position.set(-35 + (i - 1) * 3, 5, 5.05);
                substation.add(window);
            }
            
            // Switchyard equipment
            for (let i = 0; i < 6; i++) {
                // Circuit breakers
                const breaker = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 3, 1),
                    new THREE.MeshPhongMaterial({ color: 0x2F4F4F })
                );
                breaker.position.set((i - 2.5) * 8, 1.5, -15);
                substation.add(breaker);
                
                // Support structures
                const support = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 8, 8),
                    new THREE.MeshPhongMaterial({ color: 0x708090 })
                );
                support.position.set((i - 2.5) * 8, 4, -15);
                substation.add(support);
            }
            
            // Perimeter fence for substation
            const substationFence = createSecurityPerimeter(80, 50);
            substation.add(substationFence);
            
            return substation;
        }

        function createConnectingHighway() {
            const expressway = new THREE.Group();
            
            // Main highway - Multi-lane
            const road = new THREE.Mesh(
                new THREE.BoxGeometry(200, 0.2, 20),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            expressway.add(road);
            
            // Road markings - Lane dividers
            for (let i = -8; i <= 8; i++) {
                const marking = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 0.3, 0.3),
                    new THREE.MeshBasicMaterial({ color: 0xffffff })
                );
                marking.position.set(i * 12, 0.1, 0);
                expressway.add(marking);
            }
            
            // Center median barrier
            const medianBarrier = new THREE.Mesh(
                new THREE.BoxGeometry(200, 1.2, 1),
                new THREE.MeshPhongMaterial({ color: 0x808080 })
            );
            medianBarrier.position.y = 0.6;
            expressway.add(medianBarrier);
            
            // Side barriers/guardrails
            for (let side = -1; side <= 1; side += 2) {
                const barrier = new THREE.Mesh(
                    new THREE.BoxGeometry(200, 1, 0.5),
                    new THREE.MeshPhongMaterial({ color: 0x606060 })
                );
                barrier.position.set(0, 0.5, side * 10.5);
                expressway.add(barrier);
            }
            
            // Highway signs
            const signPositions = [-60, 60];
            signPositions.forEach(x => {
                // Sign post
                const signPost = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 8, 8),
                    new THREE.MeshPhongMaterial({ color: 0x404040 })
                );
                signPost.position.set(x, 4, 15);
                expressway.add(signPost);
                
                // Sign board
                const sign = new THREE.Mesh(
                    new THREE.BoxGeometry(12, 4, 0.5),
                    new THREE.MeshPhongMaterial({ color: 0x0066cc })
                );
                sign.position.set(x, 6, 15);
                expressway.add(sign);
                
                // Sign text simulation (white rectangles)
                for (let i = 0; i < 2; i++) {
                    const text = new THREE.Mesh(
                        new THREE.BoxGeometry(10, 1, 0.1),
                        new THREE.MeshBasicMaterial({ color: 0xffffff })
                    );
                    text.position.set(x, 6.5 - i * 1.5, 15.3);
                    expressway.add(text);
                }
            });
            
            // Highway lighting
            for (let i = -4; i <= 4; i++) {
                for (let side = -1; side <= 1; side += 2) {
                    const lightPost = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.15, 0.15, 12, 8),
                        new THREE.MeshPhongMaterial({ color: 0x404040 })
                    );
                    lightPost.position.set(i * 25, 6, side * 12);
                    expressway.add(lightPost);
                    
                    // Light fixture
                    const light = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 1, 1),
                        new THREE.MeshLambertMaterial({ 
                            color: 0xffffcc,
                            emissive: 0xffffcc,
                            emissiveIntensity: 0.3
                        })
                    );
                    light.position.set(i * 25, 11, side * 12);
                    expressway.add(light);
                }
            }
            
            return expressway;
        }
        
        // Create Transmission Tower
        function createTransmissionTower() {
            const tower = new THREE.Group();
            
            // Main tower structure (simplified lattice)
            const mainStructure = new THREE.Mesh(
                new THREE.CylinderGeometry(1, 3, 40, 4),
                new THREE.MeshPhongMaterial({ color: 0x708090 })
            );
            mainStructure.position.y = 20;
            tower.add(mainStructure);
            
            // Cross arms for power lines
            for (let i = 0; i < 3; i++) {
                const crossArm = new THREE.Mesh(
                    new THREE.BoxGeometry(25, 1, 1),
                    new THREE.MeshPhongMaterial({ color: 0x708090 })
                );
                crossArm.position.y = 35 - i * 5;
                tower.add(crossArm);
                
                // Insulators and power lines
                for (let j = -1; j <= 1; j++) {
                    const insulator = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.5, 2, 8),
                        new THREE.MeshPhongMaterial({ color: 0x8B4513 })
                    );
                    insulator.position.set(j * 8, 35 - i * 5 - 1.5, 0);
                    tower.add(insulator);
                }
            }
            
            // Tower base foundation
            const foundation = new THREE.Mesh(
                new THREE.BoxGeometry(8, 2, 8),
                new THREE.MeshPhongMaterial({ color: 0x696969 })
            );
            foundation.position.y = 1;
            tower.add(foundation);
            
            // Guy wires (simplified)
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const guyWire = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 30, 6),
                    new THREE.MeshPhongMaterial({ color: 0x2F4F4F })
                );
                guyWire.position.set(
                    Math.cos(angle) * 15,
                    15,
                    Math.sin(angle) * 15
                );
                guyWire.rotation.z = Math.atan2(15, 15);
                guyWire.rotation.y = angle;
                tower.add(guyWire);
                
                // Guy wire anchor
                const anchor = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 1, 2),
                    new THREE.MeshPhongMaterial({ color: 0x696969 })
                );
                anchor.position.set(
                    Math.cos(angle) * 20,
                    0.5,
                    Math.sin(angle) * 20
                );
                tower.add(anchor);
            }
            
            return tower;
        }
        
        // Create 500KV Transmission Lines
        function create500KVTransmissionLines() {
            const lineGroup = new THREE.Group();
            
            // Transmission lines connecting substation to grid - adjusted for far right position
            const linePoints = [
                new THREE.Vector3(470, 35, 35),
                new THREE.Vector3(500, 35, 60),
                new THREE.Vector3(550, 35, 80),
                new THREE.Vector3(600, 35, 100)
            ];
            
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x404040, linewidth: 3 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            
            scene.add(line);
        }
        
        // Create Security Perimeter
        function createSecurityPerimeter(width, depth) {
            const perimeter = new THREE.Group();
            
            // Fence posts
            const postPositions = [];
            const spacing = 8;
            
            // Calculate fence posts around perimeter
            for (let x = -width/2; x <= width/2; x += spacing) {
                postPositions.push({ x: x, z: -depth/2 });
                postPositions.push({ x: x, z: depth/2 });
            }
            for (let z = -depth/2; z <= depth/2; z += spacing) {
                postPositions.push({ x: -width/2, z: z });
                postPositions.push({ x: width/2, z: z });
            }
            
            postPositions.forEach(pos => {
                const post = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 3, 8),
                    new THREE.MeshPhongMaterial({ color: 0x404040 })
                );
                post.position.set(pos.x, 1.5, pos.z);
                perimeter.add(post);
            });
            
            // Fence mesh (simplified)
            const fenceGeometry = new THREE.BoxGeometry(width, 3, 0.1);
            const fenceMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x606060,
                transparent: true,
                opacity: 0.7
            });
            
            // Four fence sides
            const fenceSides = [
                { pos: [0, 1.5, -depth/2], rot: [0, 0, 0] },
                { pos: [0, 1.5, depth/2], rot: [0, 0, 0] },
                { pos: [-width/2, 1.5, 0], rot: [0, Math.PI/2, 0] },
                { pos: [width/2, 1.5, 0], rot: [0, Math.PI/2, 0] }
            ];
            
            fenceSides.forEach(side => {
                const fence = new THREE.Mesh(fenceGeometry, fenceMaterial);
                fence.position.set(...side.pos);
                fence.rotation.set(...side.rot);
                perimeter.add(fence);
            });
            
            // Barbed wire on top
            for (let x = -width/2; x <= width/2; x += spacing) {
                const barbedWire = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, spacing, 6),
                    new THREE.MeshPhongMaterial({ color: 0x2F4F4F })
                );
                barbedWire.position.set(x, 3.2, -depth/2);
                barbedWire.rotation.z = Math.PI / 2;
                perimeter.add(barbedWire);
                
                barbedWire.position.set(x, 3.2, depth/2);
                perimeter.add(barbedWire.clone());
            }
            
            return perimeter;
        }
        
        // Create Cooling Facility
        function createCoolingFacility() {
            const coolingFacility = new THREE.Group();
            
            // Main cooling tower
            const coolingTower = new THREE.Mesh(
                new THREE.CylinderGeometry(15, 20, 30, 16),
                new THREE.MeshPhongMaterial({ color: 0x708090 })
            );
            coolingTower.position.y = 15;
            coolingFacility.add(coolingTower);
            
            // Cooling tower top
            const towerTop = new THREE.Mesh(
                new THREE.CylinderGeometry(12, 15, 5, 16),
                new THREE.MeshPhongMaterial({ color: 0x606060 })
            );
            towerTop.position.y = 32.5;
            coolingFacility.add(towerTop);
            
            // Steam effect (simplified)
            for (let i = 0; i < 5; i++) {
                const steam = new THREE.Mesh(
                    new THREE.SphereGeometry(2 + i, 8, 6),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xf0f0f0,
                        transparent: true,
                        opacity: 0.3 - i * 0.05
                    })
                );
                steam.position.set(
                    (Math.random() - 0.5) * 10,
                    35 + i * 3,
                    (Math.random() - 0.5) * 10
                );
                coolingFacility.add(steam);
            }
            
            // Auxiliary cooling equipment
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const auxCooler = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 4, 4),
                    new THREE.MeshPhongMaterial({ color: 0x4682b4 })
                );
                auxCooler.position.set(
                    Math.cos(angle) * 25,
                    2,
                    Math.sin(angle) * 25
                );
                coolingFacility.add(auxCooler);
            }
            
            return coolingFacility;
        }
        
        // Create Fuel Storage
        function createFuelStorage() {
            const fuelStorage = new THREE.Group();
            
            // Main fuel tanks
            for (let i = 0; i < 3; i++) {
                const tank = new THREE.Mesh(
                    new THREE.CylinderGeometry(8, 8, 12, 16),
                    new THREE.MeshPhongMaterial({ color: 0x8B0000 })
                );
                tank.position.set(i * 20 - 20, 6, 0);
                tank.rotation.z = Math.PI / 2;
                fuelStorage.add(tank);
                
                // Tank supports
                for (let j = 0; j < 4; j++) {
                    const support = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.5, 4, 8),
                        new THREE.MeshPhongMaterial({ color: 0x2F4F4F })
                    );
                    const angle = (j / 4) * Math.PI * 2;
                    support.position.set(
                        i * 20 - 20 + Math.cos(angle) * 6,
                        2,
                        Math.sin(angle) * 6
                    );
                    fuelStorage.add(support);
                }
                
                // Fuel gauge
                const gauge = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 2, 0.5),
                    new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
                );
                gauge.position.set(i * 20 - 20, 6, 8.5);
                fuelStorage.add(gauge);
            }
            
            // Fuel pumping station
            const pumpStation = new THREE.Mesh(
                new THREE.BoxGeometry(6, 4, 4),
                new THREE.MeshPhongMaterial({ color: 0x228B22 })
            );
            pumpStation.position.set(0, 2, -15);
            fuelStorage.add(pumpStation);
            
            // Containment wall
            const containmentWall = createSecurityPerimeter(80, 30);
            fuelStorage.add(containmentWall);
            
            return fuelStorage;
        }
        
        // Create Data Center Landscaping
        function createDataCenterLandscaping() {
            // Add trees and green areas connecting smart city to data centers
            const treePositions = [
                // Around data centers
                { x: 480, z: 0 }, { x: 485, z: -5 }, { x: 475, z: 5 },
                { x: 320, z: 80 }, { x: 315, z: 85 }, { x: 325, z: 75 },
                { x: 460, z: 90 }, { x: 465, z: 95 }, { x: 455, z: 85 },
                { x: 380, z: -10 }, { x: 385, z: -15 }, { x: 375, z: -5 },
                // Connecting corridor trees (between city and DC)
                { x: 150, z: 20 }, { x: 160, z: 25 }, { x: 140, z: 15 },
                { x: 200, z: 30 }, { x: 210, z: 35 }, { x: 190, z: 25 },
                { x: 250, z: 40 }, { x: 260, z: 45 }, { x: 240, z: 35 },
                { x: 300, z: 20 }, { x: 310, z: 25 }, { x: 290, z: 15 }
            ];
            
            treePositions.forEach(pos => {
                const tree = createTree();
                tree.position.set(pos.x, 0, pos.z);
                tree.scale.setScalar(1.2);
                trees.push(tree);
                scene.add(tree);
            });
            
            // Add grass areas creating connection between city and data centers
            const grassPositions = [
                // Around data centers
                { x: 400, z: 0, size: 30 },
                { x: 370, z: 80, size: 25 },
                { x: 460, z: 90, size: 20 },
                { x: 430, z: 30, size: 35 },
                // Connecting green corridor
                { x: 180, z: 20, size: 25 },
                { x: 220, z: 40, size: 30 },
                { x: 280, z: 30, size: 20 },
                { x: 120, z: 60, size: 15 }
            ];
            
            grassPositions.forEach(pos => {
                const grass = new THREE.Mesh(
                    new THREE.CircleGeometry(pos.size, 16),
                    new THREE.MeshPhongMaterial({ color: 0x228B22 })
                );
                grass.rotation.x = -Math.PI / 2;
                grass.position.set(pos.x, 0.05, pos.z);
                scene.add(grass);
            });
        }

        // Create ground-level outdoor parking only (4-story structures removed)
        function createParkingInfrastructure() {
            console.log('üÖøÔ∏è Creating Ground-Level Outdoor Parking Only...');
            console.log('üîç DEBUG: createParkingInfrastructure() started');
            
            // Create EV charging stations that are clearly visible
            createVisibleEVStations();
            
            // Surface parking lots with better markings (ground level only)
            const parkingLotPositions = [
                { x: -120, z: 50, width: 20, depth: 15 },  // Ground level
                { x: 120, z: -50, width: 17, depth: 20 },   // Ground level  
                { x: 50, z: 50, width: 22, depth: 17 },     // Ground level
                { x: -50, z: -50, width: 20, depth: 20 }    // Ground level
            ];
            
            parkingLotPositions.forEach((lot, index) => {
                // Add type to lot configuration
                lot.type = index === 0 ? 'ev_charging' : (index === 1 ? 'smart' : 'smart');
                const parkingLot = createGroundLevelParkingLot(lot);
                parkingLots.push(parkingLot);
                scene.add(parkingLot);
            });
            
            // Add realistic parking lot demonstration (ground level)
            const realisticParkingDemo = setupRealisticParkingLot();
            realisticParkingDemo.position.set(150, 0, 150);
            scene.add(realisticParkingDemo);
            parkingLots.push(realisticParkingDemo);
            
            // Add cars to outdoor parking areas
            addCarsToOutdoorParking();
            
            // Restore grass area where parking structure was removed
            restoreGrassArea();
            
            // Add circular green areas throughout the city
            restoreGreenAreas();
            
            // CREATE NEW DATA CENTER AT EAST POSITION - DELAYED
            console.log('üèóÔ∏è Scheduling data center creation after scene loads...');
            setTimeout(() => {
                try {
                    console.log('üèóÔ∏è Creating data center at east position...');
                    createEastDataCenter();
                    console.log('‚úÖ East data center created successfully');
                } catch (dataCenterError) {
                    console.error('‚ùå Error creating data center:', dataCenterError);
                    console.log('‚ö†Ô∏è Data center creation failed but scene continues...');
                }
            }, 3000); // Delay 3 seconds after scene loads
            
            console.log('‚úÖ Ground-Level Outdoor Parking created (no multi-story structures)');
        }

        // Function to remove all parking structures (4-story buildings) - FIXED
        function removeAllParkingStructures() {
            console.log("üóëÔ∏è Removing parking structures safely (preserving rivers & data centers)...");
            
            const objectsToRemove = [];
            
            // CRITICAL FIX: Create a copy to avoid modification during iteration
            const sceneChildrenCopy = scene.children.slice();
            for (let i = 0; i < Math.min(sceneChildrenCopy.length, 1000); i++) {
                const child = sceneChildrenCopy[i];
                if (!child) continue;
                
                try {
                    // CH·ªà X√ìA C√ÅC ƒê·ªêI T∆Ø·ª¢NG C√ì ƒê√ÅNH D·∫§U PARKING_STRUCTURE
                    if (child.userData && child.userData.type === 'parking_structure') {
                        objectsToRemove.push(child);
                        continue;
                    }
                } catch (childError) {
                    console.warn('‚ö†Ô∏è Error processing parking child:', childError);
                    continue;
                }
                
                const pos = child.position;
                
                // CH·ªà TRONG V√ôNG PARKING C·ª§ TH·ªÇ (-60 ƒë·∫øn -40, 40 ƒë·∫øn 60)
                if (pos.x >= -60 && pos.x <= -40 && 
                    pos.z >= 40 && pos.z <= 60) {
                    
                    // B·∫¢O V·ªÜ: KH√îNG X√ìA RIVER, DATA CENTERS, BUILDINGS, GREEN AREAS (NGUY√äN B·∫¢N)
                    if (child.userData && (
                        child.userData.type === 'river' ||
                        child.userData.type === 'water_ripple' ||
                        child.userData.type === 'data_center' ||
                        child.userData.type === 'data_center_led' ||
                        child.userData.type === 'data_center_antenna' ||
                        child.userData.type === 'data_center_sign' ||
                        child.userData.type === 'building' ||
                        child.userData.type === 'tree' ||
                        child.userData.type === 'grass' ||
                        child.userData.type === 'green_area' ||
                        child.userData.type === 'green_area_tree' ||
                        child.userData.type === 'green_area_leaves' ||
                        child.userData.type === 'green_area_bush' ||
                        child.userData.type === 'green_area_path' ||
                        child.userData.originalId !== undefined || // B·∫¢O V·ªÜ OBJECTS NGUY√äN B·∫¢N
                        child.userData.restored === true || // B·∫¢O V·ªÜ OBJECTS ƒê√É KH√îI PH·ª§C
                        child.userData.type === 'tech_park_base' ||
                        child.userData.type === 'data_center_complex' ||
                        child.userData.type === 'data_center_equipment' ||
                        child.userData.type === 'cooling_unit' ||
                        child.userData.type === 'status_led' ||
                        child.userData.type === 'substation' ||
                        child.userData.type === 'transformer' ||
                        child.userData.type === 'power_line' ||
                        child.userData.type === 'access_road' ||
                        child.userData.type === 'internal_road' ||
                        child.userData.type === 'security_building' ||
                        child.userData.type === 'maintenance_building' ||
                        child.userData.type === 'perimeter_fence' // B·∫¢O V·ªÜ DATA CENTER COMPLEX
                    )) {
                        continue; // B·ªé QUA, KH√îNG X√ìA
                    }
                    
                    // CH·ªà X√ìA C√ÅC TH√ÄNH PH·∫¶N PARKING C·ª§ TH·ªÇ
                    if (child.material && child.material.color &&
                        (child.material.color.getHex() === 0x888888) && pos.y > 1) {
                        objectsToRemove.push(child);
                    }
                    
                    // X√≥a c·ªôt tr·ª• parking (CylinderGeometry ·ªü t·∫ßng cao)
                    if (child.geometry && child.geometry.type === 'CylinderGeometry' &&
                        pos.y > 2) {
                        objectsToRemove.push(child);
                    }
                    
                    // X√≥a xe trong garage (tr√™n t·∫ßng 1)
                    if (child.userData && child.userData.type === 'car' && pos.y > 1.5) {
                        objectsToRemove.push(child);
                    }
                }
            }
            
            objectsToRemove.forEach(obj => {
                scene.remove(obj);
            });
            
            console.log(`‚úÖ Safely removed ${objectsToRemove.length} parking structure elements`);
            console.log("üõ°Ô∏è Rivers and data centers preserved");
            
            // Automatically restore grass area after removing parking structures
            setTimeout(() => {
                restoreGrassArea();
            }, 500);
            
            return objectsToRemove.length;
        }

        // Ground-level parking only (removed multi-story garage)
        function createGroundLevelParkingLot(config) {
            const lot = new THREE.Group();
            
            // Asphalt base (ground level only)
            const asphalt = new THREE.Mesh(
                new THREE.BoxGeometry(config.width, 0.2, config.depth),
                new THREE.MeshLambertMaterial({ color: 0x333333 })
            );
            asphalt.receiveShadow = true;
            lot.add(asphalt);
            
            // Parking lines (white stripes)
            for (let i = 0; i < 8; i++) {
                const line = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.15, config.depth * 0.8),
                    new THREE.MeshBasicMaterial({ color: 0xffffff })
                );
                line.position.set(
                    -config.width/2 + (i + 1) * (config.width/9),
                    0.12,
                    0
                );
                lot.add(line);
            }
            
            // Smart parking sign (ground level)
            const sign = new THREE.Mesh(
                new THREE.BoxGeometry(12, 6, 0.5),
                new THREE.MeshBasicMaterial({ color: 0x00aaff })
            );
            sign.position.set(0, 4, config.depth/2 - 2);
            lot.add(sign);
            
            lot.position.set(config.x, 0, config.z);
            return lot;
        }

        // Add cars to outdoor parking areas
        function addCarsToOutdoorParking() {
            const carColors = [0x0066cc, 0xcc0000, 0x00cc66, 0xcccc00, 0x6600cc, 0xffffff];
            
            // B√£i ƒë·∫≠u xe 1 (position adjusted for actual parking lot locations)
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 6; col++) {
                    if (Math.random() < 0.6) { // 60% c√≥ xe
                        const carX = -120 + (col * 3) - 8;
                        const carZ = 50 + (row * 4) - 6;
                        
                        const car = createCar(carColors[Math.floor(Math.random() * carColors.length)]);
                        car.position.set(carX, 0.3, carZ);
                        car.userData = { type: 'car', location: 'outdoor' };
                        scene.add(car);
                    }
                }
            }
            
            // B√£i ƒë·∫≠u xe 2
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 5; col++) {
                    if (Math.random() < 0.5) { // 50% c√≥ xe
                        const carX = 120 + (col * 3) - 6;
                        const carZ = -50 + (row * 4) - 4;
                        
                        const car = createCar(carColors[Math.floor(Math.random() * carColors.length)]);
                        car.position.set(carX, 0.3, carZ);
                        car.userData = { type: 'car', location: 'outdoor' };
                        scene.add(car);
                    }
                }
            }
            
            // B√£i ƒë·∫≠u xe 3
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 6; col++) {
                    if (Math.random() < 0.7) { // 70% c√≥ xe
                        const carX = 50 + (col * 3) - 8;
                        const carZ = 50 + (row * 4) - 4;
                        
                        const car = createCar(carColors[Math.floor(Math.random() * carColors.length)]);
                        car.position.set(carX, 0.3, carZ);
                        car.userData = { type: 'car', location: 'outdoor' };
                        scene.add(car);
                    }
                }
            }
            
            // B√£i ƒë·∫≠u xe 4
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 5; col++) {
                    if (Math.random() < 0.4) { // 40% c√≥ xe
                        const carX = -50 + (col * 3) - 6;
                        const carZ = -50 + (row * 4) - 4;
                        
                        const car = createCar(carColors[Math.floor(Math.random() * carColors.length)]);
                        car.position.set(carX, 0.3, carZ);
                        car.userData = { type: 'car', location: 'outdoor' };
                        scene.add(car);
                    }
                }
            }
            
            console.log("‚úÖ Cars added to outdoor parking areas");
        }

        // Remove all outdoor cars
        function removeOutdoorCars() {
            const carsToRemove = [];
            
            // SAFE iteration to avoid modification during iteration
            const sceneChildren = scene.children.slice();
            for (let i = 0; i < Math.min(sceneChildren.length, 1000); i++) {
                const child = sceneChildren[i];
                if (child && child.userData && child.userData.type === 'car' && child.userData.location === 'outdoor') {
                    carsToRemove.push(child);
                }
            }
            
            carsToRemove.forEach(car => {
                scene.remove(car);
            });
            
            console.log(`üöó Removed ${carsToRemove.length} outdoor cars`);
            return carsToRemove.length;
        }

        // Restore grass area where parking structure was removed
        function restoreGrassArea() {
            console.log('üå± Restoring grass area at old parking structure location...');
            
            // Kh√¥i ph·ª•c b√£i c·ªè ·ªü v·ªã tr√≠ nh√† xe c≈© (-50, 50 area)
            const grassGeometry = new THREE.PlaneGeometry(45, 35);
            const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.rotation.x = -Math.PI / 2;
            grass.position.set(-50, 0.1, 50);
            grass.userData = { type: 'grass_restoration' };
            scene.add(grass);
            
            // Th√™m v√†i c√¢y ·ªü v·ªã tr√≠ c≈© c·ªßa parking garage
            for (let i = 0; i < 8; i++) {
                const treeX = -50 + (Math.random() * 40 - 20);
                const treeZ = 50 + (Math.random() * 30 - 15);
                
                // Th√¢n c√¢y
                const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 3);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(treeX, 1.5, treeZ);
                trunk.userData = { type: 'tree_restoration' };
                scene.add(trunk);
                
                // T√°n l√°
                const leavesGeometry = new THREE.SphereGeometry(2);
                const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.set(treeX, 3.5, treeZ);
                leaves.userData = { type: 'leaves_restoration' };
                scene.add(leaves);
            }
            
            // Th√™m m·ªôt s·ªë b·ª•i c·ªè nh·ªè
            for (let i = 0; i < 15; i++) {
                const bushX = -50 + (Math.random() * 40 - 20);
                const bushZ = 50 + (Math.random() * 30 - 15);
                
                const bushGeometry = new THREE.SphereGeometry(0.8);
                const bushMaterial = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
                const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                bush.position.set(bushX, 0.8, bushZ);
                bush.userData = { type: 'bush_restoration' };
                scene.add(bush);
            }
            
            console.log('‚úÖ Grass area and trees restored at parking structure location');
        }

        // Remove grass restoration
        function removeGrassRestoration() {
            const elementsToRemove = [];
            
            // SAFE iteration to avoid modification during iteration
            const sceneChildren = scene.children.slice();
            for (let i = 0; i < Math.min(sceneChildren.length, 1000); i++) {
                const child = sceneChildren[i];
                if (child && child.userData && (
                    child.userData.type === 'grass_restoration' ||
                    child.userData.type === 'tree_restoration' ||
                    child.userData.type === 'leaves_restoration' ||
                    child.userData.type === 'bush_restoration'
                )) {
                    elementsToRemove.push(child);
                }
            }
            
            elementsToRemove.forEach(element => {
                scene.remove(element);
            });
            
            console.log(`üåø Removed ${elementsToRemove.length} grass restoration elements`);
            return elementsToRemove.length;
        }

        // KH·∫®N C·∫§P: Kh√¥i ph·ª•c river system b·ªã x√≥a nh·∫ßm
        function restoreRiverSystem() {
            console.log("üö® KH·∫®N C·∫§P: Kh√¥i ph·ª•c river system...");
            
            try {
                // D√≤ng s√¥ng ch√≠nh (t·ª´ h√¨nh ·∫£nh c√≥ th·ªÉ th·∫•y ·ªü ph√≠a d∆∞·ªõi b√™n ph·∫£i)
                const riverSegments = [
                    { x: 20, z: -25, width: 8, length: 15, rotation: 0 },
                    { x: 30, z: -15, width: 6, length: 12, rotation: Math.PI/4 },
                    { x: 25, z: -5, width: 8, length: 10, rotation: 0 },
                    { x: 15, z: 5, width: 10, length: 8, rotation: -Math.PI/6 }
                ];
                
                let addedSegments = 0;
                riverSegments.forEach((segment, index) => {
                    try {
                        const riverGeometry = new THREE.PlaneGeometry(segment.width, segment.length);
                        const riverMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x4A90E2,
                            transparent: true,
                            opacity: 0.7
                        });
                        const riverSegment = new THREE.Mesh(riverGeometry, riverMaterial);
                        riverSegment.rotation.x = -Math.PI / 2;
                        riverSegment.rotation.z = segment.rotation;
                        riverSegment.position.set(segment.x, 0.1, segment.z);
                        riverSegment.userData = { type: 'river', id: index };
                        scene.add(riverSegment);
                        addedSegments++;
                        console.log(`‚úÖ River segment ${index} added at (${segment.x}, ${segment.z})`);
                    } catch (error) {
                        console.error(`‚ùå Error creating river segment ${index}:`, error);
                    }
                });
                
                // Th√™m hi·ªáu ·ª©ng s√≥ng n∆∞·ªõc
                let addedRipples = 0;
                for (let i = 0; i < 20; i++) {
                    try {
                        const rippleGeometry = new THREE.RingGeometry(0.5, 1);
                        const rippleMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x87CEEB,
                            transparent: true,
                            opacity: 0.3
                        });
                        const ripple = new THREE.Mesh(rippleGeometry, rippleMaterial);
                        ripple.rotation.x = -Math.PI / 2;
                        ripple.position.set(
                            20 + Math.random() * 20,
                            0.15,
                            -25 + Math.random() * 30
                        );
                        ripple.userData = { type: 'water_ripple', id: i };
                        scene.add(ripple);
                        addedRipples++;
                    } catch (error) {
                        console.error(`‚ùå Error creating ripple ${i}:`, error);
                    }
                }
                
                console.log(`‚úÖ River system restored: ${addedSegments} segments, ${addedRipples} ripples`);
                console.log(`üìä Scene now has ${scene.children.length} total objects`);
                
            } catch (error) {
                console.error("‚ùå Critical error in restoreRiverSystem:", error);
            }
        }

        // KH·∫®N C·∫§P: Kh√¥i ph·ª•c data centers b·ªã x√≥a nh·∫ßm  
        // DISABLED OLD FUNCTION - PROPERLY COMMENTED OUT
        /* function restoreDataCenters() {
            console.log("üö® KH·∫®N C·∫§P: Kh√¥i ph·ª•c data centers...");
            
            try {
                // Data centers (c√°c t√≤a nh√† xanh ƒë·∫∑c bi·ªát t·ª´ h√¨nh ·∫£nh)
                const dataCenters = [
                    { x: -30, z: 15, color: 0x00CED1 },   // T√≤a xanh ng·ªçc
                    { x: 35, z: 20, color: 0x40E0D0 },    // T√≤a xanh lam
                    { x: -25, z: -30, color: 0x48D1CC },  // T√≤a xanh bi·ªÉn
                    { x: -80, z: -80, color: 0x00CED1 },  // T√≤a b·ªï sung
                    { x: 80, z: 80, color: 0x40E0D0 }     // T√≤a b·ªï sung
                ];
                
                let addedDataCenters = 0;
                let addedLeds = 0;
                let addedAntennas = 0;
                let addedSigns = 0;
                
                dataCenters.forEach((dc, index) => {
                    try {
                        // T√≤a nh√† ch√≠nh
                        const buildingGeometry = new THREE.BoxGeometry(6, 15, 6);
                        const buildingMaterial = new THREE.MeshLambertMaterial({ color: dc.color });
                        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                        building.position.set(dc.x, 7.5, dc.z);
                        building.userData = { type: 'data_center', id: index };
                        scene.add(building);
                        addedDataCenters++;
                        console.log(`‚úÖ Data center ${index} added at (${dc.x}, ${dc.z}) with color #${dc.color.toString(16)}`);
                        
                        // ƒê√®n LED ch·ªâ b√°o ho·∫°t ƒë·ªông
                        for (let i = 0; i < 12; i++) {
                            try {
                                const ledGeometry = new THREE.SphereGeometry(0.2);
                                const ledMaterial = new THREE.MeshLambertMaterial({ 
                                    color: 0x00FF00,
                                    emissive: 0x004400
                                });
                                const led = new THREE.Mesh(ledGeometry, ledMaterial);
                                led.position.set(
                                    dc.x + (Math.random() - 0.5) * 5,
                                    5 + Math.random() * 8,
                                    dc.z + (Math.random() - 0.5) * 5
                                );
                                led.userData = { type: 'data_center_led', parentId: index };
                                scene.add(led);
                                addedLeds++;
                            } catch (error) {
                                console.error(`‚ùå Error creating LED ${i} for data center ${index}:`, error);
                            }
                        }
                        
                        // Anten/thi·∫øt b·ªã tr√™n m√°i
                        try {
                            const antennaGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3);
                            const antennaMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                            const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                            antenna.position.set(dc.x, 16.5, dc.z);
                            antenna.userData = { type: 'data_center_antenna', parentId: index };
                            scene.add(antenna);
                            addedAntennas++;
                        } catch (error) {
                            console.error(`‚ùå Error creating antenna for data center ${index}:`, error);
                        }
                        
                        // Bi·ªÉn b√°o "DATA CENTER" v·ªõi m√†u t∆∞∆°ng ·ª©ng
                        try {
                            const signGeometry = new THREE.BoxGeometry(8, 2, 0.2);
                            const signMaterial = new THREE.MeshBasicMaterial({ color: dc.color });
                            const sign = new THREE.Mesh(signGeometry, signMaterial);
                            sign.position.set(dc.x, 4, dc.z + 3.5);
                            sign.userData = { type: 'data_center_sign', parentId: index };
                            scene.add(sign);
                            addedSigns++;
                        } catch (error) {
                            console.error(`‚ùå Error creating sign for data center ${index}:`, error);
                        }
                        
                    } catch (error) {
                        console.error(`‚ùå Error creating data center ${index}:`, error);
                    }
                });
                
                console.log(`‚úÖ Data centers restored: ${addedDataCenters} buildings, ${addedLeds} LEDs, ${addedAntennas} antennas, ${addedSigns} signs`);
                console.log(`üìä Scene now has ${scene.children.length} total objects`);
                
            } catch (error) {
                console.error("‚ùå Critical error in restoreDataCenters:", error);
            }
        } */

        // KH·∫®N C·∫§P: Kh√¥i ph·ª•c to√†n b·ªô h·ªá th·ªëng b·ªã x√≥a nh·∫ßm
        function emergencyRestore() {
            console.log("üö® B·∫ÆT ƒê·∫¶U KH√îI PH·ª§C KH·∫®N C·∫§P NGUY√äN B·∫¢N...");
            
            restoreOriginalRiver();
            // DISABLED - restoreOriginalDataCenters();
            restoreGreenAreas();
            
            console.log("‚úÖ HO√ÄN TH√ÄNH KH√îI PH·ª§C KH·∫®N C·∫§P NGUY√äN B·∫¢N!");
            
            // DEBUG: Ki·ªÉm tra ƒë·ªëi t∆∞·ª£ng ƒë√£ ƒë∆∞·ª£c t·∫°o ch∆∞a
            setTimeout(() => {
                debugSceneObjects();
            }, 1000);
        }

        // KH√îI PH·ª§C RIVER SYSTEM NGUY√äN B·∫¢N
        function restoreOriginalRiver() {
            console.log("üîç Restoring ORIGINAL river system...");
            
            // Ki·ªÉm tra xem c√≥ river n√†o c√≤n l·∫°i kh√¥ng - SAFE iteration
            let existingRivers = [];
            const sceneChildren = scene.children.slice();
            for (let i = 0; i < Math.min(sceneChildren.length, 1000); i++) {
                const child = sceneChildren[i];
                if (child && child.userData && child.userData.type === 'river') {
                    existingRivers.push(child);
                }
            }
            
            console.log(`Found ${existingRivers.length} existing rivers`);
            
            // N·∫øu kh√¥ng c√≥ river n√†o, t√¨m c√°c objects c√≥ th·ªÉ l√† river (m√†u xanh, h√¨nh ph·∫≥ng)
            if (existingRivers.length === 0) {
                let restoredRivers = 0;
                const sceneChildren2 = scene.children.slice();
                for (let i = 0; i < Math.min(sceneChildren2.length, 1000); i++) {
                    const child = sceneChildren2[i];
                    if (child && child.material && child.material.color) {
                        try {
                            const color = child.material.color.getHex();
                            if ((color === 0x4A90E2 || color === 0x1E90FF || color === 0x87CEEB || color === 0x0080FF) && 
                                child.geometry && child.geometry.type === 'PlaneGeometry' &&
                                child.position.y < 0.5) {
                                child.userData = { type: 'river', restored: true };
                                console.log("‚úÖ Restored river object at:", child.position);
                                restoredRivers++;
                            }
                        } catch (error) {
                            console.warn('‚ö†Ô∏è Error processing river child:', error);
                        }
                    }
                }
                
                // N·∫øu v·∫´n kh√¥ng t√¨m th·∫•y, t·∫°o river system c∆° b·∫£n
                if (restoredRivers === 0) {
                    console.log("üèóÔ∏è Creating basic river system...");
                    
                    // T·∫°o river segments ƒë∆°n gi·∫£n
                    const riverSegments = [
                        { x: 25, z: -20, width: 30, height: 8 },
                        { x: 30, z: 0, width: 8, height: 25 },
                        { x: 15, z: 15, width: 20, height: 6 }
                    ];
                    
                    riverSegments.forEach((segment, index) => {
                        const riverGeometry = new THREE.PlaneGeometry(segment.width, segment.height);
                        const riverMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x4A90E2,
                            transparent: true,
                            opacity: 0.8
                        });
                        const river = new THREE.Mesh(riverGeometry, riverMaterial);
                        river.rotation.x = -Math.PI / 2;
                        river.position.set(segment.x, 0.05, segment.z);
                        river.userData = { type: 'river', originalId: index };
                        scene.add(river);
                        console.log(`‚úÖ Created river segment ${index} at (${segment.x}, ${segment.z})`);
                    });
                }
            }
            
            console.log("‚úÖ Original river system restoration complete");
        }

        // KH√îI PH·ª§C DATA CENTERS NGUY√äN B·∫¢N - IMPROVED VERSION
        // DISABLED OLD FUNCTION
        /* function restoreOriginalDataCenters() {
            console.log("üîç Restoring ORIGINAL data centers...");
            
            let restoredDataCenters = 0;
            
            // T√¨m c√°c t√≤a nh√† c√≥ th·ªÉ l√† data centers (cao, m√†u xanh ƒë·∫∑c bi·ªát)
            scene.children.forEach(child => {
                if (child.geometry && child.geometry.type === 'BoxGeometry' && 
                    child.material && child.material.color) {
                    
                    const color = child.material.color.getHex();
                    const pos = child.position;
                    
                    // Ki·ªÉm tra m√†u s·∫Øc ƒë·∫∑c tr∆∞ng c·ªßa data centers
                    if (color === 0x00CED1 || color === 0x40E0D0 || color === 0x48D1CC || 
                        color === 0x20B2AA || color === 0x00FFFF) {
                        
                        // Ki·ªÉm tra chi·ªÅu cao (data centers th∆∞·ªùng cao > 8)
                        if (child.geometry.parameters && child.geometry.parameters.height > 8) {
                            child.userData = { type: 'data_center', restored: true };
                            console.log(`‚úÖ Restored data center at: (${pos.x}, ${pos.y}, ${pos.z})`);
                            restoredDataCenters++;
                        }
                    }
                }
            });
            
            console.log(`üìä Found and restored ${restoredDataCenters} original data centers`);
            
            // N·∫øu kh√¥ng t√¨m th·∫•y data center n√†o, t·∫°o m·ªõi
            if (restoredDataCenters === 0) {
                console.log("üèóÔ∏è No original data centers found, creating new ones...");
                
                const dataCenterPositions = [
                    { x: -30, z: 15, color: 0x00CED1 },
                    { x: 35, z: 20, color: 0x40E0D0 },
                    { x: -25, z: -30, color: 0x48D1CC },
                    { x: -80, z: -80, color: 0x20B2AA },
                    { x: 80, z: 80, color: 0x00FFFF }
                ];
                
                dataCenterPositions.forEach((dc, index) => {
                    const geometry = new THREE.BoxGeometry(8, 20, 8);
                    const material = new THREE.MeshLambertMaterial({ color: dc.color });
                    const building = new THREE.Mesh(geometry, material);
                    building.position.set(dc.x, 10, dc.z);
                    building.userData = { type: 'data_center', originalId: index };
                    scene.add(building);
                    console.log(`‚úÖ Created new data center ${index} at (${dc.x}, ${dc.z}) - Color: #${dc.color.toString(16)}`);
                });
                
                restoredDataCenters = dataCenterPositions.length;
            }
            
            console.log(`‚úÖ Data centers restoration complete - Total: ${restoredDataCenters}`);
            
            // üö® EMERGENCY TIMEOUT - Added BEFORE potential syntax errors
            setTimeout(function() {
                console.log("üö® Emergency timeout executing at line 3663...");
                const loadingEl = document.querySelector('[id*="loading"], [class*="loading"]');
                if (loadingEl) {
                    loadingEl.style.display = 'none';
                    console.log("‚úÖ Loading hidden by emergency timeout");
                }
            }, 2000);
        } */

        // üö® EMERGENCY TIMEOUT - Placed in ACTIVE code before line 3674
        setTimeout(function() {
            console.log("üö® Emergency timeout executing (placed before syntax errors)...");
            const loadingEls = document.querySelectorAll('[id*="loading"], [class*="loading"]');
            loadingEls.forEach(function(el) {
                el.style.display = 'none';
                el.style.visibility = 'hidden';
                el.style.opacity = '0';
            });
            console.log("‚úÖ Loading hidden by emergency timeout - " + loadingEls.length + " elements hidden");
        }, 2000);

        // CLEAN UP INCORRECTLY POSITIONED DATA CENTERS
        function cleanupIncorrectDataCenters() {
            console.log("üßπ Removing incorrectly positioned data centers...");
            
            // Remove incorrectly positioned data centers
            const objectsToRemove = [];
            scene.children.forEach(child => {
                if (child.userData && child.userData.type === 'data_center') {
                    objectsToRemove.push(child);
                }
                // Also remove associated infrastructure in wrong location (old position)
                if (child.position.x > 25 && child.position.x < 55 && 
                    child.position.z > -20 && child.position.z < 20) {
                    if (child.material && (child.material.color.getHex() === 0x00CED1 || 
                        child.material.color.getHex() === 0x40E0D0 || 
                        child.material.color.getHex() === 0x48D1CC)) {
                        objectsToRemove.push(child);
                    }
                }
            });
            
            objectsToRemove.forEach(obj => scene.remove(obj));
            console.log(`‚úÖ Removed ${objectsToRemove.length} incorrectly positioned objects`);
        }

        // CREATE DATA CENTER COMPLEX ON FAR RIGHT EDGE
        function createDataCenterComplex() {
            console.log("üèóÔ∏è Creating Data Center Complex on FAR RIGHT EDGE...");
            console.log("üéØ EXPECTED POSITIONS: DC-01(150,0), DC-02(170,15), DC-03(160,-20)");
            
            // First clean up any incorrectly positioned data centers
            cleanupIncorrectDataCenters();
            
            // Position for tech park (FAR RIGHT EDGE of city)
            const TECH_PARK = {
                centerX: 160,
                centerZ: 0,
                width: 40,
                depth: 60
            };
            
            // STEP 1: Create base platform for tech park
            const baseGeometry = new THREE.PlaneGeometry(TECH_PARK.width, TECH_PARK.depth);
            const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
            const basePlatform = new THREE.Mesh(baseGeometry, baseMaterial);
            basePlatform.rotation.x = -Math.PI / 2;
            basePlatform.position.set(TECH_PARK.centerX, 0.1, TECH_PARK.centerZ);
            basePlatform.userData = { type: 'tech_park_base' };
            scene.add(basePlatform);
            console.log("‚úÖ Tech park base platform created");
            
            // STEP 2: Create 3 main data centers (FAR RIGHT EDGE)
            const dataCenters = [
                { x: 150, z: 0, width: 12, height: 22, depth: 10, color: 0x00CED1, name: "DC-01" },
                { x: 170, z: 15, width: 14, height: 28, depth: 12, color: 0x40E0D0, name: "DC-02" },
                { x: 160, z: -20, width: 13, height: 25, depth: 11, color: 0x48D1CC, name: "DC-03" }
            ];
            
            dataCenters.forEach((dc, index) => {
                // Main building
                const dcGeometry = new THREE.BoxGeometry(dc.width, dc.height, dc.depth);
                const dcMaterial = new THREE.MeshLambertMaterial({ color: dc.color });
                const dcBuilding = new THREE.Mesh(dcGeometry, dcMaterial);
                dcBuilding.position.set(dc.x, dc.height/2, dc.z);
                dcBuilding.userData = { type: 'data_center_complex', id: index, name: dc.name };
                scene.add(dcBuilding);
                console.log(`‚úÖ CREATED DATA CENTER: ${dc.name} at position (${dc.x}, ${dc.height/2}, ${dc.z})`);
                console.log(`   Material color: ${dc.color.toString(16)}, Scene children: ${scene.children.length}`);
                
                // Roof equipment
                const roofEquipment = new THREE.Mesh(
                    new THREE.BoxGeometry(dc.width * 0.8, 2, dc.depth * 0.8),
                    new THREE.MeshLambertMaterial({ color: 0x666666 })
                );
                roofEquipment.position.set(dc.x, dc.height + 1, dc.z);
                roofEquipment.userData = { type: 'data_center_equipment' };
                scene.add(roofEquipment);
                
                // Cooling units
                for (let i = 0; i < 4; i++) {
                    const cooler = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.8, 0.8, 3),
                        new THREE.MeshLambertMaterial({ color: 0x888888 })
                    );
                    cooler.position.set(
                        dc.x + (i % 2 === 0 ? -2 : 2),
                        dc.height + 2.5,
                        dc.z + (i < 2 ? -1 : 1)
                    );
                    cooler.userData = { type: 'cooling_unit' };
                    scene.add(cooler);
                }
                
                // LED status indicators
                for (let i = 0; i < 6; i++) {
                    const led = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3),
                        new THREE.MeshBasicMaterial({ color: 0x00FF00, emissive: 0x004400 })
                    );
                    led.position.set(
                        dc.x + (Math.random() - 0.5) * dc.width * 0.8,
                        5 + Math.random() * 8,
                        dc.z + (Math.random() - 0.5) * dc.depth * 0.8
                    );
                    led.userData = { type: 'status_led' };
                    scene.add(led);
                }
                
                console.log(`‚úÖ Data center ${dc.name} created at (${dc.x}, ${dc.z})`);
            });
            
            // STEP 3: Create electrical substation (FAR RIGHT)
            const substationX = 65;
            const substationZ = 10;
            
            // Substation building
            const substationBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(12, 8, 8),
                new THREE.MeshLambertMaterial({ color: 0xFFD700 })
            );
            substationBuilding.position.set(substationX, 4, substationZ);
            substationBuilding.userData = { type: 'substation' };
            scene.add(substationBuilding);
            
            // Electrical transformers
            for (let i = 0; i < 3; i++) {
                const transformer = new THREE.Mesh(
                    new THREE.CylinderGeometry(1.5, 1.5, 4),
                    new THREE.MeshLambertMaterial({ color: 0x4169E1 })
                );
                transformer.position.set(substationX + (i - 1) * 4, 2, substationZ + 6);
                transformer.userData = { type: 'transformer' };
                scene.add(transformer);
            }
            
            // Power lines (simplified) - FAR RIGHT
            for (let i = 0; i < 5; i++) {
                const powerLine = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.2, 15),
                    new THREE.MeshLambertMaterial({ color: 0x000000 })
                );
                powerLine.position.set(65 + i * 5, 8, substationZ);
                powerLine.userData = { type: 'power_line' };
                scene.add(powerLine);
            }
            
            console.log("‚úÖ Electrical substation created");
            
            // STEP 4: Create access roads (FAR RIGHT)
            const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
            
            // Main access road (horizontal connection)
            const mainRoad = new THREE.Mesh(
                new THREE.PlaneGeometry(50, 4),
                roadMaterial
            );
            mainRoad.rotation.x = -Math.PI / 2;
            mainRoad.position.set(TECH_PARK.centerX, 0.05, -25);
            mainRoad.userData = { type: 'access_road' };
            scene.add(mainRoad);
            
            // Internal roads (vertical within complex)
            const internalRoad1 = new THREE.Mesh(
                new THREE.PlaneGeometry(4, 40),
                roadMaterial
            );
            internalRoad1.rotation.x = -Math.PI / 2;
            internalRoad1.position.set(75, 0.05, 0);
            internalRoad1.userData = { type: 'internal_road' };
            scene.add(internalRoad1);
            
            console.log("‚úÖ Access roads created");
            
            // STEP 5: Create security and support buildings (FAR RIGHT)
            const securityBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(6, 4, 4),
                new THREE.MeshLambertMaterial({ color: 0x8B4513 })
            );
            securityBuilding.position.set(60, 2, -20);
            securityBuilding.userData = { type: 'security_building' };
            scene.add(securityBuilding);
            
            const maintenanceBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(8, 5, 6),
                new THREE.MeshLambertMaterial({ color: 0x696969 })
            );
            maintenanceBuilding.position.set(95, 2.5, 15);
            maintenanceBuilding.userData = { type: 'maintenance_building' };
            scene.add(maintenanceBuilding);
            
            console.log("‚úÖ Support buildings created");
            
            // STEP 6: Add perimeter fence
            const fenceHeight = 3;
            const fenceMaterial = new THREE.MeshLambertMaterial({ color: 0x708090 });
            
            // Perimeter fence segments (FAR RIGHT EDGE)
            const fenceSegments = [
                { x: 60, z: 0, width: 0.2, height: fenceHeight, depth: 60, rotation: 0 }, // Left side
                { x: 100, z: 0, width: 0.2, height: fenceHeight, depth: 60, rotation: 0 }, // Right side
                { x: 80, z: -30, width: 40, height: fenceHeight, depth: 0.2, rotation: 0 }, // Bottom
                { x: 80, z: 30, width: 40, height: fenceHeight, depth: 0.2, rotation: 0 } // Top
            ];
            
            fenceSegments.forEach((fence, index) => {
                const fenceGeometry = new THREE.BoxGeometry(fence.width, fence.height, fence.depth);
                const fenceMesh = new THREE.Mesh(fenceGeometry, fenceMaterial);
                fenceMesh.position.set(fence.x, fence.height/2, fence.z);
                fenceMesh.userData = { type: 'perimeter_fence' };
                scene.add(fenceMesh);
            });
            
            console.log("‚úÖ Perimeter fence created");
            console.log("üè≠ Data Center Complex completed successfully!");
        }

        // CREATE DETAILED DATA CENTER COMPLEX AT EAST POSITION - SAFE VERSION
        function createEastDataCenter() {
            console.log("üèóÔ∏è Creating DETAILED Data Center Complex at EXTREME RIGHT EDGE...");
            console.log("üéØ Target: Comprehensive data center with cooling, power, utilities");
            
            try {
                // SAFE CLEANUP - Remove existing data centers with strict limits
                console.log("üßπ Safely removing existing data centers...");
                const allTypesToRemove = [
                    'data_center_complex', 'data_center', 'tech_park_base', 
                    'connecting_road', 'direction_marker', 'cooling_tower', 
                    'substation', 'utility_building', 'data_center_led',
                    'data_center_equipment', 'data_center_antenna', 'data_center_sign'
                ];
                
                const allObjectsToRemove = [];
                const sceneChildren = scene.children.slice(); // Create a copy safely
                
                // SAFE iteration with multiple limits
                for (let i = 0; i < Math.min(sceneChildren.length, 500); i++) {
                    const child = sceneChildren[i];
                    if (!child) continue; // Safety check
                    
                    try {
                        if (child.userData && allTypesToRemove.includes(child.userData.type)) {
                            allObjectsToRemove.push(child);
                        }
                        // Safe color check
                        if (child.material && child.material.color && typeof child.material.color.getHex === 'function') {
                            const color = child.material.color.getHex();
                            if (color === 0x00CED1 || color === 0x40E0D0 || color === 0x48D1CC || 
                                color === 0x20B2AA || color === 0x00FFFF) {
                                allObjectsToRemove.push(child);
                            }
                        }
                    } catch (childError) {
                        console.warn('‚ö†Ô∏è Error processing child object:', childError);
                        continue;
                    }
                }
                
                // Safe removal
                let removedCount = 0;
                allObjectsToRemove.forEach(obj => {
                    try {
                        scene.remove(obj);
                        removedCount++;
                    } catch (removeError) {
                        console.warn('‚ö†Ô∏è Error removing object:', removeError);
                    }
                });
                
                console.log(`üóëÔ∏è Safely removed ${removedCount} data center objects`);
            
            // Base platform for entire complex
            const baseGeometry = new THREE.PlaneGeometry(120, 160);
            const baseMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x90EE90,
                transparent: true,
                opacity: 0.2
            });
            const basePlatform = new THREE.Mesh(baseGeometry, baseMaterial);
            basePlatform.rotation.x = -Math.PI / 2;
            basePlatform.position.set(410, 0.05, 0);
            basePlatform.userData = { type: 'tech_park_base' };
            scene.add(basePlatform);
            
            // Main Data Center Buildings
            const dataCenters = [
                { 
                    x: 390, z: -30, 
                    width: 25, height: 18, depth: 15, 
                    color: 0xe8e8e8, 
                    name: "DATA-CENTER-01",
                    power: "100MW"
                },
                { 
                    x: 420, z: 10, 
                    width: 30, height: 22, depth: 18, 
                    color: 0xf0f0f0, 
                    name: "DATA-CENTER-02",
                    power: "150MW"
                },
                { 
                    x: 440, z: -20, 
                    width: 28, height: 20, depth: 16, 
                    color: 0xe0e0e0, 
                    name: "DATA-CENTER-03",
                    power: "120MW"
                }
            ];
            
            dataCenters.forEach((dc, index) => {
                // Main building
                const dcGeometry = new THREE.BoxGeometry(dc.width, dc.height, dc.depth);
                const dcMaterial = new THREE.MeshLambertMaterial({ color: dc.color });
                const dcBuilding = new THREE.Mesh(dcGeometry, dcMaterial);
                
                dcBuilding.position.set(dc.x, dc.height/2, dc.z);
                dcBuilding.castShadow = true;
                dcBuilding.receiveShadow = true;
                dcBuilding.userData = { 
                    type: 'data_center_complex', 
                    name: dc.name,
                    power: dc.power
                };
                scene.add(dcBuilding);
                
                // Roof equipment
                const roofEquipment = new THREE.Mesh(
                    new THREE.BoxGeometry(dc.width * 0.8, 3, dc.depth * 0.8),
                    new THREE.MeshLambertMaterial({ color: 0x666666 })
                );
                roofEquipment.position.set(dc.x, dc.height + 1.5, dc.z);
                roofEquipment.userData = { type: 'roof_equipment' };
                scene.add(roofEquipment);
                
                // HVAC units on roof
                for (let i = 0; i < 4; i++) {
                    const hvac = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 2, 2),
                        new THREE.MeshLambertMaterial({ color: 0x888888 })
                    );
                    hvac.position.set(
                        dc.x + (i-1.5) * 5,
                        dc.height + 3,
                        dc.z
                    );
                    hvac.userData = { type: 'hvac_unit' };
                    scene.add(hvac);
                }
                
                console.log(`‚úÖ CREATED: ${dc.name} (${dc.power}) at (${dc.x}, ${dc.height/2}, ${dc.z})`);
            });
            
            // Cooling Towers (nh∆∞ trong h√¨nh)
            const coolingTowers = [
                { x: 380, z: 20, name: "COOLING-TOWER-01" },
                { x: 395, z: 25, name: "COOLING-TOWER-02" },
                { x: 450, z: 15, name: "COOLING-TOWER-03" },
                { x: 465, z: 20, name: "COOLING-TOWER-04" }
            ];
            
            coolingTowers.forEach((tower, index) => {
                // Main tower structure
                const towerGeometry = new THREE.CylinderGeometry(5, 7, 25, 8);
                const towerMaterial = new THREE.MeshLambertMaterial({ color: 0x00CED1 });
                const towerMesh = new THREE.Mesh(towerGeometry, towerMaterial);
                towerMesh.position.set(tower.x, 12.5, tower.z);
                towerMesh.userData = { type: 'cooling_tower', name: tower.name };
                scene.add(towerMesh);
                
                // Steam effect (white cylinders)
                const steam = new THREE.Mesh(
                    new THREE.CylinderGeometry(3, 1, 8, 6),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                steam.position.set(tower.x, 29, tower.z);
                steam.userData = { type: 'steam_effect' };
                scene.add(steam);
                
                console.log(`‚úÖ CREATED: ${tower.name} at (${tower.x}, ${tower.z})`);
            });
            
            // 500KV Substation (nh∆∞ trong h√¨nh)
            const substationX = 410;
            const substationZ = 40;
            
            // Substation platform
            const substationPlatform = new THREE.Mesh(
                new THREE.PlaneGeometry(30, 20),
                new THREE.MeshLambertMaterial({ color: 0xcccccc })
            );
            substationPlatform.rotation.x = -Math.PI / 2;
            substationPlatform.position.set(substationX, 0.1, substationZ);
            substationPlatform.userData = { type: 'substation_platform' };
            scene.add(substationPlatform);
            
            // Transformers
            for (let i = 0; i < 3; i++) {
                const transformer = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 8, 4),
                    new THREE.MeshLambertMaterial({ color: 0x555555 })
                );
                transformer.position.set(substationX + (i-1) * 10, 4, substationZ);
                transformer.userData = { type: 'transformer' };
                scene.add(transformer);
            }
            
            // Power transmission towers
            const powerTowers = [
                { x: 430, z: 50 },
                { x: 450, z: 60 },
                { x: 470, z: 70 }
            ];
            
            powerTowers.forEach(tower => {
                // Tower structure
                const towerGeometry = new THREE.BoxGeometry(2, 35, 2);
                const towerMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const towerMesh = new THREE.Mesh(towerGeometry, towerMaterial);
                towerMesh.position.set(tower.x, 17.5, tower.z);
                towerMesh.userData = { type: 'power_tower' };
                scene.add(towerMesh);
                
                // Cross arms
                const crossArm = new THREE.Mesh(
                    new THREE.BoxGeometry(12, 1, 1),
                    new THREE.MeshLambertMaterial({ color: 0x444444 })
                );
                crossArm.position.set(tower.x, 30, tower.z);
                crossArm.userData = { type: 'power_cross_arm' };
                scene.add(crossArm);
            });
            
            // Utility Buildings
            const utilityBuildings = [
                { x: 360, z: 0, width: 12, height: 8, name: "ADMIN-BUILDING" },
                { x: 470, z: -10, width: 10, height: 6, name: "SECURITY-OFFICE" },
                { x: 385, z: -50, width: 15, height: 5, name: "MAINTENANCE-SHOP" },
                { x: 445, z: 35, width: 8, height: 7, name: "CONTROL-ROOM" }
            ];
            
            utilityBuildings.forEach(building => {
                const buildingMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(building.width, building.height, building.width * 0.8),
                    new THREE.MeshLambertMaterial({ color: 0xd4d4d4 })
                );
                buildingMesh.position.set(building.x, building.height/2, building.z);
                buildingMesh.userData = { type: 'utility_building', name: building.name };
                scene.add(buildingMesh);
                
                console.log(`‚úÖ CREATED: ${building.name} at (${building.x}, ${building.z})`);
            });
            
            // Perimeter Security Fence
            const fenceHeight = 4;
            const fenceMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
            
            const fenceSegments = [
                // Outer perimeter
                { x: 340, z: 0, width: 0.2, height: fenceHeight, depth: 160 },
                { x: 480, z: 0, width: 0.2, height: fenceHeight, depth: 160 },
                { x: 410, z: -80, width: 140, height: fenceHeight, depth: 0.2 },
                { x: 410, z: 80, width: 140, height: fenceHeight, depth: 0.2 }
            ];
            
            fenceSegments.forEach(fence => {
                const fenceMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(fence.width, fence.height, fence.depth),
                    fenceMaterial
                );
                fenceMesh.position.set(fence.x, fence.height/2, fence.z);
                fenceMesh.userData = { type: 'security_fence' };
                scene.add(fenceMesh);
            });
            
            // Parking Areas
            const parkingAreas = [
                { x: 365, z: -25, width: 20, depth: 15 },
                { x: 455, z: -35, width: 18, depth: 12 }
            ];
            
            parkingAreas.forEach(parking => {
                const parkingLot = new THREE.Mesh(
                    new THREE.PlaneGeometry(parking.width, parking.depth),
                    new THREE.MeshLambertMaterial({ color: 0x333333 })
                );
                parkingLot.rotation.x = -Math.PI / 2;
                parkingLot.position.set(parking.x, 0.02, parking.z);
                parkingLot.userData = { type: 'parking_area' };
                scene.add(parkingLot);
                
                // Parking lines
                for (let i = 0; i < 8; i++) {
                    const line = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.2, 2),
                        new THREE.MeshBasicMaterial({ color: 0xffffff })
                    );
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(
                        parking.x + (i-3.5) * 2.5,
                        0.03,
                        parking.z
                    );
                    line.userData = { type: 'parking_line' };
                    scene.add(line);
                }
            });
            
            // Landscaping - Trees and Green Areas
            const treePositions = [
                { x: 375, z: 10 }, { x: 380, z: 15 }, { x: 385, z: 8 },
                { x: 430, z: -5 }, { x: 435, z: -8 }, { x: 440, z: -2 },
                { x: 460, z: 25 }, { x: 465, z: 30 }, { x: 470, z: 22 },
                { x: 350, z: -15 }, { x: 355, z: -20 }, { x: 360, z: -12 }
            ];
            
            treePositions.forEach(pos => {
                // Tree trunk
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.8, 4),
                    new THREE.MeshLambertMaterial({ color: 0x8B4513 })
                );
                trunk.position.set(pos.x, 2, pos.z);
                trunk.userData = { type: 'tree_trunk' };
                scene.add(trunk);
                
                // Tree foliage
                const foliage = new THREE.Mesh(
                    new THREE.SphereGeometry(3, 8, 6),
                    new THREE.MeshLambertMaterial({ color: 0x228B22 })
                );
                foliage.position.set(pos.x, 6, pos.z);
                foliage.userData = { type: 'tree_foliage' };
                scene.add(foliage);
            });
            
            console.log("üéØ DETAILED Data Center Complex created at coordinates (x: 340-480)");
            console.log("üè≠ Includes: Data Centers, Cooling Towers, 500KV Substation, Utilities");
            console.log("üåø Features: Security Fence, Parking, Landscaping, Power Infrastructure");
            console.log("üìπ Pan camera to EXTREME RIGHT to see the complete complex");
            console.log("‚ö†Ô∏è  Data centers are ONLY at EAST position - NOT in city center!");
            
            } catch (error) {
                console.error("‚ùå Error creating data center complex:", error);
                console.log("‚ö†Ô∏è Data center creation failed, but continuing with loading...");
            }
        }

        // Remove data center complex
        function removeDataCenterComplex() {
            console.log("üóëÔ∏è Removing Data Center Complex...");
            
            const typesToRemove = [
                'tech_park_base',
                'data_center_complex', 
                'data_center_equipment',
                'cooling_unit',
                'status_led',
                'substation',
                'transformer',
                'power_line',
                'access_road',
                'internal_road',
                'security_building',
                'maintenance_building',
                'perimeter_fence'
            ];
            
            const elementsToRemove = [];
            
            const children = [...scene.children]; // Create a copy to avoid modification during iteration
            for (let i = 0; i < children.length && i < 1000; i++) {
                const child = children[i];
                if (child.userData && typesToRemove.includes(child.userData.type)) {
                    elementsToRemove.push(child);
                }
            }
            
            elementsToRemove.forEach(element => {
                scene.remove(element);
            });
            
            console.log(`‚úÖ Removed ${elementsToRemove.length} data center complex elements`);
            return elementsToRemove.length;
        }

        // DELETE ALL RECENTLY CREATED DATA CENTERS
        function deleteRecentlyCreatedDataCenters() {
            console.log("üóëÔ∏è Deleting all recently created data centers...");
            
            // STEP 1: Remove all data center buildings
            const datacentersToRemove = [];
            const children1 = [...scene.children];
            for (let i = 0; i < children1.length && i < 1000; i++) {
                const child = children1[i];
                if (child.userData && child.userData.type === 'data_center') {
                    datacentersToRemove.push(child);
                }
            }
            
            datacentersToRemove.forEach(dc => {
                scene.remove(dc);
                console.log(`Removed data center: ${dc.userData.name || 'unnamed'}`);
            });
            
            console.log(`‚úÖ Total data centers removed: ${datacentersToRemove.length}`);
            
            // STEP 2: Remove all data center complex infrastructure
            const complexElementsToRemove = [];
            const children2 = [...scene.children];
            for (let i = 0; i < children2.length && i < 1000; i++) {
                const child = children2[i];
                if (child.userData && (
                    child.userData.type === 'data_center_complex' ||
                    child.userData.type === 'data_center_equipment' ||
                    child.userData.type === 'cooling_unit' ||
                    child.userData.type === 'status_led'
                )) {
                    complexElementsToRemove.push(child);
                }
            }
            
            complexElementsToRemove.forEach(element => {
                scene.remove(element);
                console.log(`Removed complex element: ${element.userData.type}`);
            });
            
            console.log(`‚úÖ Complex infrastructure removed: ${complexElementsToRemove.length}`);
            
            // STEP 3: Remove electrical infrastructure
            const electricalToRemove = [];
            const children3 = [...scene.children];
            for (let i = 0; i < children3.length && i < 1000; i++) {
                const child = children3[i];
                if (child.userData && (
                    child.userData.type === 'substation' ||
                    child.userData.type === 'transformer' ||
                    child.userData.type === 'power_line'
                )) {
                    electricalToRemove.push(child);
                }
            }
            
            electricalToRemove.forEach(element => {
                scene.remove(element);
                console.log(`Removed electrical: ${element.userData.type}`);
            });
            
            console.log(`‚úÖ Electrical infrastructure removed: ${electricalToRemove.length}`);
            
            // STEP 4: Remove roads and access infrastructure
            const roadToRemove = [];
            const children4 = [...scene.children];
            for (let i = 0; i < children4.length && i < 1000; i++) {
                const child = children4[i];
                if (child.userData && (
                    child.userData.type === 'access_road' ||
                    child.userData.type === 'internal_road'
                )) {
                    roadToRemove.push(child);
                }
            }
            
            roadToRemove.forEach(element => {
                scene.remove(element);
                console.log(`Removed road: ${element.userData.type}`);
            });
            
            console.log(`‚úÖ Roads removed: ${roadToRemove.length}`);
            
            // STEP 5: Remove support buildings
            const buildingsToRemove = [];
            const children5 = [...scene.children];
            for (let i = 0; i < children5.length && i < 1000; i++) {
                const child = children5[i];
                if (child.userData && (
                    child.userData.type === 'security_building' ||
                    child.userData.type === 'maintenance_building'
                )) {
                    buildingsToRemove.push(child);
                }
            }
            
            buildingsToRemove.forEach(element => {
                scene.remove(element);
                console.log(`Removed building: ${element.userData.type}`);
            });
            
            console.log(`‚úÖ Support buildings removed: ${buildingsToRemove.length}`);
            
            // STEP 6: Remove perimeter fence and base platform
            const infrastructureToRemove = [];
            const children6 = [...scene.children];
            for (let i = 0; i < children6.length && i < 1000; i++) {
                const child = children6[i];
                if (child.userData && (
                    child.userData.type === 'perimeter_fence' ||
                    child.userData.type === 'tech_park_base'
                )) {
                    infrastructureToRemove.push(child);
                }
            }
            
            infrastructureToRemove.forEach(element => {
                scene.remove(element);
                console.log(`Removed infrastructure: ${element.userData.type}`);
            });
            
            console.log(`‚úÖ Infrastructure removed: ${infrastructureToRemove.length}`);
            
            // STEP 7: Remove any objects with turquoise/teal colors in the far right area
            const coloredObjectsToRemove = [];
            scene.children.forEach(child => {
                if (child.material && child.material.color && 
                    child.position.x > 60 && child.position.x < 100) {
                    const color = child.material.color.getHex();
                    if (color === 0x00CED1 || color === 0x40E0D0 || color === 0x48D1CC || 
                        color === 0x20B2AA || color === 0x00FFFF) {
                        coloredObjectsToRemove.push(child);
                    }
                }
            });
            
            coloredObjectsToRemove.forEach(element => {
                scene.remove(element);
                console.log(`Removed colored object at (${element.position.x}, ${element.position.z})`);
            });
            
            console.log(`‚úÖ Colored objects removed: ${coloredObjectsToRemove.length}`);
            
            const totalRemoved = datacentersToRemove.length + complexElementsToRemove.length + 
                               electricalToRemove.length + roadToRemove.length + 
                               buildingsToRemove.length + infrastructureToRemove.length + 
                               coloredObjectsToRemove.length;
            
            console.log(`üéØ DELETION COMPLETE: Total objects removed: ${totalRemoved}`);
            console.log(`üìä Scene now has ${scene.children.length} objects`);
            
            return totalRemoved;
        }

        // DEBUG: Ki·ªÉm tra objects trong scene
        function debugLoadingStatus() {
            console.log('=== LOADING DEBUG STATUS ===');
            console.log('Current State:', currentLoadingState);
            console.log('Loading Time:', Date.now() - loadingStartTime, 'ms');
            console.log('Is Loading:', isLoading);
            console.log('Scene initialized:', !!scene);
            console.log('Camera initialized:', !!camera);  
            console.log('Renderer initialized:', !!renderer);
            console.log('Controls initialized:', !!controls);
            console.log('Scene children count:', scene ? scene.children.length : 'N/A');
            console.log('WebGL supported:', !!window.WebGLRenderingContext);
            console.log('THREE.js loaded:', typeof THREE !== 'undefined');
            console.log('Canvas container exists:', !!document.getElementById('canvas-container'));
            
            const loadingScreen = document.getElementById('loading-screen');
            console.log('Loading screen exists:', !!loadingScreen);
            if (loadingScreen) {
                console.log('Loading screen visible:', loadingScreen.offsetParent !== null);
                console.log('Loading screen opacity:', loadingScreen.style.opacity || 'default');
                console.log('Loading screen display:', loadingScreen.style.display || 'default');
            }
            
            console.log('Active timeouts:', Object.keys(loadingPhaseTimeouts).length);
            console.log('==============================');
        }

        function debugSceneObjects() {
            console.log("=== DEBUGGING RESTORATION ===");
            
            // Ki·ªÉm tra objects ƒë√£ ƒë∆∞·ª£c t·∫°o ch∆∞a
            let riverCount = 0;
            let dataCenterCount = 0;
            let greenAreaCount = 0;
            
            scene.children.forEach(child => {
                if (child.userData && child.userData.type === 'river') {
                    riverCount++;
                    console.log("‚úÖ River found at:", child.position);
                }
                if (child.userData && child.userData.type === 'data_center') {
                    dataCenterCount++;
                    console.log("‚úÖ Data center found at:", child.position);
                }
                if (child.userData && child.userData.type === 'green_area') {
                    greenAreaCount++;
                    console.log("‚úÖ Green area found at:", child.position);
                }
            });
            
            console.log(`üèä Rivers in scene: ${riverCount}`);
            console.log(`üè¢ Data centers in scene: ${dataCenterCount}`);
            console.log(`üå≥ Green areas in scene: ${greenAreaCount}`);
            console.log(`üìä Total scene children: ${scene.children.length}`);
            
            if (riverCount === 0) {
                console.log("‚ùå NO RIVERS FOUND - Calling restoreOriginalRiver()");
                restoreOriginalRiver();
            }
            
            if (dataCenterCount === 0) {
                console.log("‚ùå NO DATA CENTERS FOUND - Calling restoreOriginalDataCenters()");
                restoreOriginalDataCenters();
            }
            
            if (greenAreaCount === 0) {
                console.log("‚ùå NO GREEN AREAS FOUND - Calling restoreGreenAreas()");
                restoreGreenAreas();
            }
        }

        // Kh√¥i ph·ª•c c√°c khu v·ª±c xanh tr√≤n (t·ª´ h√¨nh ·∫£nh)
        function restoreGreenAreas() {
            console.log("üå≥ Kh√¥i ph·ª•c c√°c khu v·ª±c xanh tr√≤n...");
            
            const greenAreas = [
                { x: 25, z: -15, radius: 8 },
                { x: -20, z: -20, radius: 6 },
                { x: 30, z: 10, radius: 10 },
                { x: -35, z: 25, radius: 7 },
                { x: 45, z: -25, radius: 5 },
                { x: -15, z: 35, radius: 9 }
            ];
            
            greenAreas.forEach((area, index) => {
                // B√£i c·ªè tr√≤n
                const grassGeometry = new THREE.CircleGeometry(area.radius);
                const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.rotation.x = -Math.PI / 2;
                grass.position.set(area.x, 0.02, area.z);
                grass.userData = { type: 'green_area', id: index };
                scene.add(grass);
                
                // Th√™m c√¢y trong khu v·ª±c xanh
                const numTrees = Math.floor(area.radius / 3) + 2;
                for (let i = 0; i < numTrees; i++) {
                    const angle = (i / numTrees) * Math.PI * 2;
                    const distance = Math.random() * (area.radius * 0.7);
                    const treeX = area.x + Math.cos(angle) * distance;
                    const treeZ = area.z + Math.sin(angle) * distance;
                    
                    // Th√¢n c√¢y
                    const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2.5);
                    const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.set(treeX, 1.25, treeZ);
                    trunk.userData = { type: 'green_area_tree', areaId: index };
                    scene.add(trunk);
                    
                    // T√°n l√°
                    const leavesGeometry = new THREE.SphereGeometry(1.5 + Math.random() * 0.5);
                    const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                    leaves.position.set(treeX, 3, treeZ);
                    leaves.userData = { type: 'green_area_leaves', areaId: index };
                    scene.add(leaves);
                }
                
                // Th√™m b·ª•i c·ªè nh·ªè
                for (let i = 0; i < area.radius; i++) {
                    const bushX = area.x + (Math.random() - 0.5) * area.radius * 1.5;
                    const bushZ = area.z + (Math.random() - 0.5) * area.radius * 1.5;
                    
                    const bushGeometry = new THREE.SphereGeometry(0.6 + Math.random() * 0.4);
                    const bushMaterial = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
                    const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                    bush.position.set(bushX, 0.6, bushZ);
                    bush.userData = { type: 'green_area_bush', areaId: index };
                    scene.add(bush);
                }
                
                // ƒê∆∞·ªùng d·∫´n nh·ªè quanh khu v·ª±c xanh
                const pathGeometry = new THREE.RingGeometry(area.radius + 0.5, area.radius + 1.5);
                const pathMaterial = new THREE.MeshLambertMaterial({ color: 0xD2B48C });
                const path = new THREE.Mesh(pathGeometry, pathMaterial);
                path.rotation.x = -Math.PI / 2;
                path.position.set(area.x, 0.01, area.z);
                path.userData = { type: 'green_area_path', areaId: index };
                scene.add(path);
            });
            
            console.log("‚úÖ C√°c khu v·ª±c xanh tr√≤n ƒë√£ ƒë∆∞·ª£c kh√¥i ph·ª•c!");
        }

        // X√≥a c√°c khu v·ª±c xanh
        function removeGreenAreas() {
            const elementsToRemove = [];
            
            scene.children.forEach(child => {
                if (child.userData && (
                    child.userData.type === 'green_area' ||
                    child.userData.type === 'green_area_tree' ||
                    child.userData.type === 'green_area_leaves' ||
                    child.userData.type === 'green_area_bush' ||
                    child.userData.type === 'green_area_path'
                )) {
                    elementsToRemove.push(child);
                }
            });
            
            elementsToRemove.forEach(element => {
                scene.remove(element);
            });
            
            console.log(`üåø ƒê√£ x√≥a ${elementsToRemove.length} th√†nh ph·∫ßn khu v·ª±c xanh`);
            return elementsToRemove.length;
        }


        // Create VERY VISIBLE EV charging stations
        function createVisibleEVStations() {
            const stations = [
                { x: -80, z: 30 },
                { x: 80, z: -30 },
                { x: 30, z: 80 },
                { x: -30, z: -80 }
            ];
            
            stations.forEach(pos => {
                const station = new THREE.Group();
                
                // LARGE charging post (green and tall)
                const post = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 8, 3),
                    new THREE.MeshLambertMaterial({ color: 0x00ff00 }) // Bright green
                );
                post.position.y = 4;
                station.add(post);
                
                // BRIGHT LED top (cyan blue, very visible)
                const led = new THREE.Mesh(
                    new THREE.SphereGeometry(0.8, 16, 16),
                    new THREE.MeshBasicMaterial({ color: 0x00ffff }) // Bright cyan
                );
                led.position.y = 8.5;
                station.add(led);
                
                // Large base platform (white)
                const base = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 0.5, 8),
                    new THREE.MeshLambertMaterial({ color: 0xffffff }) // White
                );
                base.position.y = 0.25;
                station.add(base);
                
                // Add "EV" text sign
                const sign = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 2, 0.2),
                    new THREE.MeshBasicMaterial({ color: 0x0066ff }) // Blue sign
                );
                sign.position.set(0, 6, 1.5);
                station.add(sign);
                
                station.position.set(pos.x, 0, pos.z);
                scene.add(station);
            });
        }

        function createParkingGarage(x, z) {
            const garage = new THREE.Group();
            
            const width = 50;
            const depth = 40;
            const floorHeight = 4;
            const levels = 3;
            
            // Enhanced Materials
            const concreteMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
            const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0x606060 });
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x707070 });
            const yellowLineMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const whiteMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            // Foundation
            const foundation = new THREE.Mesh(
                new THREE.BoxGeometry(width + 2, 1, depth + 2),
                concreteMaterial
            );
            foundation.position.y = -0.5;
            foundation.receiveShadow = true;
            garage.add(foundation);
            
            // Create each level with enhanced details
            for (let level = 0; level < levels; level++) {
                const y = level * floorHeight;
                
                // Main floor slab
                const floor = new THREE.Mesh(
                    new THREE.BoxGeometry(width, 0.3, depth),
                    concreteMaterial
                );
                floor.position.y = y;
                floor.receiveShadow = true;
                garage.add(floor);
                
                // Support pillars (c·ªôt tr·ª•)
                const pillarPositions = [
                    [-15, 10], [0, 10], [15, 10],
                    [-15, -10], [0, -10], [15, -10]
                ];
                
                pillarPositions.forEach(([px, pz]) => {
                    const pillar = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, floorHeight, 0.8),
                        pillarMaterial
                    );
                    pillar.position.set(px, y + floorHeight/2, pz);
                    pillar.castShadow = true;
                    garage.add(pillar);
                });
                
                // Exterior walls (t∆∞·ªùng ngo√†i)
                if (level > 0) {
                    for (let side = 0; side < 4; side++) {
                        let wallGeometry, wallPosition;
                        
                        switch(side) {
                            case 0: // Front
                                wallGeometry = new THREE.BoxGeometry(width, floorHeight * 0.8, 0.3);
                                wallPosition = [0, y + floorHeight * 0.4, depth/2 + 0.15];
                                break;
                            case 1: // Back
                                wallGeometry = new THREE.BoxGeometry(width, floorHeight * 0.8, 0.3);
                                wallPosition = [0, y + floorHeight * 0.4, -depth/2 - 0.15];
                                break;
                            case 2: // Left
                                wallGeometry = new THREE.BoxGeometry(0.3, floorHeight * 0.8, depth);
                                wallPosition = [-width/2 - 0.15, y + floorHeight * 0.4, 0];
                                break;
                            case 3: // Right
                                wallGeometry = new THREE.BoxGeometry(0.3, floorHeight * 0.8, depth);
                                wallPosition = [width/2 + 0.15, y + floorHeight * 0.4, 0];
                                break;
                        }
                        
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(...wallPosition);
                        wall.castShadow = true;
                        garage.add(wall);
                    }
                }
                
                // Parking spaces with lines and numbers
                const spaceWidth = 2.5;
                const spaceDepth = 5;
                const spacesPerRow = Math.floor((width - 10) / spaceWidth);
                const rows = Math.floor((depth - 10) / spaceDepth);
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < spacesPerRow; col++) {
                        const spaceX = -width/2 + 5 + col * spaceWidth;
                        const spaceZ = -depth/2 + 5 + row * spaceDepth;
                        
                        // Parking space lines (v·∫°ch k·∫ª)
                        const lineGeometry = new THREE.BoxGeometry(spaceWidth, 0.01, 0.1);
                        const frontLine = new THREE.Mesh(lineGeometry, yellowLineMaterial);
                        frontLine.position.set(spaceX, y + 0.001, spaceZ + spaceDepth/2);
                        garage.add(frontLine);
                        
                        // Side lines
                        const sideLineGeometry = new THREE.BoxGeometry(0.1, 0.01, spaceDepth);
                        const leftLine = new THREE.Mesh(sideLineGeometry, yellowLineMaterial);
                        leftLine.position.set(spaceX - spaceWidth/2, y + 0.001, spaceZ);
                        garage.add(leftLine);
                        
                        if (col === spacesPerRow - 1) {
                            const rightLine = new THREE.Mesh(sideLineGeometry, yellowLineMaterial);
                            rightLine.position.set(spaceX + spaceWidth/2, y + 0.001, spaceZ);
                            garage.add(rightLine);
                        }
                        
                        // Space numbers (s·ªë ch·ªó ƒë·ªó)
                        const spaceNumber = level * 100 + row * 10 + col + 1;
                        const numberMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(0.5, 0.01, 0.3),
                            whiteMaterial
                        );
                        numberMesh.position.set(spaceX, y + 0.002, spaceZ);
                        garage.add(numberMesh);
                        
                        // Cars will be added by addCarsToParking() function
                    }
                }
                
                // Lighting fixtures (ƒë√®n chi·∫øu s√°ng)
                const lightPositions = [
                    [-15, 0], [0, 0], [15, 0],
                    [-15, 15], [0, 15], [15, 15],
                    [-15, -15], [0, -15], [15, -15]
                ];
                
                lightPositions.forEach(([lx, lz]) => {
                    const lightFixture = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 0.2, 1),
                        new THREE.MeshBasicMaterial({ color: 0xffffcc })
                    );
                    lightFixture.position.set(lx, y + floorHeight - 0.5, lz);
                    garage.add(lightFixture);
                });
            }
            
            // Entry/Exit ramps (d·ªëc l√™n xu·ªëng)
            const rampWidth = 6;
            const rampLength = 15;
            
            const entranceRamp = new THREE.Mesh(
                new THREE.BoxGeometry(rampWidth, 0.3, rampLength),
                concreteMaterial
            );
            entranceRamp.position.set(-width/2 - rampLength/2, floorHeight/2, 0);
            entranceRamp.rotation.z = Math.atan(floorHeight / rampLength);
            garage.add(entranceRamp);
            
            garage.position.set(x, 0, z);
            return garage;
        }

        function createParkingLot(config) {
            const lot = new THREE.Group();
            
            // Asphalt base
            const asphalt = new THREE.Mesh(
                new THREE.BoxGeometry(config.width, 0.1, config.depth),
                new THREE.MeshLambertMaterial({ color: 0x2c2c2c })
            );
            asphalt.receiveShadow = true;
            lot.add(asphalt);
            
            lot.position.set(config.x, 0, config.z);
            return lot;
        }

        // Enhanced Smart Parking Garage with sensors and AI
        function createSmartParkingGarage(x, z) {
            const garage = new THREE.Group();
            
            const width = 25;  // Gi·∫£m t·ª´ 50 xu·ªëng 25 (1/2)
            const depth = 20;  // Gi·∫£m t·ª´ 40 xu·ªëng 20 (1/2)
            const floorHeight = 4;  // Gi·ªØ nguy√™n
            const levels = 3;  // Gi·ªØ nguy√™n
            
            // Enhanced Materials
            const concreteMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
            const smartSensorMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                transparent: true,
                opacity: 0.8
            });
            const ledMaterial = new THREE.MeshBasicMaterial({ color: 0x3498db });
            
            // Foundation with smart sensors
            const foundation = new THREE.Mesh(
                new THREE.BoxGeometry(width + 2, 1, depth + 2),
                concreteMaterial
            );
            foundation.position.y = 0.5;
            garage.add(foundation);
            
            // Create floors with parking spaces and sensors
            for (let level = 0; level < levels; level++) {
                const y = (level + 1) * floorHeight;
                
                // Floor slab
                const floor = new THREE.Mesh(
                    new THREE.BoxGeometry(width, 0.3, depth),
                    concreteMaterial
                );
                floor.position.y = y;
                garage.add(floor);
                
                // Smart parking sensors (green dots)
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 6; j++) {
                        const sensor = new THREE.Mesh(
                            new THREE.SphereGeometry(0.3, 8, 8),
                            smartSensorMaterial
                        );
                        sensor.position.set(
                            -width/2 + (i + 1) * (width/9),
                            y + 0.5,
                            -depth/2 + (j + 1) * (depth/7)
                        );
                        garage.add(sensor);
                        
                        // Add blinking animation
                        animateSensor(sensor);
                    }
                }
                
                // LED information displays
                const ledDisplay = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 0.5, 0.1),
                    ledMaterial
                );
                ledDisplay.position.set(width/2 - 2, y + 2, 0);
                garage.add(ledDisplay);
            }
            
            // ENHANCED: Add support pillars for each level
            const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0x606060 });
            for (let level = 0; level < levels; level++) {
                const y = (level + 1) * floorHeight;
                
                // Create 6 pillars per level (2x3 grid)
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 3; j++) {
                        const pillar = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.4, floorHeight, 8),
                            pillarMaterial
                        );
                        pillar.position.set(
                            -width/2 + 10 + i * (width - 20),
                            y - floorHeight/2,
                            -depth/2 + 8 + j * (depth - 16)/2
                        );
                        garage.add(pillar);
                    }
                }
            }
            
            // ENHANCED: Add roof covering
            const roofMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x888888,
                side: THREE.DoubleSide 
            });
            const roof = new THREE.Mesh(
                new THREE.PlaneGeometry(width + 4, depth + 4),
                roofMaterial
            );
            roof.rotation.x = -Math.PI / 2;
            roof.position.y = levels * floorHeight + 1;
            garage.add(roof);
            
            // ENHANCED: Add parking space markings
            const markingMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            for (let level = 0; level < levels; level++) {
                const y = (level + 1) * floorHeight + 0.02;
                
                // Parking space lines (6 spaces per row, 8 rows)
                for (let row = 0; row < 8; row++) {
                    for (let space = 0; space < 6; space++) {
                        // Parking space outline
                        const spaceOutline = new THREE.Mesh(
                            new THREE.PlaneGeometry(4, 6),
                            new THREE.MeshBasicMaterial({ 
                                color: 0xffff00,
                                transparent: true,
                                opacity: 0.3,
                                side: THREE.DoubleSide
                            })
                        );
                        spaceOutline.rotation.x = -Math.PI / 2;
                        spaceOutline.position.set(
                            -width/2 + 6 + row * 6,
                            y,
                            -depth/2 + 4 + space * 6
                        );
                        garage.add(spaceOutline);
                        
                        // Parking space number
                        const spaceNumber = new THREE.Mesh(
                            new THREE.PlaneGeometry(1, 1),
                            new THREE.MeshBasicMaterial({ 
                                color: 0xffffff,
                                side: THREE.DoubleSide
                            })
                        );
                        spaceNumber.rotation.x = -Math.PI / 2;
                        spaceNumber.position.set(
                            -width/2 + 6 + row * 6,
                            y + 0.01,
                            -depth/2 + 4 + space * 6
                        );
                        garage.add(spaceNumber);
                    }
                }
                
                // Driving lanes
                for (let lane = 0; lane < 2; lane++) {
                    const drivingLane = new THREE.Mesh(
                        new THREE.PlaneGeometry(width - 4, 3),
                        new THREE.MeshBasicMaterial({ 
                            color: 0x333333,
                            side: THREE.DoubleSide
                        })
                    );
                    drivingLane.rotation.x = -Math.PI / 2;
                    drivingLane.position.set(
                        0,
                        y,
                        -depth/2 + 12 + lane * 16
                    );
                    garage.add(drivingLane);
                }
            }
            
            // ENHANCED: Add LED lighting system
            const lightMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffffcc,
                emissive: 0x444422,
                emissiveIntensity: 0.2
            });
            for (let level = 0; level < levels; level++) {
                const y = (level + 1) * floorHeight - 0.5;
                
                // Ceiling lights (4x3 grid)
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 3; j++) {
                        const light = new THREE.Mesh(
                            new THREE.BoxGeometry(2, 0.2, 1),
                            lightMaterial
                        );
                        light.position.set(
                            -width/2 + 10 + i * 10,
                            y,
                            -depth/2 + 8 + j * 12
                        );
                        garage.add(light);
                    }
                }
            }
            
            // ENHANCED: Add directional signs
            const signMaterial = new THREE.MeshBasicMaterial({ color: 0x1e40af });
            for (let level = 0; level < levels; level++) {
                const y = (level + 1) * floorHeight - 1;
                
                // Entry/Exit signs
                const entrySign = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 1, 0.1),
                    signMaterial
                );
                entrySign.position.set(-width/2 + 5, y, depth/2 - 1);
                garage.add(entrySign);
                
                const exitSign = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 1, 0.1),
                    new THREE.MeshBasicMaterial({ color: 0xdc2626 })
                );
                exitSign.position.set(width/2 - 5, y, depth/2 - 1);
                garage.add(exitSign);
            }
            
            // ENHANCED: Add comprehensive signage system
            
            // Main entrance sign
            const entranceSign = createParkingGateSign('entrance');
            entranceSign.position.set(-width/2 - 8, 0, 0);
            entranceSign.rotation.y = Math.PI / 2;
            garage.add(entranceSign);
            
            // Exit sign
            const exitSign = createParkingGateSign('exit');
            exitSign.position.set(width/2 + 8, 0, 0);
            exitSign.rotation.y = -Math.PI / 2;
            garage.add(exitSign);
            
            // Directional signs at entrance
            const directionSign = createDirectionalParkingSign('up');
            directionSign.position.set(-width/2 - 5, 0, -10);
            garage.add(directionSign);
            
            // Level indicators for each floor
            for (let level = 0; level < levels; level++) {
                const y = (level + 1) * floorHeight;
                
                // Level number signs
                const levelSign = createParkingSign('parking', 2.5, 1.0);
                levelSign.position.set(-width/2 + 2, y - 2, depth/2 - 2);
                garage.add(levelSign);
                
                // EV charging section sign (level 1 only)
                if (level === 0) {
                    const evSign = createParkingSign('ev', 2.5, 1.0);
                    evSign.position.set(-width/2 + 15, y, depth/2 - 2);
                    garage.add(evSign);
                }
                
                // Handicap section sign (level 1 only)
                if (level === 0) {
                    const handicapSign = createParkingSign('handicap', 2.5, 1.0);
                    handicapSign.position.set(-width/2 + 8, y, depth/2 - 2);
                    garage.add(handicapSign);
                }
                
                // Reserved section sign (level 3 only)
                if (level === 2) {
                    const reservedSign = createParkingSign('reserved', 2.5, 1.0);
                    reservedSign.position.set(-width/2 + 10, y, depth/2 - 2);
                    garage.add(reservedSign);
                }
            }
            
            // Corner navigation signs
            const cornerPositions = [
                { x: -width/2 + 5, z: -depth/2 + 5, direction: 'right' },
                { x: width/2 - 5, z: -depth/2 + 5, direction: 'left' },
                { x: width/2 - 5, z: depth/2 - 5, direction: 'left' },
                { x: -width/2 + 5, z: depth/2 - 5, direction: 'right' }
            ];
            
            cornerPositions.forEach(pos => {
                const cornerSign = createDirectionalParkingSign(pos.direction);
                cornerSign.position.set(pos.x, 0, pos.z);
                garage.add(cornerSign);
            });
            
            // Smart entrance with QR scanner
            const entrance = new THREE.Mesh(
                new THREE.BoxGeometry(6, 3, 0.5),
                new THREE.MeshBasicMaterial({ color: 0x1e40af })
            );
            entrance.position.set(-width/2 - 3, 2, 0);
            garage.add(entrance);
            
            // QR Scanner
            const qrScanner = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.5, 0.2),
                new THREE.MeshBasicMaterial({ color: 0xfbbf24 })
            );
            qrScanner.position.set(-width/2 - 2.5, 2, 0.5);
            garage.add(qrScanner);
            
            garage.position.set(x, 0, z);
            return garage;
        }

        // Enhanced Smart Parking Lot with different types
        function createSmartParkingLot(config) {
            const lot = new THREE.Group();
            
            // Asphalt base with smart materials
            const asphalt = new THREE.Mesh(
                new THREE.BoxGeometry(config.width, 0.1, config.depth),
                new THREE.MeshLambertMaterial({ color: 0x2c2c2c })
            );
            asphalt.receiveShadow = true;
            lot.add(asphalt);
            
            // ENHANCED: Add detailed parking spaces with lines
            const spacesPerRow = Math.floor(config.width / 3);
            const rows = Math.floor(config.depth / 6);
            let spaceNumber = 1;
            
            for (let row = 0; row < rows; row++) {
                for (let space = 0; space < spacesPerRow; space++) {
                    const x = -config.width/2 + (space + 0.5) * (config.width / spacesPerRow);
                    const z = -config.depth/2 + (row + 0.5) * (config.depth / rows);
                    
                    let spaceType = 'normal';
                    
                    // Special space types based on lot type and position
                    if (config.type === 'ev_charging' && space < 2) {
                        spaceType = 'ev';
                    } else if (config.type === 'smart' && space === 0 && row === 0) {
                        spaceType = 'handicap'; // First space is handicap
                    }
                    
                    const parkingSpace = createCompleteParkingSpace(x, z, spaceNumber, spaceType);
                    lot.add(parkingSpace);
                    spaceNumber++;
                }
            }
            
            // ENHANCED: Add covered parking area for premium lots
            if (config.width > 35 && config.depth > 35) {
                const coveredArea = createCoveredParkingArea(config.width * 0.8, config.depth * 0.8);
                lot.add(coveredArea);
            }
            
            // ENHANCED: Add professional signage system
            
            // Main lot identification sign
            const mainSign = createParkingSign(config.type === 'ev_charging' ? 'ev' : 'parking', 3, 1.5);
            mainSign.position.set(0, 0, config.depth/2 + 3);
            lot.add(mainSign);
            
            // Entrance/Exit directional signs
            const entranceSign = createDirectionalParkingSign('straight');
            entranceSign.position.set(-config.width/2 + 3, 0, config.depth/2 + 1);
            entranceSign.rotation.y = -Math.PI / 4;
            lot.add(entranceSign);
            
            const exitSign = createDirectionalParkingSign('left');
            exitSign.position.set(config.width/2 - 3, 0, config.depth/2 + 1);
            exitSign.rotation.y = Math.PI / 4;
            lot.add(exitSign);
            
            // Corner navigation signs for larger lots
            if (config.width > 35 && config.depth > 35) {
                const cornerSigns = [
                    { x: -config.width/2 + 2, z: -config.depth/2 + 2, dir: 'right' },
                    { x: config.width/2 - 2, z: -config.depth/2 + 2, dir: 'left' }
                ];
                
                cornerSigns.forEach(corner => {
                    const cornerSign = createDirectionalParkingSign(corner.dir);
                    cornerSign.position.set(corner.x, 0, corner.z);
                    lot.add(cornerSign);
                });
            }
            
            // Add specific features based on type
            if (config.type === 'ev_charging') {
                // EV Charging stations
                addEVChargingStations(lot, config);
                
                // Additional EV information signs
                const evInfoSign = createParkingSign('ev', 2.5, 1.0);
                evInfoSign.position.set(-config.width/2 + 5, 0, -config.depth/2 + 5);
                lot.add(evInfoSign);
                
            } else if (config.type === 'bike_parking') {
                // Bike parking racks
                addBikeParkingRacks(lot, config);
                
                // Bike parking information sign
                const bikeInfoSign = createParkingSign('parking', 2.5, 1.0);
                bikeInfoSign.position.set(0, 0, -config.depth/2 + 3);
                lot.add(bikeInfoSign);
                
            } else if (config.type === 'smart') {
                // Smart sensors for regular parking (already added in parking spaces)
                
                // Handicap section sign
                const handicapSign = createParkingSign('handicap', 2.5, 1.0);
                handicapSign.position.set(-config.width/2 + 3, 0, -config.depth/2 + 3);
                lot.add(handicapSign);
                
                // No parking zones
                const noParkingSign = createParkingSign('no_parking', 2.5, 1.0);
                noParkingSign.position.set(config.width/2 - 3, 0, -config.depth/2 + 3);
                lot.add(noParkingSign);
            }
            
            lot.position.set(config.x, 0, config.z);
            return lot;
        }

        // Add EV charging stations to parking lot
        function addEVChargingStations(lot, config) {
            const chargingStations = 6;
            for (let i = 0; i < chargingStations; i++) {
                const station = new THREE.Group();
                
                // Charging post
                const post = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 2, 0.4),
                    new THREE.MeshLambertMaterial({ color: 0x10b981 })
                );
                post.position.y = 1;
                station.add(post);
                
                // Charging cable
                const cable = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 1, 8),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                cable.position.set(0.3, 0.5, 0);
                station.add(cable);
                
                // LED indicator
                const led = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0x00ff00 })
                );
                led.position.set(0, 1.8, 0.2);
                station.add(led);
                
                // Position stations
                station.position.set(
                    -config.width/2 + (i + 1) * (config.width/(chargingStations + 1)),
                    0.1,
                    0
                );
                lot.add(station);
            }
        }

        // Add bike parking racks
        function addBikeParkingRacks(lot, config) {
            const rackCount = 10;
            for (let i = 0; i < rackCount; i++) {
                const rack = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 1, 2),
                    new THREE.MeshLambertMaterial({ color: 0x606060 })
                );
                rack.position.set(
                    -config.width/2 + (i + 1) * (config.width/(rackCount + 1)),
                    0.6,
                    0
                );
                lot.add(rack);
            }
        }

        // Add smart sensors to parking lot
        function addSmartSensors(lot, config) {
            const sensorCount = 12;
            for (let i = 0; i < sensorCount; i++) {
                const sensor = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 8, 8),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x3498db,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                sensor.position.set(
                    -config.width/2 + (i + 1) * (config.width/(sensorCount + 1)),
                    0.3,
                    config.depth/4
                );
                lot.add(sensor);
                
                // Add pulsing animation
                animateSensor(sensor);
            }
        }

        // Create EV charging stations around the city
        function createEVChargingStations() {
            const chargingLocations = [
                { x: -80, z: 30 },
                { x: 80, z: -30 },
                { x: 30, z: 80 },
                { x: -30, z: -80 },
                { x: 0, z: 100 }
            ];
            
            chargingLocations.forEach(location => {
                const chargingStation = createChargingStation();
                chargingStation.position.set(location.x, 0, location.z);
                scene.add(chargingStation);
            });
        }

        // Create individual charging station
        function createChargingStation() {
            const station = new THREE.Group();
            
            // Base platform
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.2, 6),
                new THREE.MeshLambertMaterial({ color: 0xcccccc })
            );
            base.position.y = 0.1;
            station.add(base);
            
            // Charging posts
            for (let i = 0; i < 2; i++) {
                const post = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 2.5, 0.5),
                    new THREE.MeshLambertMaterial({ color: 0x10b981 })
                );
                post.position.set(i * 2 - 0.5, 1.35, 0);
                station.add(post);
                
                // Display screen
                const screen = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 0.4, 0.05),
                    new THREE.MeshBasicMaterial({ color: 0x1e40af })
                );
                screen.position.set(i * 2 - 0.5, 2, 0.25);
                station.add(screen);
            }
            
            // Solar panel canopy
            const canopy = new THREE.Mesh(
                new THREE.BoxGeometry(5, 0.1, 7),
                new THREE.MeshLambertMaterial({ color: 0x1e3a8a })
            );
            canopy.position.y = 3.5;
            station.add(canopy);
            
            // Support pillars
            for (let i = 0; i < 4; i++) {
                const pillar = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 3, 8),
                    new THREE.MeshLambertMaterial({ color: 0x606060 })
                );
                const x = (i % 2) * 4 - 2;
                const z = Math.floor(i / 2) * 6 - 3;
                pillar.position.set(x, 1.5, z);
                station.add(pillar);
            }
            
            return station;
        }

        // Create parking management system (central hub)
        function createParkingManagementSystem() {
            const managementHub = new THREE.Group();
            
            // Main control tower
            const tower = new THREE.Mesh(
                new THREE.CylinderGeometry(2, 2.5, 8, 8),
                new THREE.MeshLambertMaterial({ color: 0x2c3e50 })
            );
            tower.position.y = 4;
            managementHub.add(tower);
            
            // Communication arrays
            for (let i = 0; i < 4; i++) {
                const antenna = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 2, 8),
                    new THREE.MeshBasicMaterial({ color: 0xfbbf24 })
                );
                const angle = (i / 4) * Math.PI * 2;
                antenna.position.set(
                    Math.cos(angle) * 1.5,
                    9,
                    Math.sin(angle) * 1.5
                );
                managementHub.add(antenna);
            }
            
            // Status lights
            const statusLight = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
            );
            statusLight.position.y = 8.5;
            managementHub.add(statusLight);
            
            // Position at center of the city
            managementHub.position.set(0, 0, 120);
            scene.add(managementHub);
        }

        // Animate smart sensors with pulsing effect
        function animateSensor(sensor) {
            const originalScale = sensor.scale.clone();
            
            function pulse() {
                const time = Date.now() * 0.003;
                const scale = 1 + Math.sin(time) * 0.3;
                sensor.scale.setScalar(scale);
                
                // Change color based on availability
                const colors = [0x00ff00, 0xffff00, 0xff0000]; // Green, Yellow, Red
                const colorIndex = Math.floor(Math.random() * colors.length);
                sensor.material.color.setHex(colors[colorIndex]);
                
                requestAnimationFrame(pulse);
            }
            
            // Start pulsing with random delay
            setTimeout(pulse, Math.random() * 2000);
        }

        // ENHANCED: Create comprehensive parking signage system
        function createParkingSign(type = 'parking', height = 3, size = 1.2) {
            const signGroup = new THREE.Group();
            
            // Sign post
            const postGeometry = new THREE.CylinderGeometry(0.05, 0.05, height);
            const postMaterial = new THREE.MeshLambertMaterial({ color: 0x404040 });
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.y = height / 2;
            post.castShadow = true;
            signGroup.add(post);
            
            // Sign board background
            const boardGeometry = new THREE.PlaneGeometry(size, size);
            let boardColor, textColor, symbol;
            
            switch(type) {
                case 'parking':
                    boardColor = 0x0066cc; // Blue
                    textColor = 0xffffff; // White
                    symbol = 'P';
                    break;
                case 'ev':
                    boardColor = 0x10b981; // Green
                    textColor = 0xffffff; // White
                    symbol = 'EV';
                    break;
                case 'handicap':
                    boardColor = 0x0066ff; // Bright Blue
                    textColor = 0xffffff; // White
                    symbol = '‚ôø';
                    break;
                case 'no_parking':
                    boardColor = 0xdc2626; // Red
                    textColor = 0xffffff; // White
                    symbol = 'üö´P';
                    break;
                case 'reserved':
                    boardColor = 0x8b5cf6; // Purple
                    textColor = 0xffffff; // White
                    symbol = 'R';
                    break;
                default:
                    boardColor = 0x0066cc;
                    textColor = 0xffffff;
                    symbol = 'P';
            }
            
            const boardMaterial = new THREE.MeshLambertMaterial({ 
                color: boardColor,
                side: THREE.DoubleSide
            });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.position.set(0, height - size/2, 0);
            signGroup.add(board);
            
            // White border
            const borderGeometry = new THREE.PlaneGeometry(size + 0.1, size + 0.1);
            const borderMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide
            });
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            border.position.set(0, height - size/2, -0.01);
            signGroup.add(border);
            
            // Create symbol/text representation (simplified)
            const symbolGeometry = new THREE.PlaneGeometry(size * 0.6, size * 0.6);
            const symbolMaterial = new THREE.MeshLambertMaterial({ 
                color: textColor,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            const symbolMesh = new THREE.Mesh(symbolGeometry, symbolMaterial);
            symbolMesh.position.set(0, height - size/2, 0.01);
            signGroup.add(symbolMesh);
            
            // Add additional info panel for some signs
            if (type === 'ev' || type === 'handicap') {
                const infoGeometry = new THREE.PlaneGeometry(size, size * 0.4);
                const infoMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xffffff,
                    side: THREE.DoubleSide
                });
                const infoPanel = new THREE.Mesh(infoGeometry, infoMaterial);
                infoPanel.position.set(0, height - size * 1.2, 0);
                signGroup.add(infoPanel);
                
                // Info text background
                const infoTextGeometry = new THREE.PlaneGeometry(size * 0.9, size * 0.3);
                const infoTextMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x333333,
                    side: THREE.DoubleSide
                });
                const infoText = new THREE.Mesh(infoTextGeometry, infoTextMaterial);
                infoText.position.set(0, height - size * 1.2, 0.01);
                signGroup.add(infoText);
            }
            
            return signGroup;
        }
        
        // Create directional parking sign with arrow
        function createDirectionalParkingSign(direction = 'straight', distance = '') {
            const signGroup = new THREE.Group();
            
            // Sign post
            const postGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2.5);
            const postMaterial = new THREE.MeshLambertMaterial({ color: 0x404040 });
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.y = 1.25;
            signGroup.add(post);
            
            // Arrow board
            const boardGeometry = new THREE.PlaneGeometry(2, 0.8);
            const boardMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x0066cc,
                side: THREE.DoubleSide
            });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.position.set(0, 2.1, 0);
            signGroup.add(board);
            
            // White border
            const borderGeometry = new THREE.PlaneGeometry(2.1, 0.9);
            const borderMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide
            });
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            border.position.set(0, 2.1, -0.01);
            signGroup.add(border);
            
            // Arrow shape (simplified)
            const arrowGeometry = new THREE.PlaneGeometry(1.5, 0.4);
            const arrowMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide
            });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            
            // Rotate arrow based on direction
            switch(direction) {
                case 'left':
                    arrow.rotation.z = Math.PI;
                    break;
                case 'right':
                    arrow.rotation.z = 0;
                    break;
                case 'up':
                    arrow.rotation.z = Math.PI / 2;
                    break;
                default: // straight
                    arrow.rotation.z = Math.PI / 2;
            }
            
            arrow.position.set(0, 2.1, 0.01);
            signGroup.add(arrow);
            
            return signGroup;
        }
        
        // Create parking entrance/exit sign
        function createParkingGateSign(type = 'entrance') {
            const signGroup = new THREE.Group();
            
            // Sign frame (larger for gate signs)
            const frameGeometry = new THREE.BoxGeometry(4, 2, 0.1);
            const frameColor = type === 'entrance' ? 0x10b981 : 0xdc2626; // Green for entrance, Red for exit
            const frameMaterial = new THREE.MeshLambertMaterial({ color: frameColor });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.y = 1;
            signGroup.add(frame);
            
            // White background
            const bgGeometry = new THREE.BoxGeometry(3.8, 1.8, 0.05);
            const bgMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const background = new THREE.Mesh(bgGeometry, bgMaterial);
            background.position.set(0, 1, 0.03);
            signGroup.add(background);
            
            // Text area (simplified representation)
            const textGeometry = new THREE.PlaneGeometry(3.4, 0.8);
            const textMaterial = new THREE.MeshLambertMaterial({ 
                color: frameColor,
                side: THREE.DoubleSide
            });
            const text = new THREE.Mesh(textGeometry, textMaterial);
            text.position.set(0, 1.2, 0.06);
            signGroup.add(text);
            
            // Icon area
            const iconGeometry = new THREE.PlaneGeometry(1, 0.6);
            const iconMaterial = new THREE.MeshLambertMaterial({ 
                color: frameColor,
                side: THREE.DoubleSide
            });
            const icon = new THREE.Mesh(iconGeometry, iconMaterial);
            icon.position.set(0, 0.6, 0.06);
            signGroup.add(icon);
            
            return signGroup;
        }

        // ENHANCED: Create parking support columns for covered areas
        function createParkingColumn(height = 4, radius = 0.3) {
            const column = new THREE.Group();
            
            // Main column
            const columnGeometry = new THREE.CylinderGeometry(radius, radius, height);
            const columnMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xcccccc,
                shininess: 30
            });
            const columnMesh = new THREE.Mesh(columnGeometry, columnMaterial);
            columnMesh.position.y = height / 2;
            columnMesh.castShadow = true;
            column.add(columnMesh);
            
            // Column base (foundation)
            const baseGeometry = new THREE.CylinderGeometry(radius * 1.5, radius * 1.8, 0.3);
            const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x999999 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.15;
            column.add(base);
            
            // Column capital (top)
            const capitalGeometry = new THREE.CylinderGeometry(radius * 1.3, radius, 0.4);
            const capital = new THREE.Mesh(capitalGeometry, columnMaterial);
            capital.position.y = height - 0.2;
            column.add(capital);
            
            return column;
        }
        
        // Create covered parking area with roof and columns
        function createCoveredParkingArea(width, depth, height = 4.5) {
            const coveredArea = new THREE.Group();
            
            // Calculate column positions (every 6 meters)
            const columnsX = Math.ceil(width / 6) + 1;
            const columnsZ = Math.ceil(depth / 6) + 1;
            
            // Create support columns
            for (let x = 0; x < columnsX; x++) {
                for (let z = 0; z < columnsZ; z++) {
                    const column = createParkingColumn(height);
                    column.position.set(
                        -width/2 + (x * width/(columnsX - 1)),
                        0,
                        -depth/2 + (z * depth/(columnsZ - 1))
                    );
                    coveredArea.add(column);
                }
            }
            
            // Create roof canopy
            const roofGeometry = new THREE.PlaneGeometry(width + 2, depth + 2);
            const roofMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x888888,
                side: THREE.DoubleSide
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.rotation.x = -Math.PI / 2;
            roof.position.y = height + 0.2;
            roof.receiveShadow = true;
            roof.castShadow = true;
            coveredArea.add(roof);
            
            // Add roof edge trim
            const edgeMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            
            // Front and back edges
            [-depth/2 - 1, depth/2 + 1].forEach(z => {
                const edge = new THREE.Mesh(
                    new THREE.BoxGeometry(width + 2, 0.3, 0.2),
                    edgeMaterial
                );
                edge.position.set(0, height + 0.35, z);
                coveredArea.add(edge);
            });
            
            // Left and right edges
            [-width/2 - 1, width/2 + 1].forEach(x => {
                const edge = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.3, depth + 2),
                    edgeMaterial
                );
                edge.position.set(x, height + 0.35, 0);
                coveredArea.add(edge);
            });
            
            // Add lighting fixtures under roof
            const lightSpacing = 8;
            const lightsX = Math.floor(width / lightSpacing) || 1;
            const lightsZ = Math.floor(depth / lightSpacing) || 1;
            
            for (let x = 0; x < lightsX; x++) {
                for (let z = 0; z < lightsZ; z++) {
                    const lightFixture = new THREE.Mesh(
                        new THREE.BoxGeometry(1.5, 0.2, 0.8),
                        new THREE.MeshLambertMaterial({ 
                            color: 0xffffcc,
                            emissive: 0x333322,
                            emissiveIntensity: 0.2
                        })
                    );
                    lightFixture.position.set(
                        -width/2 + (x + 0.5) * (width / lightsX),
                        height - 0.3,
                        -depth/2 + (z + 0.5) * (depth / lightsZ)
                    );
                    coveredArea.add(lightFixture);
                }
            }
            
            return coveredArea;
        }

        // ENHANCED: Create detailed parking lines with numbering
        function createParkingLines(x, z, width = 2.5, length = 5, spaceNumber = null, isHandicap = false, isEV = false) {
            const group = new THREE.Group();
            
            // Choose line color based on parking type
            let lineColor = 0xffffff; // Default white
            if (isHandicap) lineColor = 0x0066ff; // Blue for handicap
            else if (isEV) lineColor = 0x00ff00; // Green for EV
            
            const lineMaterial = new THREE.MeshLambertMaterial({ 
                color: lineColor,
                transparent: true,
                opacity: 0.9
            });
            
            // Enhanced line thickness
            const lineThickness = 0.15;
            
            // 2 ƒë∆∞·ªùng d·ªçc (side lines)
            [-width/2, width/2].forEach(offsetX => {
                const lineGeometry = new THREE.PlaneGeometry(lineThickness, length);
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = -Math.PI / 2;
                line.position.set(x + offsetX, 0.02, z);
                group.add(line);
            });
            
            // 2 ƒë∆∞·ªùng ngang (end lines)
            [-length/2, length/2].forEach(offsetZ => {
                const lineGeometry = new THREE.PlaneGeometry(width, lineThickness);
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = -Math.PI / 2;
                line.position.set(x, 0.02, z + offsetZ);
                group.add(line);
            });
            
            // Add parking space number
            if (spaceNumber !== null) {
                const numberGeometry = new THREE.PlaneGeometry(0.8, 0.8);
                const numberMaterial = new THREE.MeshLambertMaterial({ 
                    color: lineColor,
                    transparent: true,
                    opacity: 0.8
                });
                const numberPlane = new THREE.Mesh(numberGeometry, numberMaterial);
                numberPlane.rotation.x = -Math.PI / 2;
                numberPlane.position.set(x, 0.03, z);
                group.add(numberPlane);
            }
            
            // Special markings for handicap spaces
            if (isHandicap) {
                const handicapSymbol = new THREE.Mesh(
                    new THREE.PlaneGeometry(1.2, 1.2),
                    new THREE.MeshLambertMaterial({ 
                        color: 0x0066ff,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                handicapSymbol.rotation.x = -Math.PI / 2;
                handicapSymbol.position.set(x, 0.04, z - 1);
                group.add(handicapSymbol);
            }
            
            // Special markings for EV spaces
            if (isEV) {
                const evSymbol = new THREE.Mesh(
                    new THREE.PlaneGeometry(1.0, 1.0),
                    new THREE.MeshLambertMaterial({ 
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.7
                    })
                );
                evSymbol.rotation.x = -Math.PI / 2;
                evSymbol.position.set(x, 0.04, z + 1);
                group.add(evSymbol);
            }
            
            return group;
        }
        
        // Create comprehensive parking space with lines and markings
        function createCompleteParkingSpace(x, z, spaceNumber, type = 'normal') {
            const group = new THREE.Group();
            
            const isHandicap = type === 'handicap';
            const isEV = type === 'ev';
            
            // Create parking lines
            const lines = createParkingLines(x, z, 2.5, 5, spaceNumber, isHandicap, isEV);
            group.add(lines);
            
            // Cars removed - only parking structure will have cars
            
            return group;
        }
        
        // ENHANCED: Create simple parking roof
        function createParkingRoof(width, depth, height) {
            const roofGroup = new THREE.Group();
            
            // Main roof plane
            const roofGeometry = new THREE.PlaneGeometry(width, depth);
            const roofMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x888888,
                side: THREE.DoubleSide
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.rotation.x = -Math.PI / 2;
            roof.position.y = height;
            roof.receiveShadow = true;
            roof.castShadow = true;
            roofGroup.add(roof);
            
            // Roof support beams
            const beamMaterial = new THREE.MeshLambertMaterial({ color: 0x606060 });
            
            // Cross beams
            for (let i = -1; i <= 1; i++) {
                const crossBeam = new THREE.Mesh(
                    new THREE.BoxGeometry(width, 0.3, 0.5),
                    beamMaterial
                );
                crossBeam.position.set(0, height - 0.2, i * depth/3);
                roofGroup.add(crossBeam);
            }
            
            // Side beams
            for (let i = -1; i <= 1; i++) {
                const sideBeam = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.3, depth),
                    beamMaterial
                );
                sideBeam.position.set(i * width/3, height - 0.2, 0);
                roofGroup.add(sideBeam);
            }
            
            return roofGroup;
        }
        
        // ENHANCED: Setup complete realistic parking lot demonstration
        function setupRealisticParkingLot() {
            const parkingGroup = new THREE.Group();
            
            // Base asphalt - Gi·∫£m xu·ªëng 1/4 di·ªán t√≠ch
            const asphalt = new THREE.Mesh(
                new THREE.BoxGeometry(15, 0.1, 10),  // Gi·∫£m t·ª´ 30√ó20 xu·ªëng 15√ó10
                new THREE.MeshLambertMaterial({ color: 0x2c2c2c })
            );
            asphalt.position.y = -0.05;
            asphalt.receiveShadow = true;
            parkingGroup.add(asphalt);
            
            // Add roof structure - ƒêi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc cho ph√π h·ª£p
            const roof = createParkingRoof(12, 7, 4.5);  // Gi·∫£m t·ª´ 25√ó15 xu·ªëng 12√ó7
            parkingGroup.add(roof);
            
            // Add support columns (4 corners + center) - ƒêi·ªÅu ch·ªânh v·ªã tr√≠
            const columnPositions = [
                [-5, -3], [5, -3], [-5, 3], [5, 3], [0, 0]  // Gi·∫£m kho·∫£ng c√°ch ph√π h·ª£p v·ªõi k√≠ch th∆∞·ªõc m·ªõi
            ];
            columnPositions.forEach(pos => {
                const column = createParkingColumn(4.5);
                column.position.set(pos[0], 0, pos[1]);
                parkingGroup.add(column);
            });
            
            // Add parking spaces with lines only (no cars)
            let spaceNumber = 1;
            
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 8; col++) {
                    const x = (col - 3.5) * 3;
                    const z = (row - 0.5) * 6;
                    
                    // Determine special spaces
                    let spaceType = 'normal';
                    if (col === 0 && row === 0) spaceType = 'handicap';
                    else if (col === 7 && row === 0) spaceType = 'ev';
                    
                    // Add parking lines
                    const lines = createParkingLines(x, z, 2.5, 5, spaceNumber, 
                        spaceType === 'handicap', spaceType === 'ev');
                    parkingGroup.add(lines);
                    
                    // Cars removed - only parking structure will have cars
                    
                    spaceNumber++;
                }
            }
            
            // Add lighting under roof
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const light = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.2, 1),
                        new THREE.MeshLambertMaterial({ 
                            color: 0xffffcc,
                            emissive: 0x444422,
                            emissiveIntensity: 0.3
                        })
                    );
                    light.position.set(i * 8, 4.3, j * 5);
                    parkingGroup.add(light);
                }
            }
            
            // Add signage
            const mainSign = createParkingSign('parking', 3.5, 1.8);
            mainSign.position.set(0, 0, 12);
            parkingGroup.add(mainSign);
            
            const handicapSign = createParkingSign('handicap', 2.5, 1.0);
            handicapSign.position.set(-10.5, 0, -3);
            parkingGroup.add(handicapSign);
            
            const evSign = createParkingSign('ev', 2.5, 1.0);
            evSign.position.set(10.5, 0, -3);
            parkingGroup.add(evSign);
            
            // Add directional signs
            const entranceSign = createDirectionalParkingSign('straight');
            entranceSign.position.set(-12, 0, 8);
            entranceSign.rotation.y = Math.PI / 2;
            parkingGroup.add(entranceSign);
            
            const exitSign = createDirectionalParkingSign('left');
            exitSign.position.set(12, 0, 8);
            exitSign.rotation.y = -Math.PI / 2;
            parkingGroup.add(exitSign);
            
            // Add entrance/exit gates
            const entranceGate = createParkingGateSign('entrance');
            entranceGate.position.set(-14, 0, 0);
            entranceGate.rotation.y = Math.PI / 2;
            parkingGroup.add(entranceGate);
            
            const exitGate = createParkingGateSign('exit');
            exitGate.position.set(14, 0, 0);
            exitGate.rotation.y = -Math.PI / 2;
            parkingGroup.add(exitGate);
            
            // Add landscaping (small trees at corners)
            const treePositions = [
                [-13, 10], [13, 10], [-13, -10], [13, -10]
            ];
            treePositions.forEach(pos => {
                const tree = createTree();
                tree.position.set(pos[0], 0, pos[1]);
                tree.scale.setScalar(0.6);
                parkingGroup.add(tree);
            });
            
            return parkingGroup;
        }

        function addCarsToParking() {
            console.log('üöó DEBUG: addCarsToParking() called!');
            console.log('üìç PARKING_STRUCTURE:', PARKING_STRUCTURE);
            
            const carColors = [0x0066cc, 0xcc0000, 0x00cc66, 0xcccc00, 0x6600cc, 0xffffff];
            let carCount = 0;
            
            // Duy·ªát qua t·ª´ng t·∫ßng (0-3)
            for (let floor = 0; floor < 4; floor++) {
                const floorY = floor * 3 + 1; // ƒê·ªô cao m·ªói t·∫ßng
                
                // T·∫°o xe tr√™n m·ªói t·∫ßng
                for (let row = 0; row < 2; row++) {
                    for (let col = 0; col < 6; col++) {
                        // Fixed positioning: center cars within parking structure bounds
                        const carX = PARKING_STRUCTURE.x + (col - 2.5) * 2; // Center around structure
                        const carZ = PARKING_STRUCTURE.z + (row - 0.5) * 3; // Center rows
                        
                        // 80% c√≥ xe
                        if (Math.random() < 0.8) {
                            const car = createCar(carColors[Math.floor(Math.random() * carColors.length)]);
                            car.position.set(carX, floorY, carZ);
                            scene.add(car);
                            carCount++;
                            console.log(`üöó Car ${carCount} added at (${carX.toFixed(1)}, ${floorY}, ${carZ.toFixed(1)}) - Floor ${floor}, Row ${row}, Col ${col}`);
                        }
                    }
                }
            }
            
            console.log(`‚úÖ Total ${carCount} cars added to parking structure`);
        }

        function improveParkingStructure() {
            // Th√™m ramp (ƒë∆∞·ªùng n·ªëi gi·ªØa c√°c t·∫ßng)
            const rampGeometry = new THREE.PlaneGeometry(2, 8);
            const rampMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            
            for (let floor = 1; floor < 4; floor++) {
                const ramp = new THREE.Mesh(rampGeometry, rampMaterial);
                ramp.rotation.x = -Math.PI / 6; // G√≥c nghi√™ng
                ramp.position.set(PARKING_STRUCTURE.x + 6, floor * 3, PARKING_STRUCTURE.z);
                scene.add(ramp);
            }
            
            // Th√™m ƒë∆∞·ªùng k·∫ª parking spots
            addParkingLineMarkings();
            
            // Th√™m ƒë√®n chi·∫øu s√°ng
            addParkingLights();
        }

        function addParkingLineMarkings() {
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            for (let floor = 0; floor < 4; floor++) {
                const floorY = floor * 3 + 0.05; // ƒê·∫∑t tr√™n m·∫∑t s√†n
                
                // V·∫°ch d·ªçc cho t·ª´ng ch·ªó ƒë·∫≠u xe
                for (let row = 0; row < 2; row++) {
                    for (let col = 0; col <= 6; col++) { // +1 ƒë·ªÉ c√≥ v·∫°ch cu·ªëi
                        const lineX = PARKING_STRUCTURE.x + (col - 3) * 2; // Match car positioning
                        const lineZ = PARKING_STRUCTURE.z + (row - 0.5) * 3;
                        
                        const line = new THREE.Mesh(
                            new THREE.BoxGeometry(0.1, 0.01, 3),
                            lineMaterial
                        );
                        line.position.set(lineX, floorY, lineZ);
                        scene.add(line);
                    }
                }
                
                // V·∫°ch ngang ph√¢n chia h√†ng
                for (let row = 0; row <= 2; row++) { // +1 ƒë·ªÉ c√≥ v·∫°ch cu·ªëi
                    const lineZ = PARKING_STRUCTURE.z + (row - 1) * 3;
                    const line = new THREE.Mesh(
                        new THREE.BoxGeometry(12, 0.01, 0.1),
                        lineMaterial
                    );
                    line.position.set(PARKING_STRUCTURE.x, floorY, lineZ);
                    scene.add(line);
                }
            }
        }

        function addParkingLights() {
            const lightMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffcc,
                emissive: 0xffffcc,
                emissiveIntensity: 0.3
            });
            
            for (let floor = 0; floor < 4; floor++) {
                const lightY = floor * 3 + 2.8; // G·∫ßn tr·∫ßn
                
                // ƒê√®n ·ªü 4 g√≥c m·ªói t·∫ßng
                const lightPositions = [
                    [PARKING_STRUCTURE.x - 4, lightY, PARKING_STRUCTURE.z - 2],
                    [PARKING_STRUCTURE.x + 4, lightY, PARKING_STRUCTURE.z - 2],
                    [PARKING_STRUCTURE.x - 4, lightY, PARKING_STRUCTURE.z + 2],
                    [PARKING_STRUCTURE.x + 4, lightY, PARKING_STRUCTURE.z + 2]
                ];
                
                lightPositions.forEach(pos => {
                    const light = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 0.2, 0.5),
                        lightMaterial
                    );
                    light.position.set(pos[0], pos[1], pos[2]);
                    scene.add(light);
                    
                    // Th√™m point light th·ª±c t·∫ø
                    const pointLight = new THREE.PointLight(0xffffcc, 0.5, 10);
                    pointLight.position.set(pos[0], pos[1], pos[2]);
                    scene.add(pointLight);
                });
            }
        }

        function createCar(color = null) {
            const car = new THREE.Group();
            
            if (!color) {
                const colors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0x000000, 0xffffff, 0xff6600, 0x8b4513, 0x800080, 0x00ced1];
                color = colors[Math.floor(Math.random() * colors.length)];
            }
            
            // ENHANCED: Realistic car materials
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: color,
                shininess: 100,
                specular: 0x222222
            });
            const glassMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.7
            });
            const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const tireMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const lightMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffffcc,
                emissive: 0x444422,
                emissiveIntensity: 0.3
            });
            const tailLightMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xff4444,
                emissive: 0x441111,
                emissiveIntensity: 0.2
            });
            
            // ENHANCED: Main body with better proportions
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(4, 1, 1.8),
                bodyMaterial
            );
            body.position.y = 0.5;
            car.add(body);
            
            // ENHANCED: Cabin with windows
            const cabin = new THREE.Mesh(
                new THREE.BoxGeometry(2.5, 0.8, 1.6),
                bodyMaterial
            );
            cabin.position.set(0, 1.2, 0);
            car.add(cabin);
            
            // ENHANCED: Windshield and windows
            const windshield = new THREE.Mesh(
                new THREE.PlaneGeometry(2.3, 0.7),
                glassMaterial
            );
            windshield.position.set(0, 1.25, 0.81);
            windshield.rotation.x = -0.1;
            car.add(windshield);
            
            const rearWindow = new THREE.Mesh(
                new THREE.PlaneGeometry(2.3, 0.7),
                glassMaterial
            );
            rearWindow.position.set(0, 1.25, -0.81);
            rearWindow.rotation.x = 0.1;
            car.add(rearWindow);
            
            // Side windows
            [-0.81, 0.81].forEach(side => {
                const sideWindow = new THREE.Mesh(
                    new THREE.PlaneGeometry(2.3, 0.7),
                    glassMaterial
                );
                sideWindow.position.set(side, 1.25, 0);
                sideWindow.rotation.y = side > 0 ? Math.PI/2 : -Math.PI/2;
                car.add(sideWindow);
            });
            
            // ENHANCED: Realistic wheels with rims and tires
            const wheelPositions = [
                { x: -0.8, z: 1.3 },
                { x: 0.8, z: 1.3 },
                { x: -0.8, z: -1.3 },
                { x: 0.8, z: -1.3 }
            ];
            
            wheelPositions.forEach(pos => {
                const wheelGroup = new THREE.Group();
                
                // Tire (outer)
                const tire = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.35, 0.35, 0.25),
                    tireMaterial
                );
                tire.rotation.z = Math.PI / 2;
                wheelGroup.add(tire);
                
                // Rim (inner)
                const rim = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.25, 0.25, 0.3),
                    new THREE.MeshPhongMaterial({ 
                        color: 0xc0c0c0,
                        shininess: 100
                    })
                );
                rim.rotation.z = Math.PI / 2;
                wheelGroup.add(rim);
                
                // Rim details (spokes)
                for (let i = 0; i < 5; i++) {
                    const spoke = new THREE.Mesh(
                        new THREE.BoxGeometry(0.02, 0.4, 0.02),
                        new THREE.MeshPhongMaterial({ color: 0x888888 })
                    );
                    spoke.rotation.z = (i / 5) * Math.PI * 2;
                    spoke.position.z = 0.01;
                    wheelGroup.add(spoke);
                }
                
                wheelGroup.position.set(pos.x, 0.35, pos.z);
                car.add(wheelGroup);
            });
            
            // ENHANCED: Headlights
            [-0.7, 0.7].forEach(side => {
                const headlight = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    lightMaterial
                );
                headlight.position.set(side, 0.7, 1.9);
                car.add(headlight);
            });
            
            // ENHANCED: Tail lights
            [-0.6, 0.6].forEach(side => {
                const taillight = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.3, 0.1),
                    tailLightMaterial
                );
                taillight.position.set(side, 0.6, -1.9);
                car.add(taillight);
            });
            
            // ENHANCED: Side mirrors
            [-0.9, 0.9].forEach(side => {
                const mirrorArm = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 0.05, 0.15),
                    new THREE.MeshPhongMaterial({ color: 0x333333 })
                );
                mirrorArm.position.set(side, 1.5, 0.6);
                mirrorArm.rotation.y = side > 0 ? -0.3 : 0.3;
                car.add(mirrorArm);
                
                const mirror = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 0.08, 0.02),
                    new THREE.MeshPhongMaterial({ 
                        color: 0xffffff,
                        shininess: 100,
                        reflectivity: 0.8
                    })
                );
                mirror.position.set(side * 1.05, 1.52, 0.7);
                car.add(mirror);
            });
            
            // ENHANCED: License plate
            const licensePlate = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.15, 0.02),
                new THREE.MeshLambertMaterial({ color: 0xffffff })
            );
            licensePlate.position.set(0, 0.3, -1.92);
            car.add(licensePlate);
            
            // ENHANCED: Antenna
            const antenna = new THREE.Mesh(
                new THREE.CylinderGeometry(0.01, 0.01, 0.3),
                new THREE.MeshLambertMaterial({ color: 0x333333 })
            );
            antenna.position.set(0.6, 2.15, -0.3);
            car.add(antenna);
            
            // ENHANCED: Door handles
            [-0.9, 0.9].forEach(side => {
                const handle = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, 0.08, 0.05),
                    new THREE.MeshPhongMaterial({ color: 0x666666 })
                );
                handle.position.set(side, 1.1, 0.3);
                car.add(handle);
            });
            
            // Add metadata to identify this as a car
            car.userData = {
                type: 'car',
                createdAt: Date.now()
            };
            
            return car;
        }

        function relocateMisplacedCars() {
            console.log('üîç Searching for misplaced cars...');
            
            // T√¨m t·∫•t c·∫£ xe ·ªü ground level (kh√¥ng thu·ªôc parking structure)
            const misplacedCars = [];
            scene.children.forEach(child => {
                if (child.userData && child.userData.type === 'car') {
                    // Xe ·ªü ground level ho·∫∑c v·ªã tr√≠ trung t√¢m
                    if (child.position.y < 2) {
                        misplacedCars.push(child);
                        console.log(`üöó Found misplaced car at (${child.position.x.toFixed(1)}, ${child.position.y.toFixed(1)}, ${child.position.z.toFixed(1)})`);
                    }
                }
            });

            console.log(`üìä Found ${misplacedCars.length} cars to relocate`);
            
            if (misplacedCars.length === 0) {
                console.log('‚úÖ No misplaced cars found');
                return;
            }
            
            // Di chuy·ªÉn xe v√†o parking structure
            moveCarsToParking(misplacedCars);
        }

        function moveCarsToParking(carsToMove) {
            console.log(`üöõ Moving ${carsToMove.length} cars to parking structure...`);
            
            const carColors = [0x0066cc, 0xcc0000, 0x00cc66, 0xcccc00, 0x6600cc, 0xffffff];
            let carsMoved = 0;
            let availableSpots = [];
            
            // T·∫°o danh s√°ch ch·ªó ƒë·∫≠u xe tr·ªëng trong parking structure
            for (let floor = 0; floor < 4; floor++) {
                for (let row = 0; row < 2; row++) {
                    for (let col = 0; col < 6; col++) {
                        const floorY = floor * 3 + 1;
                        const carX = PARKING_STRUCTURE.x + (col - 2.5) * 2;
                        const carZ = PARKING_STRUCTURE.z + (row - 0.5) * 3;
                        
                        availableSpots.push({
                            x: carX,
                            y: floorY,
                            z: carZ,
                            floor: floor,
                            row: row,
                            col: col
                        });
                    }
                }
            }
            
            // Di chuy·ªÉn t·ª´ng xe
            carsToMove.forEach((car, index) => {
                if (index < availableSpots.length) {
                    const spot = availableSpots[index];
                    
                    // X√≥a xe kh·ªèi scene tr∆∞·ªõc
                    scene.remove(car);
                    
                    // T·∫°o xe m·ªõi t·∫°i v·ªã tr√≠ parking structure
                    const newCar = createCar(carColors[index % carColors.length]);
                    newCar.position.set(spot.x, spot.y, spot.z);
                    newCar.rotation.y = Math.random() > 0.5 ? 0 : Math.PI;
                    scene.add(newCar);
                    
                    carsMoved++;
                    console.log(`üöó Car ${carsMoved} moved to parking structure at (${spot.x.toFixed(1)}, ${spot.y}, ${spot.z.toFixed(1)}) - Floor ${spot.floor}`);
                }
            });
            
            console.log(`‚úÖ Successfully moved ${carsMoved} cars to parking structure`);
        }

        function removeCenterParkingArea() {
            console.log("üéØ Targeting center parking area for removal...");
            
            // T·ªça ƒë·ªô v√πng trung t√¢m g·∫ßn h·ªì n∆∞·ªõc (∆∞·ªõc t√≠nh)
            const CENTER_AREA = {
                minX: -5,
                maxX: 15,
                minZ: -15, 
                maxZ: 15,
                minY: -1,
                maxY: 2
            };

            const objectsToRemove = [];
            
            // Qu√©t to√†n b·ªô scene t√¨m objects trong v√πng trung t√¢m
            scene.children.forEach(child => {
                const pos = child.position;
                
                // Ki·ªÉm tra xem object c√≥ trong v√πng CENTER_AREA kh√¥ng
                if (pos.x >= CENTER_AREA.minX && pos.x <= CENTER_AREA.maxX &&
                    pos.z >= CENTER_AREA.minZ && pos.z <= CENTER_AREA.maxZ &&
                    pos.y >= CENTER_AREA.minY && pos.y <= CENTER_AREA.maxY) {
                    
                    // Ki·ªÉm tra xem c√≥ ph·∫£i l√† parking-related object kh√¥ng
                    const isParkingRelated = (
                        child.material && (
                            (child.material.color && child.material.color.getHex() === 0x333333) || // Asphalt
                            (child.material.color && child.material.color.getHex() === 0xffffff) || // White lines
                            (child.material.color && child.material.color.getHex() === 0x2c2c2c) || // Dark asphalt
                            (child.material.color && child.material.color.getHex() === 0xffff00) || // Yellow lines
                            (child.material.color && child.material.color.getHex() === 0x0066cc) || // Blue handicap
                            (child.material.color && child.material.color.getHex() === 0x00cc66)    // Green EV
                        ) ||
                        (child.userData && child.userData.type === 'car') ||
                        (child.geometry && (
                            child.geometry.type === 'BoxGeometry' || 
                            child.geometry.type === 'PlaneGeometry'
                        ))
                    );
                    
                    if (isParkingRelated) {
                        objectsToRemove.push(child);
                        console.log(`üóëÔ∏è Marking for removal: ${child.constructor.name} at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);
                    }
                }
            });

            // X√≥a t·∫•t c·∫£ objects ƒë√£ ƒë√°nh d·∫•u
            objectsToRemove.forEach(obj => {
                scene.remove(obj);
                
                // Dispose geometry v√† material ƒë·ªÉ gi·∫£i ph√≥ng memory
                if (obj.geometry) {
                    obj.geometry.dispose();
                }
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => mat.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
            });

            console.log(`‚úÖ Removed ${objectsToRemove.length} objects from center parking area`);
            console.log(`üßπ Center area (${CENTER_AREA.minX}-${CENTER_AREA.maxX}, ${CENTER_AREA.minZ}-${CENTER_AREA.maxZ}) cleared!`);
        }

        function clearParkingInCenterArea() {
            console.log("üßπ Starting comprehensive center area cleanup...");
            
            // X√≥a parking lots c·ª• th·ªÉ ·ªü v√πng trung t√¢m
            const lotsToRemove = [];
            
            parkingLots.forEach((lot, index) => {
                const pos = lot.position;
                
                // Ki·ªÉm tra parking lots ·ªü v√πng trung t√¢m
                if (pos.x >= -20 && pos.x <= 20 && pos.z >= -20 && pos.z <= 20) {
                    lotsToRemove.push({lot: lot, index: index});
                    console.log(`üÖøÔ∏è Found parking lot to remove at (${pos.x}, ${pos.y}, ${pos.z})`);
                }
            });
            
            // X√≥a t·ª´ scene v√† array
            lotsToRemove.reverse().forEach(item => { // Reverse ƒë·ªÉ index kh√¥ng b·ªã l·ªách
                scene.remove(item.lot);
                parkingLots.splice(item.index, 1);
                console.log(`‚úÖ Removed parking lot from scene and array`);
            });
            
            // G·ªçi h√†m x√≥a chi ti·∫øt
            removeCenterParkingArea();
            
            console.log("üéâ Center area cleanup completed!");
        }

        function forceRemoveAllCenterCars() {
            console.log("üö® FORCE REMOVING ALL CENTER CARS...");
            
            const carsRemoved = [];
            const objectsRemoved = [];
            
            // Qu√©t to√†n b·ªô scene t·ª´ cu·ªëi v·ªÅ ƒë·∫ßu ƒë·ªÉ tr√°nh index shift
            for (let i = scene.children.length - 1; i >= 0; i--) {
                const child = scene.children[i];
                
                if (!child || !child.position) continue;
                
                const pos = child.position;
                
                // M·ªü r·ªông v√πng x√≥a ƒë·ªÉ bao ph·ªß to√†n b·ªô trung t√¢m
                if (pos.x > -25 && pos.x < 25 && 
                    pos.z > -25 && pos.z < 25 && 
                    pos.y > -1 && pos.y < 10) {
                    
                    let shouldRemove = false;
                    
                    // Ki·ªÉm tra nhi·ªÅu ƒëi·ªÅu ki·ªán ƒë·ªÉ x√°c ƒë·ªãnh xe
                    if (child.userData && child.userData.type === 'car') {
                        shouldRemove = true;
                        console.log(`üöó Removing car with userData at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);
                    }
                    
                    // Ki·ªÉm tra Group c√≥ th·ªÉ ch·ª©a xe (theo s·ªë l∆∞·ª£ng children)
                    else if (child.type === 'Group' && child.children && child.children.length >= 5 && child.children.length <= 20) {
                        shouldRemove = true;
                        console.log(`üöó Removing car group (${child.children.length} parts) at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);
                    }
                    
                    // Ki·ªÉm tra Mesh c√≥ k√≠ch th∆∞·ªõc nh∆∞ xe
                    else if (child.type === 'Mesh' && child.geometry && child.geometry.parameters) {
                        const params = child.geometry.parameters;
                        if (params.width && params.height && params.depth) {
                            // K√≠ch th∆∞·ªõc ƒëi·ªÉn h√¨nh c·ªßa xe: width 2-5, height 1-2, depth 3-6
                            if (params.width >= 2 && params.width <= 5 &&
                                params.height >= 0.5 && params.height <= 3 &&
                                params.depth >= 2 && params.depth <= 6) {
                                shouldRemove = true;
                                console.log(`üöó Removing car mesh (${params.width}x${params.height}x${params.depth}) at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);
                            }
                        }
                    }
                    
                    // Ki·ªÉm tra material m√†u xe ph·ªï bi·∫øn
                    else if (child.material && child.material.color) {
                        const color = child.material.color.getHex();
                        const carColors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0x000000, 0xffffff, 0xff6600, 0x8b4513, 0x800080, 0x00ced1, 0x0066cc, 0xcc0000, 0x00cc66, 0xcccc00, 0x6600cc];
                        if (carColors.includes(color) && pos.y < 3) {
                            shouldRemove = true;
                            console.log(`üöó Removing colored object (${color.toString(16)}) at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);
                        }
                    }
                    
                    if (shouldRemove) {
                        scene.remove(child);
                        
                        // Dispose resources
                        if (child.geometry) {
                            child.geometry.dispose();
                        }
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                        
                        // Dispose children recursively
                        if (child.children) {
                            child.children.forEach(grandchild => {
                                if (grandchild.geometry) grandchild.geometry.dispose();
                                if (grandchild.material) {
                                    if (Array.isArray(grandchild.material)) {
                                        grandchild.material.forEach(mat => mat.dispose());
                                    } else {
                                        grandchild.material.dispose();
                                    }
                                }
                            });
                        }
                        
                        carsRemoved.push({x: pos.x, y: pos.y, z: pos.z});
                    }
                }
            }
            
            console.log(`üóëÔ∏è Force removed ${carsRemoved.length} objects from center area`);
            console.log(`üßπ Center area completely cleared of vehicles!`);
            
            return carsRemoved.length;
        }

        function nuclearCleanCenter() {
            console.log("‚ò¢Ô∏è NUCLEAR CLEAN: Removing EVERYTHING from center...");
            
            let totalRemoved = 0;
            
            // L·∫ßn 1: X√≥a theo userData
            totalRemoved += forceRemoveAllCenterCars();
            
            // L·∫ßn 2: X√≥a theo v·ªã tr√≠ brutal
            const brutalRemoved = [];
            for (let i = scene.children.length - 1; i >= 0; i--) {
                const child = scene.children[i];
                if (!child || !child.position) continue;
                
                const pos = child.position;
                
                // V√πng c·∫•m tuy·ªát ƒë·ªëi - x√≥a m·ªçi th·ª©
                if (pos.x > -15 && pos.x < 15 && 
                    pos.z > -15 && pos.z < 15 && 
                    pos.y > -0.5 && pos.y < 3) {
                    
                    // B·ªè qua c√°c objects quan tr·ªçng (buildings, ground, water)
                    const isImportant = (
                        (child.material && child.material.color && 
                         (child.material.color.getHex() === 0x87CEEB || // Water
                          child.material.color.getHex() === 0x00ff00 || // Ground
                          child.material.color.getHex() === 0x228b22)) || // Grass
                        (child.geometry && child.geometry.parameters && 
                         child.geometry.parameters.width > 10) || // Large buildings
                        child.type === 'AmbientLight' ||
                        child.type === 'DirectionalLight' ||
                        child.type === 'PointLight'
                    );
                    
                    if (!isImportant) {
                        scene.remove(child);
                        brutalRemoved.push(pos);
                        console.log(`‚ò¢Ô∏è Nuclear removed object at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);
                    }
                }
            }
            
            console.log(`‚ò¢Ô∏è Nuclear clean removed ${brutalRemoved.length} additional objects`);
            console.log(`üéØ Total objects removed: ${totalRemoved + brutalRemoved.length}`);
        }

        function removeParkingStructureAndCars() {
            console.log("üèóÔ∏è REMOVING PARKING STRUCTURE AND ALL CARS...");
            
            // B∆Ø·ªöC 1: X√≥a t·∫•t c·∫£ xe trong parking structure
            const carsToRemove = [];
            scene.children.forEach(child => {
                if (child.userData && child.userData.type === 'car') {
                    const pos = child.position;
                    // Xe trong parking structure (x: -15 to -5, y: 1-15, z: -3 to 3)
                    if (pos.x >= -15 && pos.x <= -5 && 
                        pos.y >= 1 && pos.y <= 15 && 
                        pos.z >= -3 && pos.z <= 3) {
                        carsToRemove.push(child);
                        console.log(`üöó Found car in parking structure at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);
                    }
                }
            });
            
            carsToRemove.forEach(car => {
                scene.remove(car);
                // Dispose resources
                if (car.geometry) car.geometry.dispose();
                if (car.material) {
                    if (Array.isArray(car.material)) {
                        car.material.forEach(mat => mat.dispose());
                    } else {
                        car.material.dispose();
                    }
                }
                if (car.children) {
                    car.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                }
            });
            
            console.log(`‚úÖ Removed ${carsToRemove.length} cars from parking structure`);
            
            // B∆Ø·ªöC 2: X√≥a t·∫•t c·∫£ th√†nh ph·∫ßn parking structure
            const structureObjectsToRemove = [];
            
            scene.children.forEach(child => {
                const pos = child.position;
                
                // V√πng parking structure r·ªông h∆°n ƒë·ªÉ bao g·ªìm ramp, lights
                if (pos.x >= -20 && pos.x <= 0 && 
                    pos.z >= -5 && pos.z <= 5 && 
                    pos.y >= -1 && pos.y <= 16) {
                    
                    let shouldRemove = false;
                    
                    // Ki·ªÉm tra parking structure components
                    if (child.material && child.material.color) {
                        const color = child.material.color.getHex();
                        
                        // M√†u c·ªßa parking structure components
                        if (color === 0xcccccc || // Gray building
                            color === 0x333333 || // Dark posts
                            color === 0x666666 || // Ramp
                            color === 0xffffff || // White lines
                            color === 0xffffcc || // Yellow lights
                            color === 0x808080 || // Light gray
                            color === 0x606060) { // Medium gray
                            shouldRemove = true;
                            console.log(`üèóÔ∏è Found parking structure component (color: ${color.toString(16)}) at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);
                        }
                    }
                    
                    // Ki·ªÉm tra geometry k√≠ch th∆∞·ªõc parking structure
                    if (child.geometry && child.geometry.parameters) {
                        const params = child.geometry.parameters;
                        
                        // Ramp (PlaneGeometry 2x8)
                        if (params.width === 2 && params.height === 8) {
                            shouldRemove = true;
                            console.log(`üõ£Ô∏è Found ramp at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);
                        }
                        
                        // Parking lines (thin boxes)
                        if ((params.width === 0.1 && params.depth === 3) || 
                            (params.width === 12 && params.depth === 0.1)) {
                            shouldRemove = true;
                            console.log(`‚¨ú Found parking line at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);
                        }
                        
                        // Light fixtures (small boxes)
                        if (params.width === 0.5 && params.height === 0.2 && params.depth === 0.5) {
                            shouldRemove = true;
                            console.log(`üí° Found light fixture at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);
                        }
                        
                        // Main parking structure building
                        if (params.width >= 8 && params.width <= 15 && 
                            params.height >= 10 && params.height <= 15 && 
                            params.depth >= 6 && params.depth <= 12) {
                            shouldRemove = true;
                            console.log(`üè¢ Found main parking building at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);
                        }
                    }
                    
                    // Ki·ªÉm tra PointLight (ƒë√®n chi·∫øu s√°ng)
                    if (child.type === 'PointLight' && 
                        child.color && child.color.getHex() === 0xffffcc) {
                        shouldRemove = true;
                        console.log(`üí° Found parking point light at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})`);
                    }
                    
                    if (shouldRemove) {
                        structureObjectsToRemove.push(child);
                    }
                }
            });
            
            // X√≥a t·∫•t c·∫£ components
            structureObjectsToRemove.forEach(obj => {
                scene.remove(obj);
                
                // Dispose resources
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => mat.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
            });
            
            console.log(`‚úÖ Removed ${structureObjectsToRemove.length} parking structure components`);
            console.log(`üéâ PARKING STRUCTURE COMPLETELY REMOVED!`);
            console.log(`üåÜ City is now car-free!`);
        }

        function createCentralPark() {
            console.log("üå≥ Creating enhanced central park with beautiful fountain...");
            
            const parkGroup = new THREE.Group();
            parkGroup.userData = { type: 'central_park' };
            
            // B∆Ø·ªöC 1: T·∫°o nhi·ªÅu l·ªõp c·ªè xanh phong ph√∫ v·ªõi gradient m√†u
            // Th·∫£m c·ªè ch√≠nh - m·ªü r·ªông v√† t·ª± nhi√™n h∆°n
            const mainGrassGeometry = new THREE.CircleGeometry(35, 64);
            const mainGrassMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x228B22,
                side: THREE.DoubleSide
            });
            const mainGrass = new THREE.Mesh(mainGrassGeometry, mainGrassMaterial);
            mainGrass.rotation.x = -Math.PI / 2;
            mainGrass.position.set(0, 0, 0);
            mainGrass.userData = { type: 'main_grass' };
            parkGroup.add(mainGrass);
            
            // L·ªõp c·ªè n·ªÅn r·ªông h∆°n
            const baseGrassGeometry = new THREE.PlaneGeometry(70, 70);
            const baseGrassMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x32CD32,
                side: THREE.DoubleSide
            });
            const baseGrass = new THREE.Mesh(baseGrassGeometry, baseGrassMaterial);
            baseGrass.rotation.x = -Math.PI / 2;
            baseGrass.position.set(0, -0.01, 0);
            parkGroup.add(baseGrass);
            
            // Th√™m nhi·ªÅu v√πng c·ªè v·ªõi m√†u s·∫Øc v√† k·∫øt c·∫•u kh√°c nhau
            const grassPatches = [
                { x: 22, z: 22, size: 12, color: 0x228B22 },
                { x: -22, z: 22, size: 12, color: 0x2E8B57 },
                { x: 22, z: -22, size: 12, color: 0x3CB371 },
                { x: -22, z: -22, size: 12, color: 0x228B22 },
                { x: 30, z: 0, size: 8, color: 0x32CD32 },
                { x: -30, z: 0, size: 8, color: 0x32CD32 },
                { x: 0, z: 30, size: 8, color: 0x2E8B57 },
                { x: 0, z: -30, size: 8, color: 0x2E8B57 }
            ];
            
            grassPatches.forEach(patch => {
                const patchGeometry = new THREE.CircleGeometry(patch.size, 32);
                const patchMaterial = new THREE.MeshLambertMaterial({ 
                    color: patch.color,
                    side: THREE.DoubleSide
                });
                const patchMesh = new THREE.Mesh(patchGeometry, patchMaterial);
                patchMesh.rotation.x = -Math.PI / 2;
                patchMesh.position.set(patch.x, 0.01, patch.z);
                parkGroup.add(patchMesh);
                
                // Th√™m texture c·ªè t·ª± nhi√™n
                const texturePatches = Math.floor(Math.random() * 3) + 2;
                for (let i = 0; i < texturePatches; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * patch.size * 0.8;
                    const texX = patch.x + Math.cos(angle) * radius;
                    const texZ = patch.z + Math.sin(angle) * radius;
                    
                    const texGeometry = new THREE.CircleGeometry(2 + Math.random() * 2, 16);
                    const texMaterial = new THREE.MeshLambertMaterial({ 
                        color: new THREE.Color().setHSL(0.25, 0.7 + Math.random() * 0.3, 0.3 + Math.random() * 0.2),
                        side: THREE.DoubleSide
                    });
                    const texMesh = new THREE.Mesh(texGeometry, texMaterial);
                    texMesh.rotation.x = -Math.PI / 2;
                    texMesh.position.set(texX, 0.015, texZ);
                    parkGroup.add(texMesh);
                }
            });
            
            // Th√™m c√°c b·ª•i c√¢y nh·ªè r·∫£i r√°c kh·∫Øp c√¥ng vi√™n
            const bushPositions = [];
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 20 + Math.random() * 12;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                // Ki·ªÉm tra kh√¥ng ƒë·∫∑t tr√™n ƒë∆∞·ªùng ƒëi ho·∫∑c h·ªì n∆∞·ªõc
                const distFromCenter = Math.sqrt(x * x + z * z);
                if (distFromCenter > 16 && distFromCenter < 32) {
                    bushPositions.push({ x, z });
                }
            }
            
            bushPositions.forEach(pos => {
                const bushGroup = new THREE.Group();
                
                // B·ª•i c√¢y ch√≠nh
                const bushSize = 0.8 + Math.random() * 0.5;
                const bushGeometry = new THREE.SphereGeometry(bushSize, 12, 12);
                const bushMaterial = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color().setHSL(0.25 + Math.random() * 0.1, 0.8, 0.4),
                    roughness: 0.9
                });
                const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                bush.position.y = bushSize * 0.6;
                bush.scale.y = 0.7;
                bushGroup.add(bush);
                
                // Th√™m l√° nh·ªè xung quanh
                const leafCount = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < leafCount; i++) {
                    const leafAngle = (i / leafCount) * Math.PI * 2;
                    const leafRadius = bushSize * 0.7;
                    const leafSize = 0.3 + Math.random() * 0.2;
                    
                    const leafGeometry = new THREE.SphereGeometry(leafSize, 8, 8);
                    const leafMaterial = new THREE.MeshPhongMaterial({ 
                        color: new THREE.Color().setHSL(0.25 + Math.random() * 0.05, 0.9, 0.35),
                        roughness: 0.95
                    });
                    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                    leaf.position.set(
                        Math.cos(leafAngle) * leafRadius,
                        leafSize * 0.5,
                        Math.sin(leafAngle) * leafRadius
                    );
                    bushGroup.add(leaf);
                }
                
                bushGroup.position.set(pos.x, 0, pos.z);
                parkGroup.add(bushGroup);
            });
            
            // Th√™m hoa ƒë·∫ßy m√†u s·∫Øc trong c√°c khu v·ª±c
            const flowerClusters = [
                { x: 18, z: 10, count: 8 },
                { x: -18, z: 10, count: 8 },
                { x: 18, z: -10, count: 8 },
                { x: -18, z: -10, count: 8 },
                { x: 10, z: 18, count: 6 },
                { x: -10, z: 18, count: 6 },
                { x: 10, z: -18, count: 6 },
                { x: -10, z: -18, count: 6 }
            ];
            
            const flowerColors = [0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0xFFA07A, 0xF7DC6F, 0xFF69B4, 0xDA70D6];
            
            flowerClusters.forEach(cluster => {
                for (let i = 0; i < cluster.count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 3;
                    const flowerX = cluster.x + Math.cos(angle) * radius;
                    const flowerZ = cluster.z + Math.sin(angle) * radius;
                    
                    const flowerGroup = new THREE.Group();
                    
                    // Th√¢n hoa
                    const stemGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 6);
                    const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                    const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                    stem.position.y = 0.3;
                    flowerGroup.add(stem);
                    
                    // ƒê·∫ßu hoa
                    const flowerGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                    const flowerMaterial = new THREE.MeshPhongMaterial({ 
                        color: flowerColors[Math.floor(Math.random() * flowerColors.length)],
                        emissive: 0x111111,
                        emissiveIntensity: 0.2
                    });
                    const flowerHead = new THREE.Mesh(flowerGeometry, flowerMaterial);
                    flowerHead.position.y = 0.6;
                    flowerGroup.add(flowerHead);
                    
                    // C√°nh hoa
                    const petalCount = 5 + Math.floor(Math.random() * 3);
                    for (let j = 0; j < petalCount; j++) {
                        const petalAngle = (j / petalCount) * Math.PI * 2;
                        const petalGeometry = new THREE.SphereGeometry(0.1, 6, 6);
                        const petal = new THREE.Mesh(petalGeometry, flowerMaterial);
                        petal.position.set(
                            Math.cos(petalAngle) * 0.25,
                            0.6,
                            Math.sin(petalAngle) * 0.25
                        );
                        petal.scale.set(1.5, 1, 1);
                        flowerGroup.add(petal);
                    }
                    
                    flowerGroup.position.set(flowerX, 0, flowerZ);
                    flowerGroup.rotation.y = Math.random() * Math.PI * 2;
                    parkGroup.add(flowerGroup);
                }
            });
            
            // B∆Ø·ªöC 2: H·ªì n∆∞·ªõc m·ªü r·ªông v·ªõi nhi·ªÅu t·∫ßng v√† ƒë·∫£o nh·ªè
            const lakeGeometry = new THREE.CylinderGeometry(15, 15, 0.4, 64);
            const lakeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4A90E2,
                transparent: true,
                opacity: 0.85,
                emissive: 0x001122,
                emissiveIntensity: 0.2,
                shininess: 100
            });
            const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
            lake.position.set(0, 0.2, 0);
            lake.userData = { type: 'water_feature' };
            parkGroup.add(lake);
            
            // Th√™m l·ªõp n∆∞·ªõc s√¢u h∆°n ·ªü trung t√¢m
            const deepWaterGeometry = new THREE.CylinderGeometry(8, 8, 0.3, 32);
            const deepWaterMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2C5F8D,
                transparent: true,
                opacity: 0.9,
                emissive: 0x000811,
                emissiveIntensity: 0.3
            });
            const deepWater = new THREE.Mesh(deepWaterGeometry, deepWaterMaterial);
            deepWater.position.set(0, 0.15, 0);
            parkGroup.add(deepWater);
            
            // B∆Ø·ªöC 3: Vi·ªÅn ƒë√° trang tr√≠ ph·ª©c t·∫°p
            const rimGeometry = new THREE.TorusGeometry(15.2, 0.8, 16, 64);
            const rimMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x808080,
                roughness: 0.8,
                metalness: 0.2
            });
            const rim = new THREE.Mesh(rimGeometry, rimMaterial);
            rim.position.set(0, 0.3, 0);
            rim.rotation.x = -Math.PI / 2;
            parkGroup.add(rim);
            
            // Th√™m c√°c ƒë·∫£o nh·ªè trong h·ªì
            const islandPositions = [
                { x: 6, z: 6, size: 2 },
                { x: -6, z: 6, size: 1.5 },
                { x: 6, z: -6, size: 1.8 },
                { x: -6, z: -6, size: 2.2 }
            ];
            
            islandPositions.forEach((island, index) => {
                // ƒê·∫£o nh·ªè
                const islandGeometry = new THREE.CylinderGeometry(island.size, island.size * 0.8, 0.5, 16);
                const islandMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B7355
                });
                const islandMesh = new THREE.Mesh(islandGeometry, islandMaterial);
                islandMesh.position.set(island.x, 0.25, island.z);
                parkGroup.add(islandMesh);
                
                // C·ªè tr√™n ƒë·∫£o
                const grassGeometry = new THREE.CylinderGeometry(island.size * 0.95, island.size * 0.95, 0.1, 16);
                const grassMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x32CD32
                });
                const grassMesh = new THREE.Mesh(grassGeometry, grassMaterial);
                grassMesh.position.set(island.x, 0.55, island.z);
                parkGroup.add(grassMesh);
                
                // C√¢y nh·ªè tr√™n ƒë·∫£o
                if (index % 2 === 0) {
                    const tree = createEnhancedParkTree('small');
                    tree.position.set(island.x, 0.5, island.z);
                    tree.scale.setScalar(0.6);
                    parkGroup.add(tree);
                }
            });
            
            // Th√™m c·∫ßu n·ªëi c√°c ƒë·∫£o
            const bridgeConnections = [
                { from: { x: 0, z: 0 }, to: { x: 6, z: 6 } },
                { from: { x: 0, z: 0 }, to: { x: -6, z: 6 } },
                { from: { x: 0, z: 0 }, to: { x: 6, z: -6 } },
                { from: { x: 0, z: 0 }, to: { x: -6, z: -6 } }
            ];
            
            bridgeConnections.forEach(bridge => {
                const dx = bridge.to.x - bridge.from.x;
                const dz = bridge.to.z - bridge.from.z;
                const length = Math.sqrt(dx * dx + dz * dz);
                const angle = Math.atan2(dz, dx);
                
                // C·∫ßu g·ªó
                const bridgeGeometry = new THREE.BoxGeometry(length, 0.1, 1.5);
                const bridgeMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.9
                });
                const bridgeMesh = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
                bridgeMesh.position.set(
                    (bridge.from.x + bridge.to.x) / 2,
                    0.45,
                    (bridge.from.z + bridge.to.z) / 2
                );
                bridgeMesh.rotation.y = angle;
                parkGroup.add(bridgeMesh);
                
                // Lan can c·∫ßu
                for (let side = -1; side <= 1; side += 2) {
                    const railGeometry = new THREE.BoxGeometry(length, 0.8, 0.05);
                    const railMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x654321,
                        roughness: 0.9
                    });
                    const rail = new THREE.Mesh(railGeometry, railMaterial);
                    rail.position.set(
                        (bridge.from.x + bridge.to.x) / 2,
                        0.85,
                        (bridge.from.z + bridge.to.z) / 2 + side * 0.7
                    );
                    rail.rotation.y = angle;
                    parkGroup.add(rail);
                }
            });
            
            // Th√™m hoa s√∫ng v√† th·ª±c v·∫≠t n∆∞·ªõc
            const lilyPadPositions = [
                { x: 9, z: 3 }, { x: -9, z: 3 }, { x: 9, z: -3 }, { x: -9, z: -3 },
                { x: 3, z: 9 }, { x: -3, z: 9 }, { x: 3, z: -9 }, { x: -3, z: -9 },
                { x: 11, z: 0 }, { x: -11, z: 0 }, { x: 0, z: 11 }, { x: 0, z: -11 }
            ];
            
            lilyPadPositions.forEach(pos => {
                // L√° s√∫ng
                const padGeometry = new THREE.CircleGeometry(0.5, 8);
                const padMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x2E8B57,
                    side: THREE.DoubleSide
                });
                const pad = new THREE.Mesh(padGeometry, padMaterial);
                pad.rotation.x = -Math.PI / 2;
                pad.position.set(pos.x, 0.41, pos.z);
                pad.rotation.y = Math.random() * Math.PI * 2;
                parkGroup.add(pad);
                
                // Hoa s√∫ng (ng·∫´u nhi√™n)
                if (Math.random() > 0.5) {
                    const flowerGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    const flowerMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xFFB6C1,
                        emissive: 0xFF69B4,
                        emissiveIntensity: 0.2
                    });
                    const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                    flower.position.set(pos.x, 0.5, pos.z);
                    parkGroup.add(flower);
                }
            });
            
            // B∆Ø·ªöC 4: ƒê√†i phun n∆∞·ªõc nhi·ªÅu t·∫ßng chi ti·∫øt
            // T·∫ßng ƒë√°y
            const fountainBase = new THREE.Group();
            
            const base1Geometry = new THREE.CylinderGeometry(3, 3.5, 0.8, 32);
            const marbleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xF5F5DC,
                emissive: 0x222222,
                emissiveIntensity: 0.1,
                shininess: 80
            });
            const base1 = new THREE.Mesh(base1Geometry, marbleMaterial);
            base1.position.set(0, 0.4, 0);
            fountainBase.add(base1);
            
            // T·∫ßng gi·ªØa
            const base2Geometry = new THREE.CylinderGeometry(2, 2.5, 1.2, 32);
            const base2 = new THREE.Mesh(base2Geometry, marbleMaterial);
            base2.position.set(0, 1.4, 0);
            fountainBase.add(base2);
            
            // T·∫ßng tr√™n
            const base3Geometry = new THREE.CylinderGeometry(1.5, 2, 1.5, 32);
            const base3 = new THREE.Mesh(base3Geometry, marbleMaterial);
            base3.position.set(0, 2.85, 0);
            fountainBase.add(base3);
            
            // ƒê·ªânh phun n∆∞·ªõc
            const topGeometry = new THREE.ConeGeometry(0.8, 2, 16);
            const topMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF,
                emissive: 0x111111,
                shininess: 100
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.set(0, 4.6, 0);
            fountainBase.add(top);
            
            parkGroup.add(fountainBase);
            
            // B∆Ø·ªöC 5: Hi·ªáu ·ª©ng n∆∞·ªõc phun ph·ª©c t·∫°p
            // T·∫°o nhi·ªÅu lu·ªìng n∆∞·ªõc
            const waterStreams = [];
            
            // Lu·ªìng n∆∞·ªõc ch√≠nh t·ª´ ƒë·ªânh
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const streamGeometry = new THREE.CylinderGeometry(0.1, 0.3, 4, 8);
                const streamMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x87CEEB,
                    transparent: true,
                    opacity: 0.7,
                    emissive: 0x4A90E2,
                    emissiveIntensity: 0.2
                });
                const stream = new THREE.Mesh(streamGeometry, streamMaterial);
                stream.position.set(
                    Math.cos(angle) * 2,
                    4,
                    Math.sin(angle) * 2
                );
                stream.rotation.z = angle * 0.2;
                waterStreams.push(stream);
                parkGroup.add(stream);
            }
            
            // Th√™m c√°c gi·ªçt n∆∞·ªõc nh·ªè
            for (let i = 0; i < 50; i++) {
                const dropGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const dropMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x87CEEB,
                    transparent: true,
                    opacity: 0.6,
                    emissive: 0x4A90E2,
                    emissiveIntensity: 0.1
                });
                const drop = new THREE.Mesh(dropGeometry, dropMaterial);
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 3 + 1;
                drop.position.set(
                    Math.cos(angle) * radius,
                    3 + Math.random() * 3,
                    Math.sin(angle) * radius
                );
                drop.userData = { 
                    type: 'water_drop',
                    velocity: Math.random() * 0.02 + 0.01,
                    angle: angle,
                    radius: radius
                };
                parkGroup.add(drop);
            }
            
            // B∆Ø·ªöC 6: Nhi·ªÅu v√πng c√¢y xanh v·ªõi ƒëa d·∫°ng lo·∫°i c√¢y
            // V√≤ng c√¢y ch√≠nh quanh ƒë√†i phun n∆∞·ªõc (ƒëi·ªÅu ch·ªânh cho h·ªì l·ªõn h∆°n)
            const mainTreePositions = [];
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const radius = 20; // TƒÉng t·ª´ 18 l√™n 20 do h·ªì l·ªõn h∆°n
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                mainTreePositions.push({ x, z, type: 'large' });
            }
            
            // V√≤ng c√¢y ph·ª•
            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2;
                const radius = 28; // TƒÉng t·ª´ 25 l√™n 28 do h·ªì l·ªõn h∆°n
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                mainTreePositions.push({ x, z, type: 'medium' });
            }
            
            mainTreePositions.forEach((pos, index) => {
                const tree = createEnhancedParkTree(pos.type);
                tree.position.set(pos.x, 0, pos.z);
                tree.scale.setScalar(0.8 + Math.random() * 0.4);
                tree.rotation.y = Math.random() * Math.PI * 2;
                parkGroup.add(tree);
            });
            
            // Th√™m nhi·ªÅu khu v∆∞·ªùn nh·ªè
            createGardenAreas(parkGroup);
            
            // Th√™m c√¢y c·ªëi b·ªï sung quanh c√¥ng vi√™n
            plantAdditionalTrees(parkGroup);
            
            // B∆Ø·ªöC 7: H·ªá th·ªëng ƒë∆∞·ªùng ƒëi ho√†n ch·ªânh
            createCompletePathSystem(parkGroup);
            
            // ƒê∆∞·ªùng d·∫´n ch√≠nh t·ª´ 8 h∆∞·ªõng v√†o trung t√¢m (ƒëi·ªÅu ch·ªânh cho h·ªì l·ªõn h∆°n)
            const pathWidth = 2.5;
            const mainPathPositions = [
                { start: { x: -30, z: 0 }, end: { x: -16, z: 0 } },
                { start: { x: 30, z: 0 }, end: { x: 16, z: 0 } },
                { start: { x: 0, z: -30 }, end: { x: 0, z: -16 } },
                { start: { x: 0, z: 30 }, end: { x: 0, z: 16 } },
                // ƒê∆∞·ªùng ch√©o
                { start: { x: -25, z: -25 }, end: { x: -12, z: -12 } },
                { start: { x: 25, z: -25 }, end: { x: 12, z: -12 } },
                { start: { x: -25, z: 25 }, end: { x: -12, z: 12 } },
                { start: { x: 25, z: 25 }, end: { x: 12, z: 12 } }
            ];
            
            mainPathPositions.forEach(path => {
                const dx = path.end.x - path.start.x;
                const dz = path.end.z - path.start.z;
                const length = Math.sqrt(dx * dx + dz * dz);
                const angle = Math.atan2(dz, dx);
                
                // ƒê∆∞·ªùng ch√≠nh v·ªõi vi·ªÅn
                const pathGeometry = new THREE.BoxGeometry(length, 0.1, pathWidth);
                const pathMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xC0C0C0,
                    roughness: 0.8
                });
                const walkway = new THREE.Mesh(pathGeometry, pathMaterial);
                
                walkway.position.set(
                    (path.start.x + path.end.x) / 2,
                    0.05,
                    (path.start.z + path.end.z) / 2
                );
                walkway.rotation.y = angle;
                
                // Th√™m vi·ªÅn ƒë∆∞·ªùng
                const borderGeometry = new THREE.BoxGeometry(length + 0.2, 0.08, pathWidth + 0.4);
                const borderMaterial = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
                const border = new THREE.Mesh(borderGeometry, borderMaterial);
                border.position.copy(walkway.position);
                border.position.y = 0.03;
                border.rotation.y = angle;
                
                parkGroup.add(border);
                parkGroup.add(walkway);
                
                // Th√™m ƒë√®n d·ªçc ƒë∆∞·ªùng
                const numLamps = Math.floor(length / 8);
                for (let i = 1; i < numLamps; i++) {
                    const t = i / numLamps;
                    const lampX = path.start.x + (path.end.x - path.start.x) * t;
                    const lampZ = path.start.z + (path.end.z - path.start.z) * t;
                    const lamp = createPathLamp();
                    lamp.position.set(lampX, 0, lampZ);
                    parkGroup.add(lamp);
                }
            });
            
            // B∆Ø·ªöC 8: Gh·∫ø ng·ªìi - K·∫øt h·ª£p gh·∫ø g·ªó v√† gh·∫ø ƒë√°
            const benchPositions = [
                // Gh·∫ø d·ªçc ƒë∆∞·ªùng tr√≤n ch√≠nh
                { x: 20, z: 8, angle: -Math.PI/2, type: 'wood' }, 
                { x: 20, z: -8, angle: -Math.PI/2, type: 'wood' },
                { x: -20, z: 8, angle: Math.PI/2, type: 'wood' }, 
                { x: -20, z: -8, angle: Math.PI/2, type: 'wood' },
                { x: 8, z: 20, angle: 0, type: 'wood' }, 
                { x: -8, z: 20, angle: 0, type: 'wood' },
                { x: 8, z: -20, angle: Math.PI, type: 'wood' }, 
                { x: -8, z: -20, angle: Math.PI, type: 'wood' },
                // Gh·∫ø ƒë√° cao c·∫•p t·∫°i v·ªã tr√≠ ƒë·∫∑c bi·ªát
                { x: 15, z: 15, angle: -3*Math.PI/4, type: 'stone' }, 
                { x: -15, z: 15, angle: -Math.PI/4, type: 'stone' },
                { x: 15, z: -15, angle: 3*Math.PI/4, type: 'stone' }, 
                { x: -15, z: -15, angle: Math.PI/4, type: 'stone' },
                { x: 20, z: 0, angle: -Math.PI/2, type: 'stone' }, 
                { x: -20, z: 0, angle: Math.PI/2, type: 'stone' },
                { x: 0, z: 20, angle: 0, type: 'stone' }, 
                { x: 0, z: -20, angle: Math.PI, type: 'stone' }
            ];
            
            benchPositions.forEach(pos => {
                const bench = pos.type === 'stone' ? createStoneBench() : createParkBench();
                bench.position.set(pos.x, 0, pos.z);
                bench.rotation.y = pos.angle;
                parkGroup.add(bench);
            });
            
            // Th√™m c√°c ti·ªán √≠ch c√¥ng vi√™n kh√°c
            createParkAmenities(parkGroup);
            
            // Th√™m th√πng r√°c d·ªçc ƒë∆∞·ªùng
            const trashBinPositions = [
                { x: 18, z: 0 }, { x: -18, z: 0 },
                { x: 0, z: 18 }, { x: 0, z: -18 },
                { x: 13, z: 13 }, { x: -13, z: 13 },
                { x: 13, z: -13 }, { x: -13, z: -13 }
            ];
            
            trashBinPositions.forEach(pos => {
                const bin = createTrashBin();
                bin.position.set(pos.x, 0, pos.z);
                parkGroup.add(bin);
            });
            
            // Th√™m bi·ªÉn ch·ªâ d·∫´n
            const signPositions = [
                { x: 30, z: 0, text: "East Garden", rotation: Math.PI/2 },
                { x: -30, z: 0, text: "West Garden", rotation: -Math.PI/2 },
                { x: 0, z: 30, text: "North Plaza", rotation: 0 },
                { x: 0, z: -30, text: "South Gate", rotation: Math.PI }
            ];
            
            signPositions.forEach(sign => {
                const signPost = createDirectionalSign(sign.text);
                signPost.position.set(sign.x, 0, sign.z);
                signPost.rotation.y = sign.rotation;
                parkGroup.add(signPost);
            });
            
            // B∆Ø·ªöC 9: ƒê√®n chi·∫øu s√°ng c√¥ng vi√™n (ƒë√®n ch√≠nh ·ªü xa)
            const outerLightPositions = [
                { x: 10, z: 10 }, { x: -10, z: 10 },
                { x: 10, z: -10 }, { x: -10, z: -10 }
            ];
            
            outerLightPositions.forEach(pos => {
                const lampPost = createParkLamp();
                lampPost.position.set(pos.x, 0, pos.z);
                parkGroup.add(lampPost);
            });
            
            // Th√™m ƒë√®n c√¥ng vi√™n g·∫ßn h·ªì n∆∞·ªõc
            addInnerParkLights(parkGroup);
            
            // ƒê·∫∑t c√¥ng vi√™n ·ªü trung t√¢m
            parkGroup.position.set(0, 0, 0);
            scene.add(parkGroup);
            
            console.log("‚úÖ Central park created with fountain, trees, and walkways");
            console.log("üå± Central park restoration completed with 50x50m green landscape!");
            return parkGroup;
        }

        function createParkTree() {
            const tree = new THREE.Group();
            
            // Th√¢n c√¢y
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 4, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2;
            tree.add(trunk);
            
            // T√°n l√° (3 l·ªõp ƒë·ªÉ t·∫°o ƒë·ªô phong ph√∫)
            const leafColors = [0x228B22, 0x32CD32, 0x90EE90];
            const leafSizes = [2.5, 2, 1.5];
            
            leafColors.forEach((color, index) => {
                const leafGeometry = new THREE.SphereGeometry(leafSizes[index], 8, 8);
                const leafMaterial = new THREE.MeshLambertMaterial({ color: color });
                const leaves = new THREE.Mesh(leafGeometry, leafMaterial);
                leaves.position.y = 4.5 + index * 0.5;
                tree.add(leaves);
            });
            
            return tree;
        }

        function createEnhancedParkTree(type = 'large') {
            const tree = new THREE.Group();
            
            if (type === 'large') {
                // C√¢y l·ªõn v·ªõi th√¢n d√†y
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.6, 5, 12);
                const trunkMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x654321,
                    roughness: 0.9
                });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 2.5;
                tree.add(trunk);
                
                // T√°n l√° d√†y v√† r·ªông
                const leafGroup = new THREE.Group();
                for (let i = 0; i < 5; i++) {
                    const leafGeometry = new THREE.SphereGeometry(3 - i * 0.4, 12, 12);
                    const leafMaterial = new THREE.MeshPhongMaterial({ 
                        color: new THREE.Color().setHSL(0.25, 0.8, 0.3 + i * 0.1),
                        roughness: 0.8
                    });
                    const leaves = new THREE.Mesh(leafGeometry, leafMaterial);
                    leaves.position.y = 6 + i * 0.8;
                    leaves.position.x = (Math.random() - 0.5) * 0.5;
                    leaves.position.z = (Math.random() - 0.5) * 0.5;
                    leafGroup.add(leaves);
                }
                tree.add(leafGroup);
            } else if (type === 'medium') {
                // C√¢y v·ª´a
                const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 4, 10);
                const trunkMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.9
                });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 2;
                tree.add(trunk);
                
                // T√°n l√° h√¨nh n√≥n
                const leafGeometry = new THREE.ConeGeometry(2.5, 4, 12);
                const leafMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x228B22,
                    roughness: 0.7
                });
                const leaves = new THREE.Mesh(leafGeometry, leafMaterial);
                leaves.position.y = 5.5;
                tree.add(leaves);
            } else {
                // C√¢y nh·ªè/c√¢y b·ª•i
                const bushGeometry = new THREE.SphereGeometry(1.5, 10, 10);
                const bushMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x2E8B57,
                    roughness: 0.9
                });
                const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                bush.position.y = 0.8;
                bush.scale.y = 0.6;
                tree.add(bush);
            }
            
            return tree;
        }

        function createGardenAreas(parkGroup) {
            console.log("üå∫ Creating enhanced garden areas with rich variety...");
            
            const gardenPositions = [
                { x: 24, z: 24, radius: 10, theme: 'rose' },
                { x: -24, z: 24, radius: 10, theme: 'tropical' },
                { x: 24, z: -24, radius: 10, theme: 'wildflower' },
                { x: -24, z: -24, radius: 10, theme: 'zen' }
            ];
            
            gardenPositions.forEach(garden => {
                const gardenGroup = new THREE.Group();
                
                // V√πng ƒë·∫•t v∆∞·ªùn v·ªõi vi·ªÅn
                const gardenGeometry = new THREE.CircleGeometry(garden.radius, 32);
                const gardenMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x4B3621,
                    side: THREE.DoubleSide
                });
                const gardenBase = new THREE.Mesh(gardenGeometry, gardenMaterial);
                gardenBase.rotation.x = -Math.PI / 2;
                gardenBase.position.y = 0.02;
                gardenGroup.add(gardenBase);
                
                // Vi·ªÅn v∆∞·ªùn b·∫±ng ƒë√°
                const borderGeometry = new THREE.TorusGeometry(garden.radius, 0.3, 8, 32);
                const borderMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x808080,
                    roughness: 0.9
                });
                const border = new THREE.Mesh(borderGeometry, borderMaterial);
                border.rotation.x = -Math.PI / 2;
                border.position.y = 0.15;
                gardenGroup.add(border);
                
                // T·∫°o theme kh√°c nhau cho m·ªói v∆∞·ªùn
                if (garden.theme === 'rose') {
                    // V∆∞·ªùn hoa h·ªìng
                    const roseColors = [0xFF1493, 0xDC143C, 0xFF69B4, 0xC71585, 0xFFB6C1];
                    for (let i = 0; i < 25; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * (garden.radius - 2) + 1;
                        const roseX = Math.cos(angle) * radius;
                        const roseZ = Math.sin(angle) * radius;
                        
                        const rose = createRose(roseColors[Math.floor(Math.random() * roseColors.length)]);
                        rose.position.set(roseX, 0, roseZ);
                        gardenGroup.add(rose);
                    }
                } else if (garden.theme === 'tropical') {
                    // V∆∞·ªùn nhi·ªát ƒë·ªõi
                    for (let i = 0; i < 15; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * (garden.radius - 2) + 1;
                        const plantX = Math.cos(angle) * radius;
                        const plantZ = Math.sin(angle) * radius;
                        
                        const tropicalPlant = createTropicalPlant();
                        tropicalPlant.position.set(plantX, 0, plantZ);
                        gardenGroup.add(tropicalPlant);
                    }
                } else if (garden.theme === 'wildflower') {
                    // V∆∞·ªùn hoa d·∫°i
                    const wildflowerColors = [0xFFFF00, 0x9370DB, 0x00CED1, 0xFF8C00, 0x32CD32];
                    for (let i = 0; i < 30; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.random() * (garden.radius - 1);
                        const flowerX = Math.cos(angle) * radius;
                        const flowerZ = Math.sin(angle) * radius;
                        
                        const wildflower = createWildflower(wildflowerColors[Math.floor(Math.random() * wildflowerColors.length)]);
                        wildflower.position.set(flowerX, 0, flowerZ);
                        gardenGroup.add(wildflower);
                    }
                } else if (garden.theme === 'zen') {
                    // V∆∞·ªùn Zen v·ªõi ƒë√° v√† c√¢y bonsai
                    // Th√™m c√°t tr·∫Øng
                    const sandGeometry = new THREE.CircleGeometry(garden.radius - 0.5, 32);
                    const sandMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xF5F5DC,
                        side: THREE.DoubleSide
                    });
                    const sand = new THREE.Mesh(sandGeometry, sandMaterial);
                    sand.rotation.x = -Math.PI / 2;
                    sand.position.y = 0.03;
                    gardenGroup.add(sand);
                    
                    // ƒê√° trang tr√≠
                    for (let i = 0; i < 5; i++) {
                        const stoneX = (Math.random() - 0.5) * garden.radius * 1.5;
                        const stoneZ = (Math.random() - 0.5) * garden.radius * 1.5;
                        
                        const stone = createZenStone();
                        stone.position.set(stoneX, 0, stoneZ);
                        gardenGroup.add(stone);
                    }
                    
                    // C√¢y bonsai
                    for (let i = 0; i < 3; i++) {
                        const angle = (i / 3) * Math.PI * 2;
                        const bonsaiX = Math.cos(angle) * (garden.radius * 0.6);
                        const bonsaiZ = Math.sin(angle) * (garden.radius * 0.6);
                        
                        const bonsai = createBonsai();
                        bonsai.position.set(bonsaiX, 0, bonsaiZ);
                        gardenGroup.add(bonsai);
                    }
                }
                
                // Th√™m c√¢y b·ª•i xung quanh m·ªói v∆∞·ªùn
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const bushX = Math.cos(angle) * (garden.radius - 1);
                    const bushZ = Math.sin(angle) * (garden.radius - 1);
                    
                    const bush = createEnhancedParkTree('small');
                    bush.position.set(bushX, 0, bushZ);
                    bush.scale.setScalar(0.6 + Math.random() * 0.3);
                    gardenGroup.add(bush);
                }
                
                gardenGroup.position.set(garden.x, 0, garden.z);
                parkGroup.add(gardenGroup);
            });
            
            console.log("‚úÖ Created 4 themed garden areas: Rose, Tropical, Wildflower, and Zen");
        }
        
        function createRose(color) {
            const rose = new THREE.Group();
            
            // Th√¢n
            const stemGeometry = new THREE.CylinderGeometry(0.08, 0.1, 1.2, 8);
            const stemMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2F4F2F,
                roughness: 0.8
            });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 0.6;
            rose.add(stem);
            
            // Hoa h·ªìng nhi·ªÅu l·ªõp
            for (let layer = 0; layer < 3; layer++) {
                const layerSize = 0.3 + layer * 0.15;
                const petalCount = 5 + layer * 2;
                
                for (let i = 0; i < petalCount; i++) {
                    const angle = (i / petalCount) * Math.PI * 2 + layer * 0.5;
                    const petalGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    const petalMaterial = new THREE.MeshPhongMaterial({ 
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.1
                    });
                    const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                    petal.position.set(
                        Math.cos(angle) * layerSize,
                        1.2 - layer * 0.1,
                        Math.sin(angle) * layerSize
                    );
                    petal.scale.set(1.5, 1, 1);
                    petal.rotation.z = angle;
                    rose.add(petal);
                }
            }
            
            // L√°
            for (let i = 0; i < 3; i++) {
                const leafY = 0.3 + i * 0.25;
                const leafAngle = i * 2.1;
                const leafGeometry = new THREE.SphereGeometry(0.2, 6, 6);
                const leafMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x228B22,
                    roughness: 0.8
                });
                const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                leaf.position.set(
                    Math.cos(leafAngle) * 0.15,
                    leafY,
                    Math.sin(leafAngle) * 0.15
                );
                leaf.scale.set(2, 1, 0.3);
                leaf.rotation.z = leafAngle;
                rose.add(leaf);
            }
            
            return rose;
        }
        
        function createTropicalPlant() {
            const plant = new THREE.Group();
            
            // L√° c·ªç l·ªõn
            const leafCount = 6 + Math.floor(Math.random() * 4);
            for (let i = 0; i < leafCount; i++) {
                const angle = (i / leafCount) * Math.PI * 2;
                const leafLength = 1.5 + Math.random() * 0.5;
                
                const leafGeometry = new THREE.ConeGeometry(0.4, leafLength, 4);
                const leafMaterial = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color().setHSL(0.25, 0.9, 0.35 + Math.random() * 0.1),
                    roughness: 0.7
                });
                const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                leaf.position.set(
                    Math.cos(angle) * 0.3,
                    leafLength / 2,
                    Math.sin(angle) * 0.3
                );
                leaf.rotation.z = angle * 0.3;
                leaf.rotation.x = 0.3;
                plant.add(leaf);
            }
            
            return plant;
        }
        
        function createWildflower(color) {
            const flower = new THREE.Group();
            
            // Th√¢n m·∫£nh
            const stemGeometry = new THREE.CylinderGeometry(0.03, 0.04, 0.8 + Math.random() * 0.4, 6);
            const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = stem.geometry.parameters.height / 2;
            flower.add(stem);
            
            // Hoa ƒë∆°n gi·∫£n
            const flowerSize = 0.2 + Math.random() * 0.15;
            const petalCount = 4 + Math.floor(Math.random() * 4);
            
            for (let i = 0; i < petalCount; i++) {
                const angle = (i / petalCount) * Math.PI * 2;
                const petalGeometry = new THREE.CircleGeometry(flowerSize, 8);
                const petalMaterial = new THREE.MeshPhongMaterial({ 
                    color: color,
                    side: THREE.DoubleSide,
                    emissive: color,
                    emissiveIntensity: 0.2
                });
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                petal.position.set(
                    Math.cos(angle) * flowerSize * 0.7,
                    stem.geometry.parameters.height,
                    Math.sin(angle) * flowerSize * 0.7
                );
                petal.rotation.y = angle;
                petal.rotation.x = -0.3;
                flower.add(petal);
            }
            
            return flower;
        }
        
        function createZenStone() {
            const stone = new THREE.Group();
            
            const stoneGeometry = new THREE.DodecahedronGeometry(0.5 + Math.random() * 0.5, 0);
            const stoneMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x696969,
                roughness: 0.9,
                flatShading: true
            });
            const stoneMesh = new THREE.Mesh(stoneGeometry, stoneMaterial);
            stoneMesh.scale.y = 0.5 + Math.random() * 0.3;
            stoneMesh.position.y = stoneMesh.scale.y * 0.3;
            stoneMesh.rotation.y = Math.random() * Math.PI * 2;
            
            stone.add(stoneMesh);
            return stone;
        }
        
        function createBonsai() {
            const bonsai = new THREE.Group();
            
            // Ch·∫≠u
            const potGeometry = new THREE.CylinderGeometry(0.4, 0.3, 0.3, 12);
            const potMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B4513,
                roughness: 0.8
            });
            const pot = new THREE.Mesh(potGeometry, potMaterial);
            pot.position.y = 0.15;
            bonsai.add(pot);
            
            // Th√¢n c√¢y u·ªën l∆∞·ª£n
            const trunkCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0.3, 0),
                new THREE.Vector3(0.1, 0.5, 0),
                new THREE.Vector3(-0.05, 0.7, 0.05),
                new THREE.Vector3(0.1, 0.9, 0)
            ]);
            
            const trunkGeometry = new THREE.TubeGeometry(trunkCurve, 10, 0.05, 8, false);
            const trunkMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4B3621,
                roughness: 0.9
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            bonsai.add(trunk);
            
            // T√°n l√° nh·ªè
            const foliagePositions = [
                { x: 0.1, y: 0.9, z: 0, size: 0.3 },
                { x: -0.05, y: 0.7, z: 0.05, size: 0.25 },
                { x: 0.15, y: 0.8, z: -0.05, size: 0.2 }
            ];
            
            foliagePositions.forEach(pos => {
                const foliageGeometry = new THREE.SphereGeometry(pos.size, 8, 8);
                const foliageMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x2F4F2F,
                    roughness: 0.8
                });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.set(pos.x, pos.y, pos.z);
                foliage.scale.y = 0.7;
                bonsai.add(foliage);
            });
            
            return bonsai;
        }
        
        function createParkAmenities(parkGroup) {
            console.log("üèõÔ∏è Adding comprehensive park amenities...");
            
            // Th√™m t∆∞·ª£ng ƒë√†i ·ªü 4 g√≥c ch√≠nh
            const monumentPositions = [
                { x: 28, z: 28, type: 'classic' },
                { x: -28, z: 28, type: 'modern' },
                { x: 28, z: -28, type: 'abstract' },
                { x: -28, z: -28, type: 'nature' }
            ];
            
            monumentPositions.forEach(pos => {
                const monument = createMonument(pos.type);
                monument.position.set(pos.x, 0, pos.z);
                parkGroup.add(monument);
            });
            
            // Th√™m khu vui ch∆°i tr·∫ª em
            const playground = createPlayground();
            playground.position.set(32, 0, 0);
            parkGroup.add(playground);
            
            // Th√™m khu t·∫≠p th·ªÉ d·ª•c
            const fitnessArea = createFitnessArea();
            fitnessArea.position.set(-32, 0, 0);
            parkGroup.add(fitnessArea);
            
            // Th√™m khu BBQ/Picnic
            const picnicAreas = [
                { x: 0, z: 32 },
                { x: 0, z: -32 }
            ];
            
            picnicAreas.forEach(pos => {
                const picnicArea = createPicnicArea();
                picnicArea.position.set(pos.x, 0, pos.z);
                parkGroup.add(picnicArea);
            });
            
            // Th√™m k·ªá s√°ch ngo√†i tr·ªùi
            const bookStands = [
                { x: 26, z: 10 },
                { x: -26, z: 10 },
                { x: 26, z: -10 },
                { x: -26, z: -10 }
            ];
            
            bookStands.forEach(pos => {
                const bookStand = createBookStand();
                bookStand.position.set(pos.x, 0, pos.z);
                parkGroup.add(bookStand);
            });
            
            // Th√™m ƒë√†i quan s√°t nh·ªè
            const viewingPlatform = createViewingPlatform();
            viewingPlatform.position.set(0, 0, 0);
            parkGroup.add(viewingPlatform);
            
            console.log("‚úÖ Added monuments, playground, fitness area, picnic areas, book stands, and viewing platform");
        }
        
        function createMonument(type) {
            const monument = new THREE.Group();
            
            // ƒê·∫ø t∆∞·ª£ng
            const baseGeometry = new THREE.CylinderGeometry(2, 2.5, 1, 16);
            const baseMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x808080,
                roughness: 0.8
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.5;
            monument.add(base);
            
            if (type === 'classic') {
                // T∆∞·ª£ng c·ªï ƒëi·ªÉn
                const statueGeometry = new THREE.CylinderGeometry(0.8, 1, 3, 12);
                const statueMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xF5F5DC,
                    roughness: 0.7
                });
                const statue = new THREE.Mesh(statueGeometry, statueMaterial);
                statue.position.y = 2.5;
                monument.add(statue);
            } else if (type === 'modern') {
                // T∆∞·ª£ng hi·ªán ƒë·∫°i
                const modernGeometry = new THREE.BoxGeometry(1.5, 4, 0.5);
                const modernMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x2F4F4F,
                    metalness: 0.6,
                    roughness: 0.4
                });
                const modernStatue = new THREE.Mesh(modernGeometry, modernMaterial);
                modernStatue.position.y = 3;
                modernStatue.rotation.y = Math.PI / 4;
                monument.add(modernStatue);
            } else if (type === 'abstract') {
                // T∆∞·ª£ng tr·ª´u t∆∞·ª£ng
                for (let i = 0; i < 3; i++) {
                    const abstractGeometry = new THREE.SphereGeometry(0.5 + i * 0.2, 8, 8);
                    const abstractMaterial = new THREE.MeshPhongMaterial({ 
                        color: new THREE.Color().setHSL(i * 0.2, 0.8, 0.6),
                        emissive: 0x111111,
                        emissiveIntensity: 0.2
                    });
                    const abstractPart = new THREE.Mesh(abstractGeometry, abstractMaterial);
                    abstractPart.position.set(
                        Math.cos(i * 2) * 0.5,
                        1.5 + i * 0.8,
                        Math.sin(i * 2) * 0.5
                    );
                    monument.add(abstractPart);
                }
            } else if (type === 'nature') {
                // T∆∞·ª£ng t·ª± nhi√™n (c√¢y stylized)
                const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 2.5, 8);
                const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 2.25;
                monument.add(trunk);
                
                const foliageGeometry = new THREE.SphereGeometry(1.2, 12, 12);
                const foliageMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = 3.7;
                monument.add(foliage);
            }
            
            return monument;
        }
        
        function createPlayground() {
            const playground = new THREE.Group();
            
            // N·ªÅn s√¢n ch∆°i
            const groundGeometry = new THREE.CircleGeometry(8, 32);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xF4A460,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0.01;
            playground.add(ground);
            
            // C·∫ßu tr∆∞·ª£t
            const slideBase = new THREE.BoxGeometry(3, 2, 4);
            const slideMaterial = new THREE.MeshPhongMaterial({ color: 0xFF4500 });
            const slide = new THREE.Mesh(slideBase, slideMaterial);
            slide.position.set(-4, 1, 0);
            playground.add(slide);
            
            // X√≠ch ƒëu
            const swingFrame = new THREE.BoxGeometry(0.3, 3, 4);
            const frameMaterial = new THREE.MeshPhongMaterial({ color: 0x4169E1 });
            const frame1 = new THREE.Mesh(swingFrame, frameMaterial);
            frame1.position.set(2, 1.5, -1.5);
            playground.add(frame1);
            
            const frame2 = new THREE.Mesh(swingFrame, frameMaterial);
            frame2.position.set(2, 1.5, 1.5);
            playground.add(frame2);
            
            // Thang leo
            const climbingFrame = new THREE.BoxGeometry(2, 2.5, 2);
            const climbMaterial = new THREE.MeshPhongMaterial({ color: 0x32CD32 });
            const climb = new THREE.Mesh(climbingFrame, climbMaterial);
            climb.position.set(4, 1.25, 0);
            playground.add(climb);
            
            return playground;
        }
        
        function createFitnessArea() {
            const fitness = new THREE.Group();
            
            // N·ªÅn khu t·∫≠p
            const groundGeometry = new THREE.CircleGeometry(6, 32);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2F4F2F,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0.01;
            fitness.add(ground);
            
            // C√°c thi·∫øt b·ªã t·∫≠p th·ªÉ d·ª•c
            const equipmentPositions = [
                { x: -3, z: -3, type: 'pullup' },
                { x: 3, z: -3, type: 'parallel' },
                { x: -3, z: 3, type: 'bench' },
                { x: 3, z: 3, type: 'rings' }
            ];
            
            equipmentPositions.forEach(pos => {
                const equipment = createFitnessEquipment(pos.type);
                equipment.position.set(pos.x, 0, pos.z);
                fitness.add(equipment);
            });
            
            return fitness;
        }
        
        function createFitnessEquipment(type) {
            const equipment = new THREE.Group();
            const metalMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x708090,
                metalness: 0.7,
                roughness: 0.3
            });
            
            if (type === 'pullup') {
                // X√† ƒë∆°n
                const post1 = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 2.5, 8),
                    metalMaterial
                );
                post1.position.set(-1, 1.25, 0);
                equipment.add(post1);
                
                const post2 = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 2.5, 8),
                    metalMaterial
                );
                post2.position.set(1, 1.25, 0);
                equipment.add(post2);
                
                const bar = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 2, 8),
                    metalMaterial
                );
                bar.rotation.z = Math.PI / 2;
                bar.position.y = 2.3;
                equipment.add(bar);
            }
            
            return equipment;
        }
        
        function createPicnicArea() {
            const picnic = new THREE.Group();
            
            // B√†n picnic
            const tableTop = new THREE.BoxGeometry(3, 0.1, 1.5);
            const tableMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const table = new THREE.Mesh(tableTop, tableMaterial);
            table.position.y = 0.8;
            picnic.add(table);
            
            // Ch√¢n b√†n
            const legGeometry = new THREE.BoxGeometry(0.1, 0.8, 0.1);
            const legPositions = [
                { x: -1.3, z: -0.6 }, { x: 1.3, z: -0.6 },
                { x: -1.3, z: 0.6 }, { x: 1.3, z: 0.6 }
            ];
            
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, tableMaterial);
                leg.position.set(pos.x, 0.4, pos.z);
                picnic.add(leg);
            });
            
            // Gh·∫ø d√†i
            const benchGeometry = new THREE.BoxGeometry(3, 0.3, 0.4);
            const bench1 = new THREE.Mesh(benchGeometry, tableMaterial);
            bench1.position.set(0, 0.4, -1.2);
            picnic.add(bench1);
            
            const bench2 = new THREE.Mesh(benchGeometry, tableMaterial);
            bench2.position.set(0, 0.4, 1.2);
            picnic.add(bench2);
            
            return picnic;
        }
        
        function createBookStand() {
            const bookStand = new THREE.Group();
            
            // C·ªôt ƒë·ª°
            const postGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8);
            const postMaterial = new THREE.MeshPhongMaterial({ color: 0x2F4F4F });
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.y = 0.75;
            bookStand.add(post);
            
            // T·ªß s√°ch
            const cabinetGeometry = new THREE.BoxGeometry(1, 1.2, 0.3);
            const cabinetMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const cabinet = new THREE.Mesh(cabinetGeometry, cabinetMaterial);
            cabinet.position.y = 1.5;
            bookStand.add(cabinet);
            
            // M√°i che
            const roofGeometry = new THREE.ConeGeometry(0.8, 0.3, 8);
            const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x654321 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 2.25;
            bookStand.add(roof);
            
            return bookStand;
        }
        
        function createViewingPlatform() {
            const platform = new THREE.Group();
            
            // N·ªÅn s√†n quan s√°t (xung quanh ƒë√†i phun n∆∞·ªõc)
            const radius = 8;
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                const plankGeometry = new THREE.BoxGeometry(2, 0.1, 1);
                const plankMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x8B7355,
                    roughness: 0.9
                });
                const plank = new THREE.Mesh(plankGeometry, plankMaterial);
                plank.position.set(x, 0.55, z);
                plank.rotation.y = angle;
                platform.add(plank);
            }
            
            // Lan can
            for (let i = 0; i < 32; i++) {
                const angle = (i / 32) * Math.PI * 2;
                const x = Math.cos(angle) * (radius + 0.5);
                const z = Math.sin(angle) * (radius + 0.5);
                
                const railGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
                const railMaterial = new THREE.MeshPhongMaterial({ color: 0x2F4F4F });
                const rail = new THREE.Mesh(railGeometry, railMaterial);
                rail.position.set(x, 1.1, z);
                platform.add(rail);
            }
            
            return platform;
        }

        function createFlower() {
            const flower = new THREE.Group();
            
            // Th√¢n hoa
            const stemGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 6);
            const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 0.4;
            flower.add(stem);
            
            // C√°nh hoa
            const petalColors = [0xFF69B4, 0xFFFF00, 0xFF4500, 0xDA70D6, 0xFFFFFF];
            const petalColor = petalColors[Math.floor(Math.random() * petalColors.length)];
            
            for (let i = 0; i < 6; i++) {
                const petalGeometry = new THREE.SphereGeometry(0.15, 6, 6);
                const petalMaterial = new THREE.MeshPhongMaterial({ 
                    color: petalColor,
                    emissive: petalColor,
                    emissiveIntensity: 0.2
                });
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                const angle = (i / 6) * Math.PI * 2;
                petal.position.set(
                    Math.cos(angle) * 0.2,
                    0.8,
                    Math.sin(angle) * 0.2
                );
                petal.scale.set(1.5, 1, 1);
                flower.add(petal);
            }
            
            // Nh·ª•y hoa
            const centerGeometry = new THREE.SphereGeometry(0.1, 6, 6);
            const centerMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
            const center = new THREE.Mesh(centerGeometry, centerMaterial);
            center.position.y = 0.8;
            flower.add(center);
            
            return flower;
        }

        function createCompletePathSystem(parkGroup) {
            console.log("üö∂ Creating comprehensive pathway system...");
            
            // H·ªá th·ªëng ƒë∆∞·ªùng ƒëi to√†n di·ªán v·ªõi nhi·ªÅu l·ªõp
            const mainPathRadius = 18; // ƒê∆∞·ªùng ch√≠nh xung quanh h·ªì
            const outerRadius = 25;    // ƒê∆∞·ªùng v√≤ng ngo√†i
            const innerRadius = 17;    // ƒê∆∞·ªùng v√≤ng trong (g·∫ßn h·ªì)
            
            // ƒê∆Ø·ªúNG CH√çNH H√åNH TR√íN - R·ªông v√† ƒë·∫πp h∆°n
            const pathWidth = 3;
            for (let i = 0; i < 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                const x = Math.cos(angle) * mainPathRadius;
                const z = Math.sin(angle) * mainPathRadius;
                
                // L·ªõp ƒë∆∞·ªùng ch√≠nh
                const pathGeometry = new THREE.PlaneGeometry(pathWidth, 2);
                const pathMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xF5F5DC, // M√†u be s√°ng
                    roughness: 0.85,
                    side: THREE.DoubleSide
                });
                const pathSegment = new THREE.Mesh(pathGeometry, pathMaterial);
                
                pathSegment.rotation.x = -Math.PI / 2;
                pathSegment.rotation.z = angle;
                pathSegment.position.set(x, 0.05, z);
                pathSegment.castShadow = false;
                pathSegment.receiveShadow = true;
                
                parkGroup.add(pathSegment);
                
                // Vi·ªÅn ƒë∆∞·ªùng trang tr√≠
                if (i % 4 === 0) {
                    const borderGeometry = new THREE.PlaneGeometry(pathWidth + 0.5, 0.3);
                    const borderMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x8B7355,
                        roughness: 0.9
                    });
                    const border = new THREE.Mesh(borderGeometry, borderMaterial);
                    border.rotation.x = -Math.PI / 2;
                    border.rotation.z = angle;
                    border.position.set(x, 0.04, z);
                    parkGroup.add(border);
                }
            }
            
            // ƒê∆Ø·ªúNG D·∫™N T·ª™ 4 H∆Ø·ªöNG CH√çNH V√ÄO TRUNG T√ÇM
            const directions = [
                { x: 1, z: 0, name: 'east' },    // ƒê√¥ng
                { x: -1, z: 0, name: 'west' },   // T√¢y
                { x: 0, z: 1, name: 'north' },   // B·∫Øc
                { x: 0, z: -1, name: 'south' }   // Nam
            ];
            
            directions.forEach(dir => {
                // T·∫°o ƒë∆∞·ªùng li√™n t·ª•c t·ª´ ngo√†i v√†o trong
                for (let distance = 35; distance >= 18; distance -= 2) {
                    const segmentGeometry = new THREE.BoxGeometry(3, 0.1, 2.5);
                    const segmentMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xF5F5DC,
                        roughness: 0.85
                    });
                    const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                    
                    segment.position.set(
                        dir.x * distance,
                        0.05,
                        dir.z * distance
                    );
                    
                    if (dir.x !== 0) {
                        segment.rotation.y = Math.PI / 2;
                    }
                    
                    parkGroup.add(segment);
                    
                    // Th√™m vi·ªÅn trang tr√≠ m·ªói 6 ƒë∆°n v·ªã
                    if (distance % 6 === 0) {
                        const decorGeometry = new THREE.BoxGeometry(3.5, 0.08, 3);
                        const decorMaterial = new THREE.MeshPhongMaterial({ 
                            color: 0xD2691E,
                            roughness: 0.9
                        });
                        const decor = new THREE.Mesh(decorGeometry, decorMaterial);
                        decor.position.copy(segment.position);
                        decor.position.y = 0.03;
                        decor.rotation.y = segment.rotation.y;
                        parkGroup.add(decor);
                    }
                }
                
                // K·∫øt n·ªëi v·ªõi ƒë∆∞·ªùng tr√≤n ch√≠nh
                const connectionLength = 3;
                const connectionGeometry = new THREE.BoxGeometry(
                    dir.x !== 0 ? connectionLength : 3,
                    0.1,
                    dir.z !== 0 ? connectionLength : 3
                );
                const connectionMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xE0E0E0,
                    roughness: 0.8
                });
                const connection = new THREE.Mesh(connectionGeometry, connectionMaterial);
                connection.position.set(
                    dir.x * 16.5,
                    0.05,
                    dir.z * 16.5
                );
                parkGroup.add(connection);
            });
            
            // ƒê∆Ø·ªúNG V√íNG NGO√ÄI - ƒê∆∞·ªùng d·∫°o nh·ªè
            for (let i = 0; i < 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                const x = Math.cos(angle) * outerRadius;
                const z = Math.sin(angle) * outerRadius;
                
                const pathGeometry = new THREE.PlaneGeometry(1.5, 1.2);
                const pathMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xD2B48C,
                    roughness: 0.9,
                    side: THREE.DoubleSide
                });
                const pathSegment = new THREE.Mesh(pathGeometry, pathMaterial);
                
                pathSegment.rotation.x = -Math.PI / 2;
                pathSegment.rotation.z = angle;
                pathSegment.position.set(x, 0.02, z);
                
                parkGroup.add(pathSegment);
            }
            
            // V√≤ng trong g·∫ßn h·ªì (g·ªçi h√†m ƒë√£ c√≥)
            createCircularWalkingPath(parkGroup);
            
            // ƒê∆Ø·ªúNG N·ªêI GI·ªÆA C√ÅC V√íNG - 8 h∆∞·ªõng
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                
                // N·ªëi v√≤ng trong v·ªõi v√≤ng ch√≠nh
                const innerConnect = createRadialPath(
                    innerRadius, mainPathRadius, angle, 0xC0C0C0
                );
                parkGroup.add(innerConnect);
                
                // N·ªëi v√≤ng ch√≠nh v·ªõi v√≤ng ngo√†i
                const outerConnect = createRadialPath(
                    mainPathRadius, outerRadius, angle, 0xB0B0B0
                );
                parkGroup.add(outerConnect);
            }
            
            // Th√™m ƒë√®n d·ªçc ƒë∆∞·ªùng ch√≠nh
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const x = Math.cos(angle) * (mainPathRadius + 1.5);
                const z = Math.sin(angle) * (mainPathRadius + 1.5);
                
                const lamp = createPathLamp();
                lamp.position.set(x, 0, z);
                parkGroup.add(lamp);
            }
            
            console.log("‚úÖ Comprehensive pathway system created with main circular path, radial paths, and decorative elements");
        }
        
        function createRadialPath(innerRadius, outerRadius, angle, color) {
            const length = outerRadius - innerRadius;
            const midRadius = (innerRadius + outerRadius) / 2;
            
            const pathGroup = new THREE.Group();
            
            const pathGeometry = new THREE.BoxGeometry(2, 0.1, length);
            const pathMaterial = new THREE.MeshPhongMaterial({ 
                color: color,
                roughness: 0.8
            });
            const path = new THREE.Mesh(pathGeometry, pathMaterial);
            
            path.position.set(
                Math.cos(angle) * midRadius,
                0.05,
                Math.sin(angle) * midRadius
            );
            path.rotation.y = angle + Math.PI / 2;
            
            return path;
        }

        function createPathLamp() {
            const lamp = new THREE.Group();
            
            // C·ªôt ƒë√®n th·∫•p cho ƒë∆∞·ªùng ƒëi
            const poleGeometry = new THREE.CylinderGeometry(0.08, 0.1, 3, 8);
            const poleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x444444,
                metalness: 0.5,
                roughness: 0.5
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 1.5;
            lamp.add(pole);
            
            // ƒê√®n LED hi·ªán ƒë·∫°i
            const lightGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.6);
            const lightMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFFFAA,
                emissive: 0xFFFF00,
                emissiveIntensity: 0.3
            });
            const light = new THREE.Mesh(lightGeometry, lightMaterial);
            light.position.y = 3;
            lamp.add(light);
            
            // √Ånh s√°ng th·ª±c
            const pointLight = new THREE.PointLight(0xFFFFAA, 0.3, 10);
            pointLight.position.y = 3;
            lamp.add(pointLight);
            
            return lamp;
        }
        
        function createTrashBin() {
            const bin = new THREE.Group();
            
            // Th√¢n th√πng r√°c
            const binGeometry = new THREE.CylinderGeometry(0.3, 0.35, 1, 12);
            const binMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2F4F2F,
                roughness: 0.8
            });
            const binBody = new THREE.Mesh(binGeometry, binMaterial);
            binBody.position.y = 0.5;
            bin.add(binBody);
            
            // N·∫Øp th√πng
            const lidGeometry = new THREE.CylinderGeometry(0.35, 0.32, 0.1, 12);
            const lidMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1C1C1C,
                roughness: 0.6
            });
            const lid = new THREE.Mesh(lidGeometry, lidMaterial);
            lid.position.y = 1.05;
            bin.add(lid);
            
            // Bi·ªÉu t∆∞·ª£ng r√°c
            const iconGeometry = new THREE.PlaneGeometry(0.2, 0.2);
            const iconMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,
                side: THREE.DoubleSide
            });
            const icon = new THREE.Mesh(iconGeometry, iconMaterial);
            icon.position.set(0.31, 0.5, 0);
            icon.rotation.y = Math.PI / 2;
            bin.add(icon);
            
            return bin;
        }
        
        function createDirectionalSign(text) {
            const signPost = new THREE.Group();
            
            // C·ªôt bi·ªÉn
            const postGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2.5, 8);
            const postMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4A4A4A,
                roughness: 0.8
            });
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.y = 1.25;
            signPost.add(post);
            
            // B·∫£ng bi·ªÉn
            const signGeometry = new THREE.BoxGeometry(2, 0.8, 0.1);
            const signMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B4513,
                roughness: 0.7
            });
            const signBoard = new THREE.Mesh(signGeometry, signMaterial);
            signBoard.position.y = 2.2;
            signPost.add(signBoard);
            
            // Vi·ªÅn bi·ªÉn
            const frameGeometry = new THREE.BoxGeometry(2.1, 0.9, 0.08);
            const frameMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x654321,
                roughness: 0.8
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.y = 2.2;
            frame.position.z = 0.01;
            signPost.add(frame);
            
            // Text placeholder (trong th·ª±c t·∫ø s·∫Ω d√πng TextGeometry)
            const textBg = new THREE.Mesh(
                new THREE.PlaneGeometry(1.8, 0.6),
                new THREE.MeshBasicMaterial({ 
                    color: 0xFFF8DC,
                    side: THREE.DoubleSide
                })
            );
            textBg.position.y = 2.2;
            textBg.position.z = 0.06;
            signPost.add(textBg);
            
            return signPost;
        }

        function createParkBench() {
            const bench = new THREE.Group();
            
            // Ch√¢n gh·∫ø
            const legGeometry = new THREE.BoxGeometry(0.1, 0.8, 0.1);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            
            const legPositions = [
                { x: -0.8, z: -0.3 }, { x: 0.8, z: -0.3 },
                { x: -0.8, z: 0.3 }, { x: 0.8, z: 0.3 }
            ];
            
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(pos.x, 0.4, pos.z);
                bench.add(leg);
            });
            
            // M·∫∑t gh·∫ø
            const seatGeometry = new THREE.BoxGeometry(1.8, 0.1, 0.6);
            const seatMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const seat = new THREE.Mesh(seatGeometry, seatMaterial);
            seat.position.y = 0.8;
            bench.add(seat);
            
            // T·ª±a l∆∞ng
            const backGeometry = new THREE.BoxGeometry(1.8, 0.6, 0.1);
            const back = new THREE.Mesh(backGeometry, seatMaterial);
            back.position.set(0, 1.1, -0.25);
            bench.add(back);
            
            return bench;
        }
        
        function createStoneBench() {
            const bench = new THREE.Group();
            
            // Gh·∫ø ƒë√° nguy√™n kh·ªëi
            const benchGeometry = new THREE.BoxGeometry(2, 0.4, 0.8);
            const benchMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B7355,
                roughness: 0.9,
                metalness: 0.1
            });
            const benchMesh = new THREE.Mesh(benchGeometry, benchMaterial);
            benchMesh.position.y = 0.4;
            benchMesh.castShadow = true;
            benchMesh.receiveShadow = true;
            bench.add(benchMesh);
            
            // T·ª±a l∆∞ng ƒë√°
            const backGeometry = new THREE.BoxGeometry(2, 0.6, 0.2);
            const backMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x696969,
                roughness: 0.95
            });
            const back = new THREE.Mesh(backGeometry, backMaterial);
            back.position.set(0, 0.7, -0.3);
            bench.add(back);
            
            // Ch√¢n ƒë√°
            const footGeometry = new THREE.BoxGeometry(1.8, 0.3, 0.6);
            const foot = new THREE.Mesh(footGeometry, benchMaterial);
            foot.position.y = 0.15;
            bench.add(foot);
            
            return bench;
        }

        function createParkLamp() {
            const lamp = new THREE.Group();
            
            // C·ªôt ƒë√®n
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.12, 5, 8);
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 2.5;
            lamp.add(pole);
            
            // ƒê·∫ßu ƒë√®n
            const lightHeadGeometry = new THREE.SphereGeometry(0.3, 12, 12);
            const lightHeadMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFACD,
                emissive: 0xFFFACD,
                emissiveIntensity: 0.2
            });
            const lightHead = new THREE.Mesh(lightHeadGeometry, lightHeadMaterial);
            lightHead.position.y = 5.2;
            lamp.add(lightHead);
            
            // √Ånh s√°ng th·ª±c t·∫ø
            const pointLight = new THREE.PointLight(0xFFFACD, 0.5, 15);
            pointLight.position.set(0, 5.2, 0);
            lamp.add(pointLight);
            
            return lamp;
        }

        function createCircularWalkingPath(parkGroup) {
            console.log("üîÑ Creating circular walking path around fountain...");
            
            const pathRadius = 17; // TƒÉng t·ª´ 12 l√™n 17 do h·ªì l·ªõn h∆°n (radius 15)
            const pathWidth = 2;
            
            for (let i = 0; i < 32; i++) {
                const angle = (i / 32) * Math.PI * 2;
                const x = Math.cos(angle) * pathRadius;
                const z = Math.sin(angle) * pathRadius;
                
                const pathGeometry = new THREE.PlaneGeometry(pathWidth, 1);
                const pathMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xE8E8E8,
                    transparent: false
                });
                const pathSegment = new THREE.Mesh(pathGeometry, pathMaterial);
                
                pathSegment.rotation.x = -Math.PI / 2;
                pathSegment.rotation.z = angle;
                pathSegment.position.set(x, 0.02, z);
                pathSegment.userData = { type: 'circular_walkway' };
                
                parkGroup.add(pathSegment);
            }
            
            // Th√™m c·∫ßu nh·ªè n·ªëi ƒë∆∞·ªùng tr√≤n v·ªõi l·ªëi v√†o
            const bridgePositions = [
                { angle: 0, length: 3 },      // B·∫Øc
                { angle: Math.PI, length: 3 }, // Nam  
                { angle: Math.PI / 2, length: 3 }, // ƒê√¥ng
                { angle: -Math.PI / 2, length: 3 }  // T√¢y
            ];
            
            bridgePositions.forEach(bridge => {
                const bridgeX = Math.cos(bridge.angle) * (pathRadius + bridge.length / 2);
                const bridgeZ = Math.sin(bridge.angle) * (pathRadius + bridge.length / 2);
                
                const bridgeGeometry = new THREE.BoxGeometry(pathWidth, 0.05, bridge.length);
                const bridgeMaterial = new THREE.MeshLambertMaterial({ color: 0xE8E8E8 });
                const bridgeSegment = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
                
                bridgeSegment.position.set(bridgeX, 0.025, bridgeZ);
                if (bridge.angle === Math.PI / 2 || bridge.angle === -Math.PI / 2) {
                    bridgeSegment.rotation.y = Math.PI / 2;
                }
                
                parkGroup.add(bridgeSegment);
            });
            
            console.log("‚úÖ Circular walking path created with 32 segments and 4 connecting bridges");
        }

        function plantAdditionalTrees(parkGroup) {
            console.log("üå≤ Planting additional trees around park...");
            
            const additionalTreePositions = [
                { x: 15, z: 5 }, { x: -15, z: 5 }, { x: 15, z: -5 }, { x: -15, z: -5 },
                { x: 10, z: 12 }, { x: -10, z: 12 }, { x: 10, z: -12 }, { x: -10, z: -12 },
                { x: 18, z: 0 }, { x: -18, z: 0 }, { x: 0, z: 18 }, { x: 0, z: -18 },
                // Th√™m m·ªôt s·ªë v·ªã tr√≠ kh√°c ƒë·ªÉ t·∫°o r·ª´ng nh·ªè
                { x: 16, z: 8 }, { x: -16, z: 8 }, { x: 16, z: -8 }, { x: -16, z: -8 },
                { x: 8, z: 16 }, { x: -8, z: 16 }, { x: 8, z: -16 }, { x: -8, z: -16 }
            ];
            
            additionalTreePositions.forEach(pos => {
                // T·∫°o c√¢y v·ªõi k√≠ch th∆∞·ªõc ng·∫´u nhi√™n
                const tree = createParkTree();
                tree.position.set(pos.x, 0, pos.z);
                
                // T·∫°o s·ª± ƒëa d·∫°ng v·ªÅ k√≠ch th∆∞·ªõc (70% - 120%)
                const scale = 0.7 + Math.random() * 0.5;
                tree.scale.setScalar(scale);
                
                // Xoay ng·∫´u nhi√™n ƒë·ªÉ t·∫°o t·ª± nhi√™n
                tree.rotation.y = Math.random() * Math.PI * 2;
                
                tree.userData = { type: 'additional_tree' };
                parkGroup.add(tree);
            });
            
            console.log(`‚úÖ Planted ${additionalTreePositions.length} additional trees`);
        }

        function createSimpleTree(x, z, trunk_height = 2, leaf_size = 2) {
            const treeGroup = new THREE.Group();
            
            // Th√¢n c√¢y ƒë∆°n gi·∫£n
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, trunk_height, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunk_height / 2;
            treeGroup.add(trunk);
            
            // T√°n l√° ƒë∆°n gi·∫£n
            const leavesGeometry = new THREE.SphereGeometry(leaf_size, 12, 12);
            const leavesMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x228B22,
                transparent: false
            });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = trunk_height + leaf_size * 0.5;
            treeGroup.add(leaves);
            
            // ƒê·∫∑t v·ªã tr√≠
            treeGroup.position.set(x, 0, z);
            treeGroup.userData = { type: 'simple_tree' };
            
            return treeGroup;
        }

        function addInnerParkLights(parkGroup) {
            console.log("üí° Adding inner park lights around fountain...");
            
            const innerLightPositions = [
                { x: 6, z: 0 }, { x: -6, z: 0 }, 
                { x: 0, z: 6 }, { x: 0, z: -6 }
            ];
            
            innerLightPositions.forEach(pos => {
                // C·ªôt ƒë√®n th·∫•p h∆°n, ph√π h·ª£p v·ªõi khu v·ª±c g·∫ßn h·ªì
                const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 4, 12);
                const poleMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x666666,
                    metalness: 0.3,
                    roughness: 0.7
                });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.set(pos.x, 2, pos.z);
                pole.castShadow = true;
                
                // ƒê√®n tr√≤n v·ªõi hi·ªáu ·ª©ng ph√°t s√°ng
                const lightGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const lightMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xFFFFAA,
                    emissive: 0x444400,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.9
                });
                const lightBulb = new THREE.Mesh(lightGeometry, lightMaterial);
                lightBulb.position.set(pos.x, 4, pos.z);
                
                // √Ånh s√°ng th·ª±c t·∫ø chi·∫øu xu·ªëng h·ªì
                const spotLight = new THREE.SpotLight(0xFFFFAA, 0.8, 15, Math.PI / 4, 0.3, 1);
                spotLight.position.set(pos.x, 4, pos.z);
                spotLight.target.position.set(0, 0, 0); // H∆∞·ªõng v·ªÅ phun n∆∞·ªõc
                spotLight.castShadow = true;
                
                // C·∫•u h√¨nh shadow
                spotLight.shadow.mapSize.width = 512;
                spotLight.shadow.mapSize.height = 512;
                spotLight.shadow.camera.near = 0.5;
                spotLight.shadow.camera.far = 15;
                
                // Th√™m userData ƒë·ªÉ qu·∫£n l√Ω
                pole.userData = { type: 'inner_park_lighting' };
                lightBulb.userData = { type: 'inner_park_lighting' };
                spotLight.userData = { type: 'inner_park_lighting' };
                
                parkGroup.add(pole);
                parkGroup.add(lightBulb);
                parkGroup.add(spotLight);
                parkGroup.add(spotLight.target);
            });
            
            // Th√™m ƒë√®n LED d∆∞·ªõi n∆∞·ªõc (hi·ªáu ·ª©ng √°nh s√°ng d∆∞·ªõi h·ªì)
            const underwaterLightPositions = [
                { x: 3, z: 3 }, { x: -3, z: 3 },
                { x: 3, z: -3 }, { x: -3, z: -3 },
                { x: 0, z: 0 } // Trung t√¢m d∆∞·ªõi ƒë√†i phun n∆∞·ªõc
            ];
            
            underwaterLightPositions.forEach(pos => {
                const underwaterLight = new THREE.PointLight(0x4A90E2, 0.5, 8);
                underwaterLight.position.set(pos.x, 0.1, pos.z);
                underwaterLight.userData = { type: 'underwater_lighting' };
                parkGroup.add(underwaterLight);
            });
            
            console.log(`‚úÖ Added ${innerLightPositions.length} inner park lights and ${underwaterLightPositions.length} underwater lights`);
        }

        // Create street furniture
        function createStreetFurniture() {
            // Benches throughout the city
            const benchLocations = [
                { x: -30, z: 30 }, { x: 30, z: 30 },
                { x: -30, z: -30 }, { x: 30, z: -30 },
                { x: -70, z: 0 }, { x: 70, z: 0 },
                { x: 0, z: -70 }, { x: 0, z: 70 },
                { x: -130, z: 60 }, { x: 130, z: -60 },
                { x: -60, z: 130 }, { x: 60, z: -130 }
            ];
            
            benchLocations.forEach(loc => {
                const bench = createBench();
                bench.position.set(loc.x, 0, loc.z);
                bench.rotation.y = Math.random() * Math.PI;
                streetFurniture.push(bench);
                scene.add(bench);
            });
        }

        function createBench() {
            const bench = new THREE.Group();
            
            const woodMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
            
            // Seat
            const seat = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.3, 1),
                woodMaterial
            );
            seat.position.y = 1;
            bench.add(seat);
            
            // Back
            const back = new THREE.Mesh(
                new THREE.BoxGeometry(4, 1.2, 0.2),
                woodMaterial
            );
            back.position.set(0, 1.6, -0.4);
            bench.add(back);
            
            return bench;
        }

        // Create infrastructure elements
        function createInfrastructure() {
            // Street lights every 40m
            const streetLightPositions = [];
            
            // Along main roads
            for (let i = -200; i <= 200; i += 40) {
                streetLightPositions.push({ x: -15, z: i });
                streetLightPositions.push({ x: 15, z: i });
                streetLightPositions.push({ x: -105, z: i });
                streetLightPositions.push({ x: 105, z: i });
                
                if (Math.abs(i) > 20) {
                    streetLightPositions.push({ x: i, z: -15 });
                    streetLightPositions.push({ x: i, z: 15 });
                    streetLightPositions.push({ x: i, z: -105 });
                    streetLightPositions.push({ x: i, z: 105 });
                }
            }
            
            streetLightPositions.forEach(pos => {
                const light = createStreetLight();
                light.position.set(pos.x, 0, pos.z);
                lights.push(light);
                scene.add(light);
            });
        }

        function createStreetLight() {
            const streetLight = new THREE.Group();
            
            // Pole
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.2, 8, 8),
                new THREE.MeshPhongMaterial({ color: 0x404040 })
            );
            pole.position.y = 4;
            pole.castShadow = true;
            streetLight.add(pole);
            
            // Light bulb (emissive)
            const bulb = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 8, 8),
                new THREE.MeshLambertMaterial({ 
                    color: 0xffffcc,
                    emissive: 0xffffcc,
                    emissiveIntensity: 0.5
                })
            );
            bulb.position.set(2, 7.3, 0);
            streetLight.add(bulb);
            
            return streetLight;
        }

        // Create water features
        function createWaterFeatures() {
            // Small ponds in parks
            parks.forEach((park, index) => {
                if (index > 0 && index < 4) {
                    const pond = createPond();
                    pond.position.copy(park.position);
                    pond.position.x += 15;
                    pond.position.z += 10;
                    waterFeatures.push(pond);
                    scene.add(pond);
                }
            });
        }

        function createPond() {
            const pond = new THREE.Group();
            
            // Water surface
            const waterGeometry = new THREE.CircleGeometry(8, 32);
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = 0.1;
            pond.add(water);
            
            return pond;
        }

        // Create river flowing from north to south as one continuous shape
        function createRiver() {
            const riverGroup = new THREE.Group();
            
            // Create natural meandering river path using curves
            const riverCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(250, 0, 290),   // North start
                new THREE.Vector3(240, 0, 240),   // Curve left
                new THREE.Vector3(255, 0, 200),   // Curve right
                new THREE.Vector3(245, 0, 160),   // Curve left
                new THREE.Vector3(260, 0, 120),   // Curve right
                new THREE.Vector3(250, 0, 80),    // Center
                new THREE.Vector3(265, 0, 40),    // Curve right
                new THREE.Vector3(245, 0, 0),     // Curve left (city center)
                new THREE.Vector3(260, 0, -40),   // Curve right
                new THREE.Vector3(250, 0, -80),   // Center
                new THREE.Vector3(240, 0, -120),  // Curve left
                new THREE.Vector3(255, 0, -160),  // Curve right
                new THREE.Vector3(245, 0, -200),  // Curve left
                new THREE.Vector3(250, 0, -240),  // Curve right
                new THREE.Vector3(250, 0, -290)   // South end
            ]);

            // Create river material with better depth handling
            const riverMaterial = new THREE.MeshPhongMaterial({
                color: 0x4682b4,
                transparent: true,
                opacity: 0.8,
                shininess: 100,
                side: THREE.DoubleSide,
                depthWrite: true,    // Enable depth writing
                depthTest: true,     // Enable depth testing
                alphaTest: 0.1      // Discard very transparent pixels
            });

            // Get points along the curve for creating river shape
            const riverPoints = riverCurve.getPoints(150);
            
            // Create river shape using custom geometry
            const riverGeometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            const riverWidth = 25;
            
            // Create vertices for both sides of river
            riverPoints.forEach((point, i) => {
                // Calculate perpendicular direction for river width
                let perpDir = new THREE.Vector3(1, 0, 0);
                if (i < riverPoints.length - 1) {
                    const forward = new THREE.Vector3().subVectors(riverPoints[i + 1], point).normalize();
                    perpDir = new THREE.Vector3(-forward.z, 0, forward.x);
                }
                
                // Left bank point
                const leftPoint = new THREE.Vector3()
                    .copy(point)
                    .add(perpDir.clone().multiplyScalar(-riverWidth / 2));
                vertices.push(leftPoint.x, 0.05, leftPoint.z);
                
                // Right bank point  
                const rightPoint = new THREE.Vector3()
                    .copy(point)
                    .add(perpDir.clone().multiplyScalar(riverWidth / 2));
                vertices.push(rightPoint.x, 0.05, rightPoint.z);
            });
            
            // Create triangles to form river surface
            for (let i = 0; i < riverPoints.length - 1; i++) {
                const leftIndex = i * 2;
                const rightIndex = i * 2 + 1;
                const nextLeftIndex = (i + 1) * 2;
                const nextRightIndex = (i + 1) * 2 + 1;
                
                // Two triangles per river segment
                indices.push(leftIndex, nextLeftIndex, rightIndex);
                indices.push(rightIndex, nextLeftIndex, nextRightIndex);
            }
            
            riverGeometry.setFromPoints = function(points) {
                const positions = new Float32Array(points.length * 3);
                for (let i = 0; i < points.length; i++) {
                    positions[i * 3] = points[i].x;
                    positions[i * 3 + 1] = points[i].y;
                    positions[i * 3 + 2] = points[i].z;
                }
                this.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            };
            
            riverGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            riverGeometry.setIndex(indices);
            riverGeometry.computeVertexNormals();
            
            const riverMesh = new THREE.Mesh(riverGeometry, riverMaterial);
            riverMesh.receiveShadow = true;
            riverGroup.add(riverMesh);
            
            // Add trees along the meandering banks
            riverPoints.forEach((point, index) => {
                if (index % 5 === 0) { // Every 5th point
                    // Calculate perpendicular direction for bank positioning
                    let perpDir = new THREE.Vector3(1, 0, 0);
                    if (index < riverPoints.length - 1) {
                        const forward = new THREE.Vector3().subVectors(riverPoints[index + 1], point).normalize();
                        perpDir = new THREE.Vector3(-forward.z, 0, forward.x);
                    }
                    
                    // Trees on both sides of river
                    [-1, 1].forEach(side => {
                        const treePos = new THREE.Vector3()
                            .copy(point)
                            .add(perpDir.clone().multiplyScalar(side * (35 + Math.random() * 10)));
                        
                        const tree = createTree();
                        tree.position.copy(treePos);
                        tree.scale.setScalar(0.8 + Math.random() * 0.4);
                        trees.push(tree);
                        scene.add(tree);
                    });
                }
            });
            
            // Bridges crossing the river (perpendicular to river flow)
            const bridgePositions = [
                { z: 150, x: 248 },   // North bridge
                { z: 50, x: 258 },    // Central north bridge  
                { z: -30, x: 248 },   // Central south bridge
                { z: -130, x: 252 }   // South bridge
            ];
            
            bridgePositions.forEach(bridgePos => {
                const bridge = createBridge();
                bridge.position.set(bridgePos.x, 0, bridgePos.z);
                riverGroup.add(bridge);
            });
            
            // Natural river features
            createRiverFeatures(riverPoints, riverGroup, riverMaterial);
            
            scene.add(riverGroup);
        }
        
        // Create natural river features
        function createRiverFeatures(riverPoints, riverGroup, riverMaterial) {
            // River source (northern end) - natural spring
            const sourceGeometry = new THREE.CircleGeometry(20, 16);
            const riverSource = new THREE.Mesh(sourceGeometry, riverMaterial);
            riverSource.rotation.x = -Math.PI / 2;
            riverSource.position.set(250, 0.05, 290);
            riverGroup.add(riverSource);
            
            // Source vegetation - ring of trees
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const sourceTree = createTree();
                sourceTree.position.set(
                    250 + Math.cos(angle) * 30,
                    0,
                    290 + Math.sin(angle) * 30
                );
                sourceTree.scale.setScalar(1.2);
                trees.push(sourceTree);
                scene.add(sourceTree);
            }
            
            // River mouth/delta (southern end) - wider estuary
            const mouthGeometry = new THREE.CircleGeometry(28, 16);
            const riverMouth = new THREE.Mesh(mouthGeometry, riverMaterial);
            riverMouth.rotation.x = -Math.PI / 2;
            riverMouth.position.set(250, 0.05, -290);
            riverGroup.add(riverMouth);
            
            // Delta vegetation
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const deltaTree = createTree();
                deltaTree.position.set(
                    250 + Math.cos(angle) * 40,
                    0,
                    -290 + Math.sin(angle) * 40
                );
                deltaTree.scale.setScalar(1.0);
                trees.push(deltaTree);
                scene.add(deltaTree);
            }
            
            // Scattered rocks along riverbed
            riverPoints.forEach((point, index) => {
                if (index % 15 === 0 && Math.random() > 0.7) {
                    const rock = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(1 + Math.random() * 2),
                        new THREE.MeshPhongMaterial({ color: 0x696969 })
                    );
                    rock.position.set(
                        point.x + (Math.random() - 0.5) * 12,
                        0.5,
                        point.z + (Math.random() - 0.5) * 8
                    );
                    rock.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    riverGroup.add(rock);
                }
            });
            
            // Small islands at river bends
            const islandPositions = [
                { x: 240, z: 160 },
                { x: 265, z: 40 },
                { x: 240, z: -120 }
            ];
            
            islandPositions.forEach(pos => {
                // Island ground
                const islandGeometry = new THREE.CircleGeometry(10, 12);
                const islandMaterial = new THREE.MeshLambertMaterial({ color: 0x228b22 });
                const island = new THREE.Mesh(islandGeometry, islandMaterial);
                island.rotation.x = -Math.PI / 2;
                island.position.set(pos.x, 0.1, pos.z);
                riverGroup.add(island);
                
                // Trees on island
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const islandTree = createTree();
                    islandTree.position.set(
                        pos.x + Math.cos(angle) * 5,
                        0,
                        pos.z + Math.sin(angle) * 5
                    );
                    islandTree.scale.setScalar(0.7);
                    trees.push(islandTree);
                    scene.add(islandTree);
                }
            });
        }
        
        // Create bridge crossing river (east-west orientation)
        function createBridge() {
            const bridge = new THREE.Group();
            
            // Bridge deck spanning east-west across north-south river
            const deck = new THREE.Mesh(
                new THREE.BoxGeometry(60, 2, 10), // Width spans river, depth is road width
                new THREE.MeshPhongMaterial({ color: 0x8B4513 })
            );
            deck.position.y = 5;
            bridge.add(deck);
            
            // Bridge supports/pillars
            const supportPositions = [-20, -10, 0, 10, 20]; // Along the width
            supportPositions.forEach(x => {
                const support = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.8, 0.8, 8, 8),
                    new THREE.MeshPhongMaterial({ color: 0x696969 })
                );
                support.position.set(x, 1, 0);
                bridge.add(support);
            });
            
            // Bridge railings on north and south sides
            [-5, 5].forEach(side => {
                const railing = new THREE.Mesh(
                    new THREE.BoxGeometry(60, 1.5, 0.3),
                    new THREE.MeshPhongMaterial({ color: 0x2F4F4F })
                );
                railing.position.set(0, 6.25, side);
                bridge.add(railing);
            });
            
            // Bridge approach roads (connecting to main road system)
            [-35, 35].forEach(side => {
                const approach = new THREE.Mesh(
                    new THREE.BoxGeometry(10, 0.2, 10),
                    new THREE.MeshPhongMaterial({ color: 0x2c2c2c })
                );
                approach.position.set(side, 0.1, 0);
                bridge.add(approach);
            });
            
            // Bridge lighting
            for (let x = -25; x <= 25; x += 10) {
                [-5, 5].forEach(side => {
                    const lightPost = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.1, 2, 6),
                        new THREE.MeshPhongMaterial({ color: 0x404040 })
                    );
                    lightPost.position.set(x, 7.5, side);
                    bridge.add(lightPost);
                    
                    const light = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3, 6, 4),
                        new THREE.MeshLambertMaterial({ 
                            color: 0xffffcc,
                            emissive: 0xffffcc,
                            emissiveIntensity: 0.3
                        })
                    );
                    light.position.set(x, 8.5, side);
                    bridge.add(light);
                });
            }
            
            return bridge;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (controls) {
                controls.update();
            }
            
            // Cinematic mode rotation
            if (isCinematicMode) {
                cinematicRotation += 0.003;
                const radius = 180 + Math.sin(cinematicRotation * 0.3) * 50;
                const height = 100 + Math.sin(cinematicRotation * 0.7) * 30;
                
                const x = Math.cos(cinematicRotation) * radius;
                const z = Math.sin(cinematicRotation) * radius;
                const y = height;
                
                const targetX = Math.sin(cinematicRotation * 0.5) * 50;
                const targetZ = Math.cos(cinematicRotation * 0.3) * 50;
                const targetY = Math.sin(cinematicRotation * 0.8) * 10;
                
                camera.position.set(x, y, z);
                controls.target.set(targetX, targetY, targetZ);
                controls.update();
            }
            
            renderer.render(scene, camera);
        }

        // Window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Keyboard controls
        function onKeyDown(event) {
            switch (event.code) {
                case 'Digit1':
                    setCameraView('aerial');
                    break;
                case 'Digit2':
                    setCameraView('street');
                    break;
                case 'Digit3':
                    setCameraView('birdseye');
                    break;
                case 'Digit4':
                    setCameraView('overview');
                    break;
                case 'Digit5':
                    togglePhase('phase1');
                    break;
                case 'Digit6':
                    togglePhase('phase2');
                    break;
                case 'Digit7':
                    togglePhase('phase3');
                    break;
            }
        }

        // Mouse interaction
        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(buildings, true);

            if (intersects.length > 0) {
                let building = intersects[0].object;
                while (building.parent && !building.userData.type) {
                    building = building.parent;
                }
                
                if (building.userData.type) {
                    showBuildingInfo(building.userData);
                }
            }
        }

        function onMouseMove(event) {
            // Update mouse position for hover effects if needed
        }

        function showBuildingInfo(buildingData) {
            const popup = document.getElementById('buildingInfoPopup');
            const icon = document.getElementById('buildingIcon');
            const title = document.getElementById('buildingTitle');
            const type = document.getElementById('buildingType');
            const height = document.getElementById('buildingHeight');
            const floors = document.getElementById('buildingFloors');
            const features = document.getElementById('buildingFeatures');
            const phase = document.getElementById('buildingPhase');

            icon.textContent = buildingTypes[buildingData.type].icon;
            title.textContent = buildingData.name;
            type.textContent = buildingData.name;
            height.textContent = buildingData.height + 'm';
            floors.textContent = buildingData.floors + ' t·∫ßng';
            
            features.innerHTML = '';
            buildingData.features.forEach(feature => {
                const li = document.createElement('li');
                li.textContent = feature;
                features.appendChild(li);
            });
            
            phase.textContent = buildingData.phase.toUpperCase();
            phase.className = `phase-status ${buildingData.phase}`;
            
            popup.classList.add('show');
        }

        function hideBuildingInfo() {
            const popup = document.getElementById('buildingInfoPopup');
            popup.classList.remove('show');
        }

        // Camera view positions and targets
        const cameraViews = {
            aerial: {
                position: { x: 300, y: 400, z: 200 },
                target: { x: 200, y: 0, z: 0 },
                name: 'Aerial View'
            },
            street: {
                position: { x: -50, y: 8, z: 50 },
                target: { x: 50, y: 5, z: -50 },
                name: 'Street View'
            },
            birdseye: {
                position: { x: 200, y: 600, z: 100 },
                target: { x: 200, y: 0, z: 0 },
                name: "Bird's Eye View"
            },
            overview: {
                position: { x: 200, y: 800, z: 100 },
                target: { x: 200, y: 0, z: 0 },
                name: "Complete Overview"
            },
            cinematic: {
                position: { x: 150, y: 100, z: 150 },
                target: { x: 0, y: 0, z: 0 },
                name: 'Cinematic View'
            }
        };

        // Set camera view function
        function setCameraView(viewName) {
            if (isCinematicMode) {
                isCinematicMode = false;
            }
            
            const view = cameraViews[viewName];
            if (!view) return;
            
            // Update button states
            document.querySelectorAll('.camera-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const buttonId = viewName + 'ViewBtn';
            const button = document.getElementById(buttonId);
            if (button) {
                button.classList.add('active');
            }
            
            currentCameraView = viewName;
            
            const targetPos = new THREE.Vector3(view.position.x, view.position.y, view.position.z);
            const targetLookAt = new THREE.Vector3(view.target.x, view.target.y, view.target.z);
            
            if (viewName === 'cinematic') {
                startCinematicMode();
            } else {
                animateCamera(targetPos, targetLookAt);
            }
        }

        function startCinematicMode() {
            isCinematicMode = true;
            cinematicRotation = 0;
        }

        function animateCamera(targetPos, targetLookAt, duration = 2000) {
            if (cameraAnimation) {
                cancelAnimationFrame(cameraAnimation);
            }
            
            const startPos = camera.position.clone();
            const startLookAt = controls.target.clone();
            const startTime = performance.now();
            
            function animate() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                camera.position.lerpVectors(startPos, targetPos, easeProgress);
                
                const currentTarget = new THREE.Vector3().lerpVectors(startLookAt, targetLookAt, easeProgress);
                controls.target.copy(currentTarget);
                controls.update();
                
                if (progress < 1) {
                    cameraAnimation = requestAnimationFrame(animate);
                } else {
                    cameraAnimation = null;
                }
            }
            
            animate();
        }

        // Toggle building phase visibility
        function togglePhase(phaseName) {
            const phase = buildingPhases[phaseName];
            const button = document.getElementById(phaseName + 'Btn');
            
            phase.visible = !phase.visible;
            
            if (phase.visible) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
            
            phase.buildings.forEach(building => {
                if (phase.visible) {
                    building.visible = true;
                    animateBuildingOpacity(building, 0, 1, 500);
                } else {
                    animateBuildingOpacity(building, 1, 0, 500, () => {
                        building.visible = false;
                    });
                }
            });
        }
        
        function animateBuildingOpacity(building, fromOpacity, toOpacity, duration, callback) {
            const startTime = performance.now();
            
            function animate() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const currentOpacity = fromOpacity + (toOpacity - fromOpacity) * progress;
                
                building.traverse(child => {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.transparent = true;
                                mat.opacity = currentOpacity;
                            });
                        } else {
                            child.material.transparent = true;
                            child.material.opacity = currentOpacity;
                        }
                    }
                });
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else if (callback) {
                    callback();
                }
            }
            
            animate();
        }
        
        function showAllPhases() {
            const button = document.getElementById('showAllBtn');
            const allPhases = ['phase1', 'phase2', 'phase3'];
            
            const allVisible = allPhases.every(phase => buildingPhases[phase].visible);
            
            if (allVisible) {
                allPhases.forEach(phaseName => {
                    const phase = buildingPhases[phaseName];
                    const phaseButton = document.getElementById(phaseName + 'Btn');
                    
                    phase.visible = false;
                    phaseButton.classList.remove('active');
                    
                    phase.buildings.forEach(building => {
                        animateBuildingOpacity(building, 1, 0, 500, () => {
                            building.visible = false;
                        });
                    });
                });
                
                button.innerHTML = '<span class="phase-indicator phase-all" style="background: linear-gradient(to right, #4682B4 0%, #FF8C00 50%, #32CD32 100%); width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>SHOW ALL PHASES';
                button.classList.remove('active');
            } else {
                allPhases.forEach(phaseName => {
                    const phase = buildingPhases[phaseName];
                    const phaseButton = document.getElementById(phaseName + 'Btn');
                    
                    if (!phase.visible) {
                        phase.visible = true;
                        phaseButton.classList.add('active');
                        
                        phase.buildings.forEach(building => {
                            building.visible = true;
                            animateBuildingOpacity(building, 0, 1, 500);
                        });
                    }
                });
                
                button.innerHTML = '<span class="phase-indicator phase-all" style="background: linear-gradient(to right, #4682B4 0%, #FF8C00 50%, #32CD32 100%); width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>HIDE ALL PHASES';
                button.classList.add('active');
            }
        }

        // Time of day function
        function setTimeOfDay(time) {
            // Update button states
            document.querySelectorAll('.time-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            event.target.classList.add('active');
            
            switch (time) {
                case 'morning':
                    scene.background = new THREE.Color(0x87CEEB);
                    break;
                case 'noon':
                    scene.background = new THREE.Color(0x87CEEB);
                    break;
                case 'evening':
                    scene.background = new THREE.Color(0xff6b35);
                    break;
                case 'night':
                    scene.background = new THREE.Color(0x191970);
                    break;
            }
        }

        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            buildings.forEach(building => {
                building.traverse(child => {
                    if (child.isMesh) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.wireframe = wireframeMode);
                        } else {
                            child.material.wireframe = wireframeMode;
                        }
                    }
                });
            });
        }

        function toggleLandscapeMode() {
            landscapeMode = !landscapeMode;
            trees.forEach(tree => {
                tree.visible = landscapeMode;
            });
            parks.forEach(park => {
                park.visible = landscapeMode;
            });
        }

        function toggleInfoPanel() {
            const panel = document.getElementById('info-panel');
            const toggleBtn = document.querySelector('.panel-toggle');
            
            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
                toggleBtn.classList.remove('panel-hidden');
                toggleBtn.innerHTML = '‚úñ';
                toggleBtn.title = '·∫®n b·∫£ng th√¥ng tin';
            } else {
                panel.classList.add('hidden');
                toggleBtn.classList.add('panel-hidden');
                toggleBtn.innerHTML = '‚ò∞';
                toggleBtn.title = 'Hi·ªán b·∫£ng th√¥ng tin';
            }
        }

        // Check WebGL support
        function checkWebGLSupport() {
            currentLoadingState = LoadingState.WEBGL_CHECK;
            console.log('üîç Checking WebGL support...');
            
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                
                if (!gl) {
                    console.error('‚ùå WebGL not supported');
                    throw new Error('WebGL kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£');
                }
                
                // Check WebGL capabilities
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                    const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    console.log('‚úÖ WebGL supported - Vendor:', vendor, 'Renderer:', renderer);
                } else {
                    console.log('‚úÖ WebGL supported');
                }
                
                // Clean up
                canvas.remove();
                return true;
                
            } catch (e) {
                console.error('‚ùå WebGL check error:', e);
                return false;
            }
        }

        // Global function references for onclick handlers
        window.setTimeOfDay = setTimeOfDay;
        window.toggleWireframe = toggleWireframe;
        window.toggleLandscapeMode = toggleLandscapeMode;
        window.toggleInfoPanel = toggleInfoPanel;
        window.setCameraView = setCameraView;
        window.togglePhase = togglePhase;
        window.showAllPhases = showAllPhases;
        
        // Initialize popup close button
        document.addEventListener('DOMContentLoaded', () => {
            const popupCloseBtn = document.getElementById('popupCloseBtn');
            if (popupCloseBtn) {
                popupCloseBtn.addEventListener('click', hideBuildingInfo);
            }
            
            document.addEventListener('click', (event) => {
                const popup = document.getElementById('buildingInfoPopup');
                const isClickOnBuilding = event.target.tagName === 'CANVAS';
                const isClickInsidePopup = popup.contains(event.target);
                
                if (!isClickOnBuilding && !isClickInsidePopup && popup.classList.contains('show')) {
                    hideBuildingInfo();
                }
            });
        });

        // H√†m x√≥a v√† x√¢y d·ª±ng l·∫°i parking structure v·ªõi k√≠ch th∆∞·ªõc m·ªõi
        function rebuildParkingStructure() {
            console.log("üóëÔ∏è Removing existing parking structure...");
            
            // B∆Ø·ªöC 1: X√≥a parking structure hi·ªán t·∫°i
            const objectsToRemove = [];
            scene.children.forEach(child => {
                const pos = child.position;
                
                // Ki·ªÉm tra v√πng parking structure (m·ªü r·ªông ƒë·ªÉ ƒë·∫£m b·∫£o x√≥a h·∫øt)
                if (pos.x >= -25 && pos.x <= 5 && 
                    pos.z >= -15 && pos.z <= 15 && 
                    pos.y >= 0 && pos.y <= 20) {
                    
                    // X√≥a t·∫•t c·∫£ elements c·ªßa parking structure
                    if (child.material && 
                        (child.material.color && (
                            child.material.color.getHex() === 0xcccccc || 
                            child.material.color.getHex() === 0x888888 ||
                            child.material.color.getHex() === 0x808080 ||
                            child.material.color.getHex() === 0x2c2c2c ||
                            child.material.color.getHex() === 0x00ff00
                        )) ||
                        (child.userData && (
                            child.userData.type === 'car' ||
                            child.userData.type === 'parking' ||
                            child.userData.type === 'parking_structure'
                        ))) {
                        objectsToRemove.push(child);
                    }
                }
            });
            
            // X√≥a c√°c objects ƒë√£ ƒë√°nh d·∫•u
            objectsToRemove.forEach(obj => {
                scene.remove(obj);
                
                // Dispose geometry v√† material ƒë·ªÉ gi·∫£i ph√≥ng memory
                if (obj.geometry) {
                    obj.geometry.dispose();
                }
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => mat.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
                
                // Dispose children recursively n·∫øu c√≥
                if (obj.children) {
                    obj.children.forEach(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    });
                }
            });
            
            console.log(`üóëÔ∏è Removed ${objectsToRemove.length} parking structure objects`);
            
            // B∆Ø·ªöC 2: X√¢y d·ª±ng l·∫°i parking structure v·ªõi k√≠ch th∆∞·ªõc m·ªõi
            console.log("üèóÔ∏è Rebuilding parking structure with new dimensions...");
            
            // Parking structure removed - ground level only
            
            // Enhanced parking garage removed - ground level only
            
            console.log("‚úÖ Parking structure rebuilt successfully with 1/4 original size!");
            console.log("üìè New dimensions applied:", {
                main: `${PARKING_STRUCTURE.width}√ó${PARKING_STRUCTURE.depth}`,
                enhanced: "40√ó30",
                smart: "25√ó20"
            });
        }

        // ‚úÖ CRITICAL MISSING FUNCTION: debugLoading
        function debugLoading() {
            console.log('üîç DEBUG LOADING STATE:');
            console.log('  - currentLoadingState:', typeof currentLoadingState !== 'undefined' ? currentLoadingState : 'UNDEFINED');
            console.log('  - isLoading:', typeof isLoading !== 'undefined' ? isLoading : 'UNDEFINED');
            console.log('  - THREE.js loaded:', typeof THREE !== 'undefined');
            console.log('  - scene defined:', typeof scene !== 'undefined');
            console.log('  - camera defined:', typeof camera !== 'undefined');
            console.log('  - renderer defined:', typeof renderer !== 'undefined');
            
            // Check for loading screen elements
            const loadingElements = document.querySelectorAll('[id*="loading"], [class*="loading"]');
            console.log('  - Loading elements found:', loadingElements.length);
            loadingElements.forEach((el, i) => {
                console.log(`    ${i + 1}. ${el.tagName}#${el.id || 'no-id'}.${el.className} - visible: ${el.offsetParent !== null}`);
            });
            
            // Ki·ªÉm tra xem 3D scene c√≥ th·ª±c s·ª± ho·∫°t ƒë·ªông kh√¥ng
            console.log('\nüîç === KI·ªÇM TRA 3D SCENE CHI TI·∫æT ===');
            console.log("S·ªë canvas elements:", document.querySelectorAll('canvas').length);
            console.log("THREE object:", window.THREE ? "ƒë√£ t·∫£i" : "thi·∫øu");
            console.log("Scene ƒë√£ kh·ªüi t·∫°o:", window.scene ? "c√≥" : "kh√¥ng");
            console.log("Camera ƒë√£ kh·ªüi t·∫°o:", window.camera ? "c√≥" : "kh√¥ng"); 
            console.log("Renderer ƒë√£ kh·ªüi t·∫°o:", window.renderer ? "c√≥" : "kh√¥ng");
            
            // Ki·ªÉm tra chi ti·∫øt scene
            if (window.scene) {
                console.log("  - S·ªë objects trong scene:", window.scene.children.length);
                console.log("  - Scene background:", window.scene.background);
            }
            
            // Ki·ªÉm tra canvas container
            const container = document.getElementById('canvas-container');
            console.log("Canvas container:", container ? "t·ªìn t·∫°i" : "thi·∫øu");
            if (container) {
                console.log("  - Container children:", container.children.length);
                console.log("  - Container display:", window.getComputedStyle(container).display);
            }
            
            // Ki·ªÉm tra animate function
            console.log("Animate function:", typeof animate === 'function' ? "c√≥" : "kh√¥ng");
            console.log("Animation ID:", typeof animationId !== 'undefined' ? animationId : "kh√¥ng c√≥");
            console.log('üîç === K·∫æT TH√öC KI·ªÇM TRA ===\n');
        }
        
        // ‚úÖ CRITICAL MISSING FUNCTION: ensureSceneCreation
        function ensureSceneCreation() {
            console.log('üîç Checking 3D components...');
            console.log('  - window.scene:', typeof window.scene !== 'undefined' ? 'EXISTS' : 'MISSING');
            console.log('  - window.renderer:', typeof window.renderer !== 'undefined' ? 'EXISTS' : 'MISSING');
            console.log('  - window.camera:', typeof window.camera !== 'undefined' ? 'EXISTS' : 'MISSING');
            
            if (!window.scene || !window.renderer || !window.camera) {
                console.log('üî• Creating missing 3D components...');
                
                // Check if THREE.js is loaded
                if (typeof THREE === 'undefined') {
                    console.error('‚ùå Cannot create scene - THREE.js not loaded!');
                    return false;
                }
                
                // Force scene creation by calling init
                if (typeof init === 'function') {
                    console.log('üöÄ Calling init() to create scene...');
                    init();
                } else if (typeof initScene === 'function') {
                    console.log('üöÄ Calling initScene() to create scene...');
                    initScene();
                } else {
                    console.error('‚ùå No init function found!');
                    
                    // Emergency scene creation
                    try {
                        console.log('üö® Emergency scene creation...');
                        if (!window.scene) {
                            window.scene = new THREE.Scene();
                            window.scene.background = new THREE.Color(0x87CEEB);
                        }
                        if (!window.camera) {
                            window.camera = new THREE.PerspectiveCamera(
                                75,
                                window.innerWidth / window.innerHeight,
                                0.1,
                                2000
                            );
                            window.camera.position.set(100, 100, 100);
                        }
                        if (!window.renderer) {
                            window.renderer = new THREE.WebGLRenderer({ antialias: true });
                            window.renderer.setSize(window.innerWidth, window.innerHeight);
                            const container = document.getElementById('canvas-container');
                            if (container) {
                                container.appendChild(window.renderer.domElement);
                            }
                        }
                        console.log('‚úÖ Emergency scene creation completed');
                        return true;
                    } catch (error) {
                        console.error('‚ùå Emergency scene creation failed:', error);
                        return false;
                    }
                }
                return true;
            }
            
            console.log('‚úÖ All 3D components already exist');
            return true;
        }
        
        // Ensure global access to critical functions
        window.debugLoading = debugLoading;
        window.forceHideLoading = forceHideLoading;
        window.toggleInfoPanel = toggleInfoPanel;
        window.ensureSceneCreation = ensureSceneCreation;
        window.ensureSceneInitialization = ensureSceneInitialization;
        window.ensureCanvasInDOM = ensureCanvasInDOM;
        window.createEmergencyScene = createEmergencyScene;
        window.createFallbackScene = createFallbackScene;

        // üö® CRITICAL FIX: Define missing LoadingState object with try-catch protection
        try {
            // Check if LoadingState already exists
            if (typeof window.LoadingState === 'undefined') {
                window.LoadingState = {
                    INITIAL: 'initial',
                    WEBGL_CHECK: 'webgl_check',
                    THREE_INIT: 'three_init',
                    SCENE_CREATE: 'scene_create',
                    ASSETS_LOADING: 'assets_loading',
                    RENDER_START: 'render_start',
                    COMPLETE: 'complete',
                    ERROR: 'error',
                    isHidden: false,
                    timeouts: [],
                    forceHide: function() {
                        try {
                            const loadingElements = document.querySelectorAll('[id*="loading"], [class*="loading"], .loading-screen');
                            loadingElements.forEach(el => {
                                el.style.display = 'none';
                                el.style.opacity = '0';
                                el.style.visibility = 'hidden';
                                el.remove();
                            });
                            this.isHidden = true;
                            console.log("‚úÖ LoadingState: Force hide completed");
                        } catch (hideError) {
                            console.warn("LoadingState.forceHide error:", hideError);
                            // Fallback: simple removal
                            document.querySelectorAll('[id*="loading"]').forEach(el => el.remove());
                        }
                    }
                };
                
                console.log("‚úÖ LoadingState object created successfully");
            } else {
                console.log("‚ÑπÔ∏è LoadingState already exists");
            }
        } catch (e) {
            console.warn("LoadingState initialization failed:", e);
            // Emergency fallback LoadingState
            window.LoadingState = {
                COMPLETE: 'complete',
                forceHide: () => {
                    try {
                        document.querySelectorAll('[id*="loading"]').forEach(el => el.remove());
                    } catch (err) {
                        console.error("Emergency LoadingState.forceHide failed:", err);
                    }
                }
            };
        }
        
        // Initialize loading state variables if they don't exist
        if (typeof currentLoadingState === 'undefined') {
            window.currentLoadingState = window.LoadingState ? window.LoadingState.INITIAL : 'initial';
        }
        if (typeof isLoading === 'undefined') {
            window.isLoading = true;
        }
        if (typeof loadingTimeout === 'undefined') {
            window.loadingTimeout = null;
        }
        if (typeof loadingPhaseTimeouts === 'undefined') {
            window.loadingPhaseTimeouts = {};
        }

        // ULTIMATE: Force remove loading screen with multiple aggressive strategies
        function forceHideLoading() {
            console.log('üö® ULTIMATE FORCE HIDE - Multiple strategies triggered');
            
            // Update state immediately
            currentLoadingState = window.LoadingState ? window.LoadingState.COMPLETE : 'complete';
            isLoading = false;
            
            // Clear all timeouts
            clearTimeout(loadingTimeout);
            Object.values(loadingPhaseTimeouts).forEach(timeout => clearTimeout(timeout));
            loadingPhaseTimeouts = {};
            
            // Strategy 1: CSS display none for all loading-related elements
            const loadingElements = document.querySelectorAll('[id*="loading"], [class*="loading"], .loading-screen');
            console.log('üéØ Found', loadingElements.length, 'loading elements');
            loadingElements.forEach(el => {
                el.style.display = 'none';
                el.style.opacity = '0';
                el.style.visibility = 'hidden';
                el.style.pointerEvents = 'none';
                el.remove(); // Complete removal
            });
            
            // Strategy 2: Remove by content (Vietnamese loading text)
            document.querySelectorAll('*').forEach(el => {
                if (el.textContent && (el.textContent.includes('ƒêang t·∫£i') || 
                    el.textContent.includes('WebGL') || 
                    el.textContent.includes('Enhanced Smart City') ||
                    el.textContent.includes('Kh·ªüi t·∫°o'))) {
                    el.style.display = 'none';
                    console.log('üóëÔ∏è Removed loading element by content:', el.textContent.substring(0, 50));
                }
            });
            
            // Strategy 3: Direct element removal by ID
            const directIds = ['loading-screen', 'loading-progress', 'loading-content', 'loading-spinner'];
            directIds.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.remove();
                    console.log('üóëÔ∏è Direct removal of:', id);
                }
            });
            
            // Strategy 4: Force show body content and hide anything with high z-index
            document.body.style.display = 'block';
            document.body.style.visibility = 'visible';
            document.body.style.opacity = '1';
            
            document.querySelectorAll('*').forEach(el => {
                const zIndex = window.getComputedStyle(el).zIndex;
                if (zIndex && parseInt(zIndex) > 1000) {
                    const bgColor = window.getComputedStyle(el).backgroundColor;
                    if (bgColor.includes('rgb(30, 60, 114)') || bgColor.includes('rgb(42, 82, 152)')) {
                        el.remove();
                        console.log('üóëÔ∏è Removed high z-index loading element');
                    }
                }
            });
            
            console.log('üéØ Ultimate force hide complete - Loading time was:', Date.now() - loadingStartTime, 'ms');
            
            // üî• CRITICAL: Ensure 3D scene initialization after loading removal
            setTimeout(() => {
                console.log('üöÄ Attempting to initialize 3D scene after loading removal...');
                ensureSceneInitialization();
            }, 100);
        }
        
        // üî• CRITICAL: Ensure canvas appears in DOM
        function ensureCanvasInDOM() {
            console.log("üéØ Ensuring canvas is appended to DOM...");
            
            // First, ensure canvas container exists and is visible
            let container = document.getElementById('canvas-container');
            if (!container) {
                console.log("üîß Creating missing canvas-container...");
                container = document.createElement('div');
                container.id = 'canvas-container';
                document.body.appendChild(container);
            }
            
            if (container) {
                console.log("üì¶ Ensuring canvas container is visible...");
                container.style.display = 'block';
                container.style.width = '100%';
                container.style.height = '100vh';
                container.style.position = 'relative';
                container.style.overflow = 'hidden';
                container.style.backgroundColor = 'transparent';
                container.style.margin = '0';
                container.style.padding = '0';
                console.log("‚úÖ Canvas container styled:", {
                    display: container.style.display,
                    width: container.style.width,
                    height: container.style.height,
                    position: container.style.position,
                    exists: document.contains(container)
                });
            }
            
            if (window.renderer && window.renderer.domElement) {
                const targetContainer = container || document.body;
                
                // Clear any existing canvas
                const existingCanvas = targetContainer.querySelector('canvas');
                if (existingCanvas) {
                    console.log("üóëÔ∏è Removing existing canvas");
                    existingCanvas.remove();
                }
                
                // Append new canvas
                targetContainer.appendChild(window.renderer.domElement);
                
                // Force canvas styles
                window.renderer.domElement.style.width = '100%';
                window.renderer.domElement.style.height = '100vh';
                window.renderer.domElement.style.display = 'block';
                window.renderer.domElement.style.position = 'absolute';
                window.renderer.domElement.style.top = '0';
                window.renderer.domElement.style.left = '0';
                window.renderer.domElement.style.zIndex = '1';
                window.renderer.domElement.style.visibility = 'visible';
                window.renderer.domElement.style.opacity = '1';
                
                // Immediate verification
                const immediateCheck = document.querySelectorAll('canvas').length;
                console.log(`üîç Immediate canvas count after append: ${immediateCheck}`);
                
                console.log("‚úÖ Canvas manually appended to DOM");
                console.log("  - Container:", targetContainer.tagName + (targetContainer.id ? '#' + targetContainer.id : ''));
                console.log("  - Canvas size:", window.renderer.domElement.width, 'x', window.renderer.domElement.height);
                console.log("  - Canvas in DOM:", document.contains(window.renderer.domElement));
                
                // Add verification check after canvas append
                setTimeout(() => {
                    const canvasCount = document.querySelectorAll('canvas').length;
                    const canvas = document.querySelector('canvas');
                    const canvasVisible = canvas?.offsetWidth > 0;
                    const canvasHeight = canvas?.offsetHeight > 0;
                    const canvasDisplay = canvas ? window.getComputedStyle(canvas).display : 'none';
                    const canvasOpacity = canvas ? window.getComputedStyle(canvas).opacity : '0';
                    
                    console.log(`üîç Canvas verification after 1s:`);
                    console.log(`  - Count: ${canvasCount} found`);
                    console.log(`  - Visible (width > 0): ${canvasVisible}`);
                    console.log(`  - Visible (height > 0): ${canvasHeight}`);
                    console.log(`  - Display style: ${canvasDisplay}`);
                    console.log(`  - Opacity: ${canvasOpacity}`);
                    console.log(`  - Dimensions: ${canvas?.offsetWidth || 0}x${canvas?.offsetHeight || 0}`);
                    
                    if (canvasCount === 0) {
                        console.error("üö® CRITICAL: Canvas still not in DOM!");
                        console.log("üîß Attempting emergency canvas creation...");
                        if (typeof createFallbackScene === 'function') {
                            createFallbackScene();
                        }
                    } else if (!canvasVisible || !canvasHeight) {
                        console.warn("‚ö†Ô∏è Canvas exists but not visible - checking styles...");
                        if (canvas) {
                            // Force visibility styles
                            canvas.style.display = 'block';
                            canvas.style.visibility = 'visible';
                            canvas.style.opacity = '1';
                            canvas.style.width = '100%';
                            canvas.style.height = '100vh';
                            console.log("üîß Forced canvas visibility styles");
                        }
                    } else {
                        console.log("‚úÖ Canvas is visible and properly sized");
                    }
                }, 1000);
                
                return true;
            } else {
                console.warn("‚ö†Ô∏è No renderer or domElement found for canvas append");
                return false;
            }
        }

        // üéØ COMPREHENSIVE SCENE INITIALIZATION
        function ensureSceneInitialization() {
            console.log("üî• Starting 3D scene initialization...");
            
            try {
                // Create canvas if missing
                let canvas = document.querySelector('canvas');
                if (!canvas) {
                    console.log("üì¶ Creating canvas element...");
                    const container = document.getElementById('canvas-container');
                    if (container) {
                        canvas = document.createElement('canvas');
                        canvas.style.width = '100%';
                        canvas.style.height = '100%';
                        container.appendChild(canvas);
                    } else {
                        canvas = document.createElement('canvas');
                        canvas.style.width = '100%';
                        canvas.style.height = '100vh';
                        canvas.style.position = 'fixed';
                        canvas.style.top = '0';
                        canvas.style.left = '0';
                        canvas.style.zIndex = '1';
                        document.body.appendChild(canvas);
                    }
                    console.log("‚úÖ Canvas created");
                }
                
                // Initialize Three.js scene
                if (!window.scene || !window.camera || !window.renderer) {
                    console.log("üöÄ Initializing Three.js components...");
                    
                    if (typeof init === 'function') {
                        console.log("üìû Calling init()...");
                        init();
                    } else if (typeof initScene === 'function') {
                        console.log("üìû Calling initScene()...");
                        initScene();
                    } else {
                        console.log("üö® No init function found, creating emergency scene...");
                        createEmergencyScene();
                    }
                }
                
                // üéØ CRITICAL: Ensure canvas is in DOM after initialization
                setTimeout(() => {
                    if (!ensureCanvasInDOM()) {
                        console.log("üö® Canvas not in DOM, creating fallback...");
                        createFallbackScene();
                    }
                }, 500);
                
                // Update LoadingState if available
                if (window.LoadingState && typeof window.LoadingState.complete === 'function') {
                    window.LoadingState.complete();
                }
                
                // Start animation if not running
                if (typeof animate === 'function' && !window.animationId) {
                    console.log("üé¨ Starting animation loop...");
                    animate();
                }
                
                console.log("‚úÖ Scene initialization complete");
                
            } catch (error) {
                console.error("üö® Scene initialization failed:", error);
                createFallbackScene();
            }
        }
        
        // üö® EMERGENCY SCENE CREATION
        function createEmergencyScene() {
            console.log("üö® Creating emergency 3D scene...");
            
            try {
                // Ensure THREE.js is loaded
                if (typeof THREE === 'undefined') {
                    console.error("‚ùå THREE.js not loaded!");
                    return;
                }
                
                // Create scene
                window.scene = new THREE.Scene();
                window.scene.background = new THREE.Color(0x87CEEB);
                
                // Create camera
                window.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    2000
                );
                window.camera.position.set(100, 100, 100);
                window.camera.lookAt(0, 0, 0);
                
                // Create renderer
                const canvas = document.querySelector('canvas');
                window.renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas,
                    antialias: true 
                });
                window.renderer.setSize(window.innerWidth, window.innerHeight);
                window.renderer.shadowMap.enabled = true;
                
                // Add basic lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                // Add a simple ground plane
                const groundGeometry = new THREE.PlaneGeometry(500, 500);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                scene.add(ground);
                
                // Add a test cube
                const cubeGeometry = new THREE.BoxGeometry(20, 20, 20);
                const cubeMaterial = new THREE.MeshPhongMaterial({ color: 0x4169E1 });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cube.position.y = 10;
                cube.castShadow = true;
                scene.add(cube);
                
                // Add controls if available
                if (typeof THREE.OrbitControls !== 'undefined') {
                    window.controls = new THREE.OrbitControls(camera, renderer.domElement);
                    window.controls.enableDamping = true;
                    window.controls.dampingFactor = 0.05;
                }
                
                console.log("‚úÖ Emergency scene created successfully");
                
                // Ensure canvas is in DOM
                setTimeout(() => {
                    ensureCanvasInDOM();
                }, 100);
                
                // Start rendering
                function emergencyAnimate() {
                    requestAnimationFrame(emergencyAnimate);
                    
                    if (window.controls) {
                        window.controls.update();
                    }
                    
                    // Rotate the cube
                    if (cube) {
                        cube.rotation.x += 0.01;
                        cube.rotation.y += 0.01;
                    }
                    
                    window.renderer.render(window.scene, window.camera);
                }
                
                emergencyAnimate();
                
            } catch (error) {
                console.error("‚ùå Emergency scene creation failed:", error);
            }
        }
        
        // üõ°Ô∏è FALLBACK SCENE (Simple Three.js scene)
        function createFallbackScene() {
            console.log("üõ°Ô∏è Creating fallback 3D scene...");
            
            try {
                // Check if THREE.js is available
                if (typeof THREE === 'undefined') {
                    console.error("‚ùå THREE.js not available for fallback scene");
                    // Show message instead
                    document.body.style.background = 'linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #87CEEB 100%)';
                    const message = document.createElement('div');
                    message.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: white;
                        font-size: 24px;
                        text-align: center;
                        font-family: Arial, sans-serif;
                        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
                    `;
                    message.innerHTML = '‚ö†Ô∏è Three.js not loaded<br><small>Please refresh the page</small>';
                    document.body.appendChild(message);
                    return;
                }
                
                // Clear any existing canvas
                const existingCanvas = document.querySelector('canvas');
                if (existingCanvas) {
                    existingCanvas.remove();
                }
                
                // Create new canvas
                const canvas = document.createElement('canvas');
                canvas.style.width = '100%';
                canvas.style.height = '100vh';
                canvas.style.position = 'fixed';
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.style.zIndex = '1';
                document.body.appendChild(canvas);
                
                // Create renderer
                const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                // Create scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); // Sky blue
                
                // Create camera
                const camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                camera.position.set(0, 2, 5);
                camera.lookAt(0, 0, 0);
                
                // Add lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                scene.add(directionalLight);
                
                // Add ground
                const groundGeometry = new THREE.PlaneGeometry(50, 50);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 }); // Light green
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -0.5;
                scene.add(ground);
                
                // Add basic geometry to show scene is working
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 }); // Green cube
                const cube = new THREE.Mesh(geometry, material);
                cube.position.y = 0.5;
                scene.add(cube);
                
                // Add text to show it's fallback
                const textDiv = document.createElement('div');
                textDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 20px;
                    color: white;
                    font-family: Arial, sans-serif;
                    font-size: 16px;
                    background: rgba(0,0,0,0.5);
                    padding: 10px;
                    border-radius: 5px;
                    z-index: 1000;
                `;
                textDiv.innerHTML = 'üõ°Ô∏è Fallback 3D Scene Active<br><small>Main scene failed to load</small>';
                document.body.appendChild(textDiv);
                
                // Handle window resize
                function handleResize() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
                window.addEventListener('resize', handleResize);
                
                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    
                    // Rotate the cube
                    cube.rotation.x += 0.01;
                    cube.rotation.y += 0.01;
                    
                    renderer.render(scene, camera);
                }
                
                animate();
                
                // Store references globally for debugging
                window.fallbackScene = scene;
                window.fallbackCamera = camera;
                window.fallbackRenderer = renderer;
                
                console.log("‚úÖ Fallback scene created successfully");
                console.log("  - Canvas created and attached");
                console.log("  - Renderer initialized");
                console.log("  - Scene with cube and ground created");
                console.log("  - Animation loop started");
                
            } catch (error) {
                console.error("‚ùå Fallback scene creation failed:", error);
                // Last resort: just show colored background
                document.body.style.background = 'linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #87CEEB 100%)';
            }
        }

        // ‚úÖ IMMEDIATE ACCESS: Make critical functions available right away
        console.log('üîß SETUP: Making critical functions globally accessible...');
        
        // ‚ö° ULTRA-QUICK: First attempt after just 1 second
        setTimeout(() => {
            const loadingEl = document.getElementById('loading-screen');
            if (loadingEl && loadingEl.style.display !== 'none') {
                console.log("‚ö° 1-second check: Loading screen still visible, waiting...");
            }
        }, 1000);
        
        // ‚ö° QUICK HIDE: Force hide loading after 2 seconds regardless
        setTimeout(() => {
            const loadingEl = document.getElementById('loading-screen');
            if (loadingEl) {
                loadingEl.style.display = 'none';
                console.log("‚è∞ Loading force-hidden by 2-second timeout");
            }
        }, 2000);
        
        // ‚ö° EMERGENCY BACKUP: Ensure loading screen is hidden after 8 seconds no matter what
        setTimeout(() => {
            console.log('üö® EMERGENCY TIMEOUT: Force hiding loading after 8 seconds');
            if (typeof forceHideLoading === 'function') {
                forceHideLoading();
            } else {
                // Ultra-basic fallback
                document.querySelectorAll('[id*="loading"], [class*="loading"]')
                    .forEach(el => el.style.display = 'none');
                console.log('üõ°Ô∏è Emergency fallback loading removal completed');
            }
        }, 8000);
        
        // üî• SCENE CREATION CHECK: Ensure scene exists after 3 seconds
        setTimeout(() => {
            console.log('üî• CHECKING SCENE CREATION after 3 seconds...');
            if (typeof ensureSceneCreation === 'function') {
                ensureSceneCreation();
            }
        }, 3000);
        
        // üö® URGENT: Enhanced initialization with CRITICAL debugging
        window.addEventListener('DOMContentLoaded', async () => {
            console.log('üöÄ PROFESSIONAL: DOMContentLoaded - Starting LoadingManager system');
            
            // Call debug function immediately to check state
            if (typeof debugLoading === 'function') {
                debugLoading();
            }
            
            // Initialize professional LoadingManager
            loadingManager = new LoadingManager();
            
            // Start the managed initialization process
            try {
                await loadingManager.initialize();
                console.log('üéâ LoadingManager initialization completed successfully');
            } catch (managerError) {
                console.error('üö® LoadingManager failed:', managerError);
                loadingManager.forceComplete();
            }
            
            // Legacy debug info for comparison
            console.log('üìä Debug: THREE.js available?', typeof THREE !== 'undefined');
            console.log('üìä Debug: Document state:', document.readyState);
            
            // CRITICAL: Check for Three.js IMMEDIATELY
            if (typeof THREE === 'undefined') {
                console.error('üö® CRITICAL ERROR: Three.js not loaded!');
                setTimeout(() => {
                    if (typeof THREE === 'undefined') {
                        console.error('üö® Three.js still not loaded after 2 seconds, force hiding loading');
                        emergencyHideLoading();
                    }
                }, 2000);
                return;
            }
            
            // IMMEDIATE fallback - hide after 3 seconds maximum
            setTimeout(() => {
                console.warn('‚è∞ 3-second CRITICAL fallback triggered');
                emergencyHideLoading();
            }, 3000);
            
            // SUPER AGGRESSIVE - 1 second fallback
            setTimeout(() => {
                console.warn('‚ö° 1-second SUPER AGGRESSIVE fallback');
                forceHideLoading();
            }, 1000);
            
            // Add emergency timeout to prevent infinite loading
            const emergencyTimeout = setTimeout(() => {
                console.error('üö® EMERGENCY TIMEOUT: Loading failed after 30 seconds');
                const loadingScreen = document.getElementById('loading-screen');
                const loadingProgress = document.getElementById('loading-progress');
                if (loadingProgress) {
                    loadingProgress.innerHTML = '<div style="color: #ff6b6b; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; margin-top: 20px;">‚ùå Loading timeout - Vui l√≤ng refresh trang ƒë·ªÉ th·ª≠ l·∫°i</div>';
                }
            }, 30000); // 30 second emergency timeout
            
            try {
                console.log('üîÑ Starting initializeLoading...');
                initializeLoading();
                console.log('‚úÖ initializeLoading completed');
                
                // Clear emergency timeout if loading succeeds
                const originalHideLoading = window.hideLoadingScreen;
                window.hideLoadingScreen = function() {
                    clearTimeout(emergencyTimeout);
                    if (originalHideLoading) originalHideLoading();
                };
                
            } catch (error) {
                clearTimeout(emergencyTimeout);
                console.error('üö® CRITICAL initialization error:', error);
                console.error('üö® Error stack:', error.stack);
                console.error('üö® Error name:', error.name);
                console.error('üö® Error message:', error.message);
                emergencyHideLoading();
                showError('üö® Critical loading error: ' + error.message);
            }
            
            if (!checkWebGLSupport()) {
                showError('Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ WebGL. Vui l√≤ng s·ª≠ d·ª•ng tr√¨nh duy·ªát hi·ªán ƒë·∫°i.');
                return;
            }
            
            if (typeof THREE === 'undefined') {
                showError('Kh√¥ng th·ªÉ t·∫£i Three.js. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi internet.');
                return;
            }
            
            // Start initialization with comprehensive error handling
            console.log('üîÑ Starting init() function...');
            try {
                await init();
                console.log('‚úÖ init() completed successfully');
            } catch (initError) {
                console.error('üö® INIT FUNCTION ERROR:', initError);
                console.error('üö® Init error stack:', initError.stack);
                emergencyHideLoading();
                showError('üö® 3D initialization failed: ' + initError.message);
            }
            
            // Rebuild parking structure after scene is initialized
            setTimeout(() => {
                if (scene) {
                    rebuildParkingStructure();
                }
            }, 3000); // Wait 3 seconds for scene to fully load
        });
    </script>
</body>
</html>