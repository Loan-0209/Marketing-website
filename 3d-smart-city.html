<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Smart City - HEART Technology Park</title>
    <meta name="description" content="Explore HEART Technology Park in immersive 3D - Vietnam's premier AI innovation hub">
    
    <!-- CSS Files - Optional, won't break 3D functionality -->
    <link rel="stylesheet" href="css/main.css" onerror="this.remove()">
    <link rel="stylesheet" href="css/components.css" onerror="this.remove()">
    <link rel="stylesheet" href="css/animations.css" onerror="this.remove()">
    <link rel="stylesheet" href="css/responsive.css" onerror="this.remove()">
    
    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    
    <!-- 3D Smart City Specific Styles -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #87CEEB 100%);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: relative;
            margin: 0;
            padding: 0;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s ease;
        }

        .loading-content {
            text-align: center;
            color: white;
        }

        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top: 4px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .loading-progress {
            font-size: 14px;
            opacity: 0.8;
            margin-top: 10px;
        }

        /* Website header integration - styles will come from main.css */

        /* Responsive adjustments for 3D controls */
        @media (max-width: 768px) {
            #controls {
                top: 80px;
                right: 10px;
                padding: 15px;
            }
            
            #info-panel {
                top: 80px;
                left: 10px;
                max-width: 280px;
                padding: 15px;
            }
            
            .panel-toggle.panel-hidden {
                top: 85px;
                left: 5px;
            }
            
            .camera-btn {
                font-size: 11px;
                padding: 8px 12px;
            }
            
            .phase-btn {
                font-size: 11px;
                padding: 8px 12px;
            }
            
            .phase-legend {
                font-size: 10px;
            }
        }

        #canvas-container {
            position: relative;
            width: 100vw;
            height: calc(100vh - 80px);
            margin-top: 80px;
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        #controls {
            position: absolute;
            top: 75px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 6px;
            background: rgba(255, 255, 255, 0.85);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(8px);
            min-width: 160px;
            max-width: 180px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .control-group h3 {
            font-size: 11px;
            font-weight: 600;
            color: #333;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 4px;
            padding-bottom: 2px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .control-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 6px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.25);
            margin: 2px 0;
            line-height: 1.2;
        }

        .control-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        }

        .control-btn.active {
            background: #10b981;
            box-shadow: 0 2px 10px rgba(16, 185, 129, 0.3);
        }

        .control-btn.time-btn {
            background: #8b5cf6;
        }

        .control-btn.time-btn:hover {
            background: #7c3aed;
        }

        .control-btn.time-btn.active {
            background: #f59e0b;
        }

        .camera-btn {
            background: #8b5cf6;
            color: white;
            border: none;
            padding: 6px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.25);
            margin: 2px 0;
            width: 100%;
            display: flex;
            align-items: center;
            gap: 4px;
            line-height: 1.2;
        }

        .camera-btn:hover {
            background: #7c3aed;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
        }

        .camera-btn.active {
            background: #ec4899;
            box-shadow: 0 2px 10px rgba(236, 72, 153, 0.3);
        }

        .camera-btn.active:hover {
            background: #db2777;
        }

        .camera-controls {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .camera-controls h3 {
            font-size: 11px;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
            padding-bottom: 2px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .phase-btn {
            background: #475569;
            color: white;
            border: none;
            padding: 6px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 2px 8px rgba(71, 85, 105, 0.25);
            margin: 2px 0;
            width: 100%;
            display: flex;
            align-items: center;
            gap: 4px;
            line-height: 1.2;
        }

        .phase-btn:hover {
            background: #334155;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(71, 85, 105, 0.4);
        }

        .phase-btn.active {
            box-shadow: 0 2px 10px rgba(16, 185, 129, 0.3);
        }

        .phase-btn.phase1 {
            background: #4682b4;
            box-shadow: 0 2px 10px rgba(70, 130, 180, 0.3);
        }

        .phase-btn.phase1:hover {
            background: #36648b;
        }

        .phase-btn.phase1.active {
            background: #10b981;
        }

        .phase-btn.phase2 {
            background: #ff8c00;
            box-shadow: 0 2px 10px rgba(255, 140, 0, 0.3);
        }

        .phase-btn.phase2:hover {
            background: #e07b00;
        }

        .phase-btn.phase2.active {
            background: #10b981;
        }

        .phase-btn.phase3 {
            background: #32cd32;
            box-shadow: 0 2px 10px rgba(50, 205, 50, 0.3);
        }

        .phase-btn.phase3:hover {
            background: #228b22;
        }

        .phase-btn.phase3.active {
            background: #10b981;
        }

        .phase-controls {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .phase-controls h3 {
            font-size: 11px;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
            padding-bottom: 2px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .phase-legend {
            margin-top: 6px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
            font-size: 9px;
        }

        .phase-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 2px 0;
        }

        .phase-color {
            width: 8px;
            height: 8px;
            border-radius: 2px;
        }

        .phase-color.completed {
            background: #4682b4;
        }

        .phase-color.construction {
            background: #ff8c00;
        }

        .phase-color.planned {
            background: #32cd32;
            opacity: 0.7;
        }

        #info-panel {
            position: absolute;
            top: 90px;
            left: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border-radius: 12px;
            padding: 20px;
            max-width: 320px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        #info-panel.hidden {
            transform: translateX(-100%);
            opacity: 0;
            pointer-events: none;
        }

        .panel-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: rgba(59, 130, 246, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 10px rgba(59, 130, 246, 0.3);
            z-index: 101;
            backdrop-filter: blur(5px);
            user-select: none;
        }

        .panel-toggle:hover {
            background: rgba(59, 130, 246, 1);
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        }

        .panel-toggle.panel-hidden {
            position: fixed;
            top: 100px;
            left: 10px;
            background: rgba(59, 130, 246, 0.9);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
            animation: pulse-glow 2s infinite;
        }

        .panel-toggle.panel-hidden:hover {
            left: 15px;
            background: rgba(59, 130, 246, 1);
            animation: none;
        }

        @keyframes pulse-glow {
            0% {
                box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
            }
            50% {
                box-shadow: 0 4px 20px rgba(59, 130, 246, 0.6), 0 0 10px rgba(59, 130, 246, 0.3);
            }
            100% {
                box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
            }
        }

        #info-panel h2 {
            color: #1e40af;
            font-size: 24px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding-right: 40px;
        }

        #info-panel h3 {
            color: #3b82f6;
            font-size: 16px;
            margin-top: 15px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #info-panel ul {
            list-style: none;
            padding-left: 0;
        }

        #info-panel li {
            padding: 4px 0;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #building-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            border-radius: 8px;
            padding: 15px;
            max-width: 300px;
            display: none;
            backdrop-filter: blur(10px);
        }


        .error-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10000;
        }

        .error-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
        }

        .error-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .error-title {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .error-message {
            font-size: 18px;
            opacity: 0.9;
            line-height: 1.6;
        }

        .icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-right: 4px;
        }
        
        /* Building Info Popup Styles */
        .building-info-popup {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(120%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            width: 320px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .building-info-popup.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        .popup-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            background: linear-gradient(135deg, #4c63d2 0%, #6c7ff2 100%);
            color: white;
            border-radius: 12px 12px 0 0;
        }
        
        .building-icon {
            font-size: 24px;
        }
        
        .building-title {
            flex: 1;
            font-size: 16px;
            font-weight: 600;
        }
        
        .popup-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s ease;
        }
        
        .popup-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .popup-content {
            padding: 15px;
        }
        
        .info-row {
            display: flex;
            margin-bottom: 12px;
            align-items: flex-start;
        }
        
        .info-row:last-child {
            margin-bottom: 0;
        }
        
        .info-label {
            font-weight: 600;
            color: #333;
            min-width: 80px;
            font-size: 13px;
        }
        
        .info-value {
            color: #666;
            font-size: 13px;
            flex: 1;
        }
        
        .features-list {
            list-style: none;
            padding: 0;
            margin: 0;
            color: #666;
            font-size: 12px;
        }
        
        .features-list li {
            padding: 2px 0;
            padding-left: 15px;
            position: relative;
        }
        
        .features-list li:before {
            content: "•";
            position: absolute;
            left: 0;
            color: #4c63d2;
        }
        
        .phase-status {
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            display: inline-block;
        }
        
        .phase-status.phase1 {
            background: rgba(70, 130, 180, 0.2);
            color: #4682B4;
        }
        
        .phase-status.phase2 {
            background: rgba(255, 140, 0, 0.2);
            color: #FF8C00;
        }
        
        .phase-status.phase3 {
            background: rgba(50, 205, 50, 0.2);
            color: #32CD32;
        }
        
        /* Mobile responsive */
        @media (max-width: 640px) {
            .building-info-popup {
                width: 90%;
                max-width: 320px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <h2 class="loading-text">Đang tải Enhanced Smart City...</h2>
            <p class="loading-progress" id="loading-progress">Khởi tạo WebGL...</p>
        </div>
    </div>

    <!-- Error Screen -->
    <div class="error-screen" id="error-screen">
        <div class="error-content">
            <div class="error-icon">⚠️</div>
            <h1 class="error-title">Lỗi Tải Smart City</h1>
            <p class="error-message" id="error-message">
                Không thể tải mô hình 3D. Vui lòng làm mới trang và thử lại.
            </p>
        </div>
    </div>

    <!-- Header -->
    <!-- Website Header -->
    <header class="header">
        <div class="header-container">
            <a href="index.html" class="logo">HEART</a>
            <nav class="nav">
                <a href="index.html">Home</a>
                <a href="about.html">About Us</a>
                <a href="master-plan.html">Master Plan</a>
                <a href="3d-smart-city.html" class="active">3D Smart City</a>
                <a href="facilities.html">Facilities</a>
                <a href="investment.html">Investment</a>
                <a href="technology.html">Technology</a>
                <a href="news.html">News</a>
                <a href="contact.html" class="contact-btn">Contact</a>
            </nav>
        </div>
    </header>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Information Panel -->
    <div id="info-panel">
        <button class="panel-toggle" onclick="toggleInfoPanel()" title="Ẩn/Hiện bảng thông tin">
            ✖
        </button>
        <h2>🏙️ Enhanced Smart City</h2>
        <p>Thành phố thông minh với cơ sở hạ tầng cảnh quan hoàn chỉnh</p>
        
        <h3>🏭 Khu Datacenter Complex:</h3>
        <ul>
            <li>✅ Data Center 01 - 100MW (22 HA)</li>
            <li>✅ Data Center 02 - 100MW (20 HA)</li>
            <li>✅ Data Center 03 - 100MW (17 HA)</li>
            <li>✅ Trạm biến áp 500KV</li>
            <li>🏗️ Nền công nghiệp chuyên biệt</li>
            <li>🛡️ Foundation pads cho từng tòa nhà</li>
            <li>⚠️ Security perimeter markings</li>
            <li>🌊 Hệ thống sông uốn lượn (chính + nhánh vùng hoang dã)</li>
            <li>🌊 Sông chính chảy Bắc-Nam với 3 đảo nhỏ</li>
            <li>🌊 Nhánh sông phụ chảy qua vùng hoang dã phía Đông</li>
            <li>🏞️ Hồ tản nhiệt 100m + 4 ao hoang dã</li>
            <li>🌉 9 cầu (3 chính + 6 vùng hoang dã): xe cộ & đi bộ</li>
            <li>💧 4 thác nước lớn trong vùng hoang dã</li>
            <li>🌿 4 khu đất ngập nước tự nhiên</li>
        </ul>
        
        <h3>🌳 Tính năng cảnh quan:</h3>
        <ul>
            <li>✅ Công viên trung tâm 200x150m</li>
            <li>✅ 5 công viên nhỏ với sân chơi</li>
            <li>✅ 60+ cây xanh đô thị</li>
            <li>✅ Bãi đỗ xe 3 tầng</li>
            <li>✅ 4 bãi đỗ xe bề mặt</li>
            <li>✅ Đồ nội thất đường phố</li>
            <li>✅ Hệ thống đèn đường</li>
            <li>✅ 4 trạm sạc xe điện</li>
            <li>✅ Đài phun nước & hồ nước</li>
            <li>✅ Lối đi bộ & cơ sở hạ tầng</li>
        </ul>

        <h3>🎮 Điều khiển:</h3>
        <ul>
            <li>🖱️ Kéo chuột: Xoay camera</li>
            <li>🔍 Cuộn: Thu phóng</li>
            <li>👆 Click: Xem thông tin tòa nhà</li>
        </ul>
        
        <h3>⌨️ Phim tắt:</h3>
        <ul>
            <li>1-5: Camera Views</li>
            <li>6: Toggle Phase 1</li>
            <li>7: Toggle Phase 2</li>
            <li>8: Toggle Phase 3</li>
        </ul>
    </div>

    <!-- Controls -->
    <div id="controls">
        <div class="control-group">
            <h3>🕐 Thời gian trong ngày</h3>
            <button class="control-btn time-btn active" onclick="setTimeOfDay('morning')">Buổi sáng</button>
            <button class="control-btn time-btn" onclick="setTimeOfDay('noon')">Buổi trưa</button>
            <button class="control-btn time-btn" onclick="setTimeOfDay('evening')">Buổi chiều</button>
            <button class="control-btn time-btn" onclick="setTimeOfDay('night')">Buổi tối</button>
        </div>
        
        <div class="control-group">
            <h3>🎨 Chế độ hiển thị</h3>
            <button class="control-btn" onclick="toggleWireframe()">Khung dây</button>
            <button class="control-btn" onclick="toggleLandscapeMode()">Cảnh quan</button>
        </div>
        
        <div class="control-group camera-controls">
            <h3>📹 Camera Views</h3>
            <button class="camera-btn" id="aerialViewBtn" onclick="setCameraView('aerial')">🚁 Aerial View</button>
            <button class="camera-btn" id="streetViewBtn" onclick="setCameraView('street')">🚶 Street View</button>
            <button class="camera-btn" id="birdsEyeBtn" onclick="setCameraView('birdseye')">🦅 Bird's Eye</button>
            <button class="camera-btn" id="cinematicBtn" onclick="setCameraView('cinematic')">🎬 Cinematic</button>
            <button class="camera-btn" id="datacenterBtn" onclick="setCameraView('datacenter')">🏭 Datacenter</button>
        </div>
        
        <div class="control-group phase-controls">
            <div style="font-weight: bold; margin: 10px 0 8px 0; color: #2c3e50; font-size: 11px;">🏗️ Master Plan Phases</div>
            <button class="phase-btn phase1 active" id="phase1Btn" data-phase="1" onclick="togglePhase('phase1')">
                <span class="phase-indicator phase-1" style="background: #4682B4; width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>
                PHASE 1 - HEART CORE
            </button>
            <button class="phase-btn phase2 active" id="phase2Btn" data-phase="2" onclick="togglePhase('phase2')">
                <span class="phase-indicator phase-2" style="background: #FF8C00; width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>
                PHASE 2 - TECHNOLOGY HUB
            </button>
            <button class="phase-btn phase3 active" id="phase3Btn" data-phase="3" onclick="togglePhase('phase3')">
                <span class="phase-indicator phase-3" style="background: #32CD32; width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>
                PHASE 3 - INNOVATION DISTRICT
            </button>
            <button class="phase-btn" id="showAllBtn" onclick="showAllPhases()">
                <span class="phase-indicator phase-all" style="background: linear-gradient(to right, #4682B4 0%, #FF8C00 50%, #32CD32 100%); width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>
                SHOW ALL PHASES
            </button>
            
            <div class="phase-legend">
                <div class="phase-legend-item">
                    <div class="phase-color completed"></div>
                    <span>HEART CORE (Lõi HEART)</span>
                </div>
                <div class="phase-legend-item">
                    <div class="phase-color construction"></div>
                    <span>TECHNOLOGY HUB (Trung tâm Công nghệ)</span>
                </div>
                <div class="phase-legend-item">
                    <div class="phase-color planned"></div>
                    <span>INNOVATION DISTRICT (Khu Đổi mới)</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Building Info Popup -->
    <div class="building-info-popup" id="buildingInfoPopup">
        <div class="popup-header">
            <span class="building-icon" id="buildingIcon">🏢</span>
            <span class="building-title" id="buildingTitle">Building Information</span>
            <button class="popup-close" id="popupCloseBtn">✖</button>
        </div>
        <div class="popup-content">
            <div class="info-row">
                <span class="info-label">Loại:</span>
                <span class="info-value" id="buildingType">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Chiều cao:</span>
                <span class="info-value" id="buildingHeight">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Số tầng:</span>
                <span class="info-value" id="buildingFloors">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Tính năng:</span>
                <ul class="features-list" id="buildingFeatures"></ul>
            </div>
            <div class="info-row">
                <span class="info-label">Trạng thái:</span>
                <span class="info-value phase-status" id="buildingPhase">-</span>
            </div>
        </div>
    </div>


    <!-- Three.js và Main Script -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" 
            crossorigin="anonymous"
            onerror="console.error('Failed to load Three.js from primary CDN'); 
                     var script = document.createElement('script');
                     script.src = 'https://unpkg.com/three@0.128.0/build/three.min.js';
                     script.crossOrigin = 'anonymous';
                     document.head.appendChild(script);"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"
            crossorigin="anonymous"
            onerror="console.error('Failed to load OrbitControls from primary CDN');
                     var script = document.createElement('script');
                     script.src = 'https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js';
                     script.crossOrigin = 'anonymous';
                     document.head.appendChild(script);"></script>
    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let buildings = [];
        let trees = [];
        let parks = [];
        let parkingLots = [];
        let streetFurniture = [];
        let vehicles = [];
        let waterFeatures = [];
        let lights = [];
        let timeOfDay = 'morning';
        let wireframeMode = false;
        let landscapeMode = false;
        let raycaster, mouse;
        let selectedObject = null;
        let loadingTimeout;
        let isLoading = true;
        
        // Camera animation variables
        let currentCameraView = null;
        let cameraAnimation = null;
        let cinematicRotation = 0;
        let isCinematicMode = false;
        
        // Building phase system
        let buildingPhases = {
            phase1: { visible: true, buildings: [] },
            phase2: { visible: true, buildings: [] },
            phase3: { visible: true, buildings: [] }
        };
        
        // Phase colors and materials
        const phaseColors = {
            phase1: 0x4682B4,  // Steel blue - completed
            phase2: 0xFF8C00,  // Dark orange - construction
            phase3: 0x32CD32   // Lime green - planned
        };

        // Building types với thiết kế chi tiết
        const buildingTypes = {
            office_tower: { 
                minHeight: 40, 
                maxHeight: 80, 
                color: 0x4a90e2,
                name: 'Tòa văn phòng',
                icon: '🏢',
                features: ['Kính phản quang', 'Sảnh lớn', 'Thang máy tốc độ cao']
            },
            residential_tower: { 
                minHeight: 30, 
                maxHeight: 60, 
                color: 0xf5a623,
                name: 'Chung cư cao cấp',
                icon: '🏠',
                features: ['Ban công rộng', 'Hồ bơi trên mái', 'Phòng gym']
            },
            tech_campus: { 
                minHeight: 15, 
                maxHeight: 25, 
                color: 0x7ed321,
                name: 'Khu công nghệ',
                icon: '💻',
                features: ['Năng lượng mặt trời', 'Không gian mở', 'Phòng lab AI']
            },
            commercial_center: { 
                minHeight: 20, 
                maxHeight: 35, 
                color: 0xbd10e0,
                name: 'Trung tâm thương mại',
                icon: '🛍️',
                features: ['Food court', 'Rạp chiếu phim', 'Khu vui chơi']
            },
            medical_center: { 
                minHeight: 25, 
                maxHeight: 40, 
                color: 0xff0000,
                name: 'Bệnh viện thông minh',
                icon: '🏥',
                features: ['Cấp cứu 24/7', 'Helipad', 'AI chẩn đoán']
            },
            education_hub: { 
                minHeight: 15, 
                maxHeight: 30, 
                color: 0x50e3c2,
                name: 'Trung tâm giáo dục',
                features: ['Thư viện số', 'Phòng VR', 'Sân thể thao']
            },
            datacenter_01: {
                minHeight: 18,
                maxHeight: 22,
                color: 0x2c3e50,
                name: 'Data Center 01 - 100MW',
                icon: '🏭',
                features: ['22 HA', 'Hệ thống làm mát', 'Backup generators', '500KV connection']
            },
            datacenter_02: {
                minHeight: 16,
                maxHeight: 20,
                color: 0x34495e,
                name: 'Data Center 02 - 100MW', 
                icon: '🏭',
                features: ['20 HA', 'Advanced cooling', 'UPS systems', 'Fiber optic']
            },
            datacenter_03: {
                minHeight: 14,
                maxHeight: 18,
                color: 0x566573,
                name: 'Data Center 03 - 100MW',
                icon: '🏭', 
                features: ['17 HA', 'Edge computing', 'AI processing', 'Green energy']
            },
            substation_500kv: {
                minHeight: 8,
                maxHeight: 12,
                color: 0xf39c12,
                name: 'Trạm biến áp 500KV',
                icon: '⚡',
                features: ['500KV distribution', 'Smart grid', 'Remote monitoring', 'Emergency backup']
            }
        };

        // Park configurations
        const parkConfigs = [
            { size: { x: 200, z: 150 }, position: { x: 0, z: 0 }, type: 'central' },
            { size: { x: 50, z: 50 }, position: { x: -120, z: 80 }, type: 'playground' },
            { size: { x: 40, z: 60 }, position: { x: 130, z: -70 }, type: 'playground' },
            { size: { x: 45, z: 45 }, position: { x: -100, z: -100 }, type: 'playground' },
            { size: { x: 55, z: 40 }, position: { x: 110, z: 90 }, type: 'playground' },
            { size: { x: 35, z: 50 }, position: { x: -140, z: 0 }, type: 'playground' }
        ];

        // Initialize loading with timeout protection
        function initializeLoading() {
            // Set timeout để tránh loading vô hạn
            loadingTimeout = setTimeout(() => {
                if (isLoading) {
                    console.error('⏰ Loading timeout sau 15 giây');
                    showError('Timeout khi tải. Vui lòng thử lại.');
                }
            }, 15000);

            // Update loading progress
            updateLoadingProgress('Đang tải Three.js...');
        }

        function updateLoadingProgress(message) {
            const progressElement = document.getElementById('loading-progress');
            if (progressElement) {
                progressElement.textContent = message;
            }
            console.log('📊 ' + message);
        }

        function hideLoading() {
            isLoading = false;
            clearTimeout(loadingTimeout);
            
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }
        }

        function showError(message) {
            isLoading = false;
            clearTimeout(loadingTimeout);
            
            const errorScreen = document.getElementById('error-screen');
            const errorMessage = document.getElementById('error-message');
            
            if (errorScreen && errorMessage) {
                errorMessage.textContent = message;
                errorScreen.style.display = 'flex';
            }
            
            // Hide loading screen
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.style.display = 'none';
            }
        }

        // Initialize scene
        async function init() {
            try {
                updateLoadingProgress('Khởi tạo scene 3D...');
                
                // Scene setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB);
                // Fog removed for better visibility

                // Get viewport dimensions with fallbacks
                const width = window.innerWidth || 1920;
                const height = window.innerHeight || 1080;
                
                // Camera setup
                camera = new THREE.PerspectiveCamera(
                    75,
                    width / height,
                    0.1,
                    1000
                );
                camera.position.set(150, 100, 150);
                camera.lookAt(0, 0, 0);

                // Renderer setup
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                const container = document.getElementById('canvas-container');
                if (!container) {
                    throw new Error('Canvas container element not found');
                }
                container.appendChild(renderer.domElement);

                updateLoadingProgress('Khởi tạo controls...');
                
                // Initialize OrbitControls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.screenSpacePanning = false;
                controls.minDistance = 50;
                controls.maxDistance = 1000;
                controls.maxPolarAngle = Math.PI / 2;
                
                // Raycaster for mouse interaction
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();

                updateLoadingProgress('Tạo ánh sáng...');
                
                // Lighting
                setupLighting();

                updateLoadingProgress('Xây dựng thành phố...');
                
                // Create city elements  
                createGround();
                createRoads();
                
                updateLoadingProgress('Tạo công viên và cây xanh...');
                createParks();
                createTrees();
                
                updateLoadingProgress('Xây dựng tòa nhà...');
                createBuildings();
                
                updateLoadingProgress('Tạo bãi đỗ xe...');
                createParkingInfrastructure();
                
                updateLoadingProgress('Thêm nội thất đường phố...');
                createStreetFurniture();
                createInfrastructure();
                
                updateLoadingProgress('Tạo tính năng nước...');
                createWaterFeatures();

                // Event listeners
                window.addEventListener('resize', onWindowResize);
                window.addEventListener('keydown', onKeyDown);
                renderer.domElement.addEventListener('click', onMouseClick);
                renderer.domElement.addEventListener('mousemove', onMouseMove);


                updateLoadingProgress('Hoàn tất! Đang render...');
                
                // Start animation
                animate();
                
                // Hide loading after first frame
                setTimeout(() => {
                    hideLoading();
                }, 100);

            } catch (error) {
                console.error('❌ Lỗi khởi tạo:', error);
                showError('Lỗi khởi tạo 3D scene: ' + error.message);
            }
        }


        // Setup lighting system
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // Directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -150;
            directionalLight.shadow.camera.right = 150;
            directionalLight.shadow.camera.top = 150;
            directionalLight.shadow.camera.bottom = -150;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Hemisphere light for better ambient
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x545454, 0.4);
            scene.add(hemisphereLight);
        }

        // Create ground với thickness nhất quán
        function createGround() {
            const groundGeometry = new THREE.BoxGeometry(500, 0.2, 500);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x3a3a3a,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.position.y = 0.1; // Nâng lên một chút để thấy thickness
            ground.receiveShadow = true;
            scene.add(ground);
        }

        // Create road system
        function createRoads() {
            const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x2c2c2c });
            
            // Main roads
            const roads = [
                { pos: [0, 0.1, 0], size: [20, 0.1, 500] }, // Main vertical
                { pos: [0, 0.1, 0], size: [500, 0.1, 20] }, // Main horizontal
                { pos: [100, 0.1, 0], size: [15, 0.1, 500] }, // East vertical
                { pos: [-100, 0.1, 0], size: [15, 0.1, 500] }, // West vertical
                { pos: [0, 0.1, 100], size: [500, 0.1, 15] }, // North horizontal
                { pos: [0, 0.1, -100], size: [500, 0.1, 15] }, // South horizontal
            ];

            roads.forEach(road => {
                const geometry = new THREE.BoxGeometry(...road.size);
                const mesh = new THREE.Mesh(geometry, roadMaterial);
                mesh.position.set(...road.pos);
                mesh.receiveShadow = true;
                scene.add(mesh);

                // Add road markings
                const markingMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const markingGeometry = new THREE.BoxGeometry(
                    road.size[0] > 20 ? 2 : road.size[0] * 0.1,
                    0.2,
                    road.size[2] > 20 ? 2 : road.size[2] * 0.1
                );

                // Create dashed line effect
                const numMarkings = road.size[0] > road.size[2] ? 
                    Math.floor(road.size[0] / 10) : Math.floor(road.size[2] / 10);
                
                for (let i = 0; i < numMarkings; i += 2) {
                    const marking = new THREE.Mesh(markingGeometry, markingMaterial);
                    if (road.size[0] > road.size[2]) {
                        marking.position.set(
                            road.pos[0] - road.size[0]/2 + i * 10 + 5,
                            road.pos[1] + 0.1,
                            road.pos[2]
                        );
                    } else {
                        marking.position.set(
                            road.pos[0],
                            road.pos[1] + 0.1,
                            road.pos[2] - road.size[2]/2 + i * 10 + 5
                        );
                    }
                    scene.add(marking);
                }
            });
        }

        // Create central park với đường đi figure-8
        function createCentralPark(config) {
            const park = new THREE.Group();
            
            // Park base
            const parkGeometry = new THREE.BoxGeometry(config.size.x, 0.5, config.size.z);
            const parkMaterial = new THREE.MeshLambertMaterial({ color: 0x228b22 });
            const parkBase = new THREE.Mesh(parkGeometry, parkMaterial);
            parkBase.receiveShadow = true;
            park.add(parkBase);

            // Figure-8 walking paths
            const pathMaterial = new THREE.MeshLambertMaterial({ color: 0xd4a574 });
            
            // Create figure-8 path với curves
            const curve1 = new THREE.EllipseCurve(
                -30, 0, 40, 30, 0, 2 * Math.PI, false, 0
            );
            const curve2 = new THREE.EllipseCurve(
                30, 0, 40, 30, 0, 2 * Math.PI, false, 0
            );

            const points1 = curve1.getPoints(50);
            const points2 = curve2.getPoints(50);

            // Create path meshes
            [points1, points2].forEach(points => {
                points.forEach((point, i) => {
                    if (i < points.length - 1) {
                        const pathSegment = new THREE.BoxGeometry(5, 0.1, 2);
                        const pathMesh = new THREE.Mesh(pathSegment, pathMaterial);
                        pathMesh.position.set(point.x, 0.3, point.y);
                        
                        // Rotate to align with curve
                        const nextPoint = points[i + 1];
                        const angle = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);
                        pathMesh.rotation.y = -angle;
                        
                        park.add(pathMesh);
                    }
                });
            });

            // Small fountain - reduced size to avoid river-like appearance
            const fountainGroup = new THREE.Group();
            
            // Fountain base
            const fountainBase = new THREE.Mesh(
                new THREE.CylinderGeometry(4, 5, 1.5, 32),
                new THREE.MeshPhongMaterial({ color: 0x808080 })
            );
            fountainBase.position.y = 0.75;
            fountainGroup.add(fountainBase);

            // Small water effect - much smaller
            const waterGeometry = new THREE.CylinderGeometry(3, 3, 1, 32);
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.6,
                shininess: 100
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.position.y = 1.5;
            fountainGroup.add(water);

            // Reduced water jets - only 4 small ones
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const jet = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.2, 1.5, 8),
                    waterMaterial
                );
                jet.position.set(
                    Math.cos(angle) * 2,
                    2.5,
                    Math.sin(angle) * 2
                );
                fountainGroup.add(jet);
            }

            park.add(fountainGroup);

            // Circular benches around fountain
            const benchMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const bench = new THREE.Group();
                
                // Bench seat
                const seat = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 0.5, 1),
                    benchMaterial
                );
                seat.position.y = 1;
                bench.add(seat);
                
                // Bench back
                const back = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 1.5, 0.2),
                    benchMaterial
                );
                back.position.set(0, 1.75, -0.4);
                bench.add(back);
                
                bench.position.set(
                    Math.cos(angle) * 15,
                    0,
                    Math.sin(angle) * 15
                );
                bench.rotation.y = -angle;
                park.add(bench);
            }

            // Park entrances (4 points)
            const entrances = [
                { x: 0, z: config.size.z/2 - 5 },    // North
                { x: 0, z: -config.size.z/2 + 5 },   // South
                { x: config.size.x/2 - 5, z: 0 },    // East
                { x: -config.size.x/2 + 5, z: 0 }    // West
            ];

            entrances.forEach(entrance => {
                const gate = new THREE.Group();
                
                // Gate pillars
                for (let side = -1; side <= 1; side += 2) {
                    const pillar = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 4, 1),
                        new THREE.MeshPhongMaterial({ color: 0x808080 })
                    );
                    pillar.position.set(side * 3, 2, 0);
                    gate.add(pillar);
                }
                
                // Gate arch
                const arch = new THREE.Mesh(
                    new THREE.BoxGeometry(7, 1, 1),
                    new THREE.MeshPhongMaterial({ color: 0x808080 })
                );
                arch.position.y = 4.5;
                gate.add(arch);
                
                gate.position.set(entrance.x, 0, entrance.z);
                if (entrance.x !== 0) gate.rotation.y = Math.PI / 2;
                park.add(gate);
            });

            // Decorative elements
            // Flower beds
            const flowerColors = [0xff1493, 0xffff00, 0xff6347, 0xda70d6];
            for (let i = 0; i < 20; i++) {
                const flower = new THREE.Mesh(
                    new THREE.SphereGeometry(1, 8, 8),
                    new THREE.MeshPhongMaterial({ 
                        color: flowerColors[Math.floor(Math.random() * flowerColors.length)]
                    })
                );
                flower.position.set(
                    (Math.random() - 0.5) * config.size.x * 0.8,
                    0.5,
                    (Math.random() - 0.5) * config.size.z * 0.8
                );
                park.add(flower);
            }

            park.position.set(config.position.x, 0, config.position.z);
            return park;
        }

        // Create small parks với playgrounds
        function createSmallPark(config) {
            const park = new THREE.Group();
            
            // Park base
            const parkGeometry = new THREE.BoxGeometry(config.size.x, 0.5, config.size.z);
            const parkMaterial = new THREE.MeshLambertMaterial({ color: 0x2d5016 });
            const parkBase = new THREE.Mesh(parkGeometry, parkMaterial);
            parkBase.receiveShadow = true;
            park.add(parkBase);

            // Playground equipment
            const playgroundGroup = new THREE.Group();
            
            // Slide
            const slideGroup = new THREE.Group();
            // Slide structure
            const slideBase = new THREE.Mesh(
                new THREE.BoxGeometry(2, 4, 6),
                new THREE.MeshPhongMaterial({ color: 0xff4500 })
            );
            slideBase.position.set(0, 2, 0);
            slideGroup.add(slideBase);
            
            // Slide surface
            const slideSurface = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 0.2, 6),
                new THREE.MeshPhongMaterial({ color: 0xffff00 })
            );
            slideSurface.position.set(0, 2.5, 0);
            slideSurface.rotation.x = -0.3;
            slideGroup.add(slideSurface);
            
            // Ladder
            for (let i = 0; i < 5; i++) {
                const step = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 0.2, 0.5),
                    new THREE.MeshPhongMaterial({ color: 0x8b4513 })
                );
                step.position.set(0, i * 0.8, -3);
                slideGroup.add(step);
            }
            
            slideGroup.position.set(-10, 0, 0);
            playgroundGroup.add(slideGroup);

            // Swings
            const swingSet = new THREE.Group();
            
            // Swing frame
            const frameMaterial = new THREE.MeshPhongMaterial({ color: 0x4169e1 });
            // A-frame sides
            for (let side = -1; side <= 1; side += 2) {
                const sideFrame = new THREE.Group();
                
                const leg1 = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 5, 8),
                    frameMaterial
                );
                leg1.position.set(side * 2, 2.5, -1);
                leg1.rotation.z = side * 0.2;
                sideFrame.add(leg1);
                
                const leg2 = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 5, 8),
                    frameMaterial
                );
                leg2.position.set(side * 2, 2.5, 1);
                leg2.rotation.z = side * 0.2;
                sideFrame.add(leg2);
                
                swingSet.add(sideFrame);
            }
            
            // Top bar
            const topBar = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 6, 8),
                frameMaterial
            );
            topBar.position.y = 4.5;
            topBar.rotation.z = Math.PI / 2;
            swingSet.add(topBar);
            
            // Swings (3)
            for (let i = -1; i <= 1; i++) {
                const swing = new THREE.Group();
                
                // Chains
                const chainMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 });
                for (let side = -0.3; side <= 0.3; side += 0.6) {
                    const chain = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05, 0.05, 3, 4),
                        chainMaterial
                    );
                    chain.position.set(side, 3, 0);
                    swing.add(chain);
                }
                
                // Seat
                const seat = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.1, 0.4),
                    new THREE.MeshPhongMaterial({ color: 0x000000 })
                );
                seat.position.y = 1.5;
                swing.add(seat);
                
                swing.position.x = i * 1.5;
                swingSet.add(swing);
            }
            
            swingSet.position.set(5, 0, 0);
            playgroundGroup.add(swingSet);

            // Seesaw
            const seesawGroup = new THREE.Group();
            
            // Base
            const seesawBase = new THREE.Mesh(
                new THREE.ConeGeometry(0.5, 1, 4),
                new THREE.MeshPhongMaterial({ color: 0x32cd32 })
            );
            seesawBase.position.y = 0.5;
            seesawGroup.add(seesawBase);
            
            // Plank
            const plank = new THREE.Mesh(
                new THREE.BoxGeometry(6, 0.3, 0.8),
                new THREE.MeshPhongMaterial({ color: 0x8b4513 })
            );
            plank.position.y = 1;
            seesawGroup.add(plank);
            
            // Handles
            for (let side = -1; side <= 1; side += 2) {
                const handle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8),
                    new THREE.MeshPhongMaterial({ color: 0xff0000 })
                );
                handle.position.set(side * 2.5, 1.4, 0);
                seesawGroup.add(handle);
            }
            
            seesawGroup.position.set(0, 0, 8);
            playgroundGroup.add(seesawGroup);

            // Sandbox
            const sandbox = new THREE.Group();
            
            // Sandbox walls
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
            const walls = [
                { pos: [0, 0.5, 2], size: [4, 1, 0.2] },
                { pos: [0, 0.5, -2], size: [4, 1, 0.2] },
                { pos: [2, 0.5, 0], size: [0.2, 1, 4] },
                { pos: [-2, 0.5, 0], size: [0.2, 1, 4] }
            ];
            
            walls.forEach(wall => {
                const wallMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(...wall.size),
                    wallMaterial
                );
                wallMesh.position.set(...wall.pos);
                sandbox.add(wallMesh);
            });
            
            // Sand
            const sand = new THREE.Mesh(
                new THREE.BoxGeometry(3.8, 0.8, 3.8),
                new THREE.MeshLambertMaterial({ color: 0xf4a460 })
            );
            sand.position.y = 0.4;
            sandbox.add(sand);
            
            sandbox.position.set(10, 0, -5);
            playgroundGroup.add(sandbox);

            playgroundGroup.position.set(0, 0.3, 0);
            park.add(playgroundGroup);

            // Walking path around playground
            const pathMaterial = new THREE.MeshLambertMaterial({ color: 0xd4a574 });
            const pathWidth = 2;
            const paths = [
                { pos: [0, 0.3, config.size.z/2 - 2], size: [config.size.x - 4, 0.1, pathWidth] },
                { pos: [0, 0.3, -config.size.z/2 + 2], size: [config.size.x - 4, 0.1, pathWidth] },
                { pos: [config.size.x/2 - 2, 0.3, 0], size: [pathWidth, 0.1, config.size.z - 4] },
                { pos: [-config.size.x/2 + 2, 0.3, 0], size: [pathWidth, 0.1, config.size.z - 4] }
            ];
            
            paths.forEach(path => {
                const pathMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(...path.size),
                    pathMaterial
                );
                pathMesh.position.set(...path.pos);
                park.add(pathMesh);
            });

            // Park benches
            const benchPositions = [
                { x: -config.size.x/2 + 5, z: config.size.z/2 - 5 },
                { x: config.size.x/2 - 5, z: config.size.z/2 - 5 },
                { x: -config.size.x/2 + 5, z: -config.size.z/2 + 5 },
                { x: config.size.x/2 - 5, z: -config.size.z/2 + 5 }
            ];
            
            benchPositions.forEach(pos => {
                const bench = createBench();
                bench.position.set(pos.x, 0, pos.z);
                park.add(bench);
            });

            // Small trees in park
            for (let i = 0; i < 5; i++) {
                const tree = createTree();
                tree.position.set(
                    (Math.random() - 0.5) * config.size.x * 0.8,
                    0,
                    (Math.random() - 0.5) * config.size.z * 0.8
                );
                tree.scale.setScalar(0.8);
                park.add(tree);
            }

            park.position.set(config.position.x, 0, config.position.z);
            return park;
        }

        // Create all parks
        function createParks() {
            parkConfigs.forEach(config => {
                let park;
                if (config.type === 'central') {
                    park = createCentralPark(config);
                } else {
                    park = createSmallPark(config);
                }
                parks.push(park);
                scene.add(park);
            });
        }

        // Create tree system
        function createTree() {
            const tree = new THREE.Group();
            
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 5, 8);
            const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.5;
            trunk.castShadow = true;
            tree.add(trunk);
            
            // Crown variations
            const crownTypes = [
                { geometry: new THREE.SphereGeometry(3, 12, 8), yOffset: 6 },
                { geometry: new THREE.ConeGeometry(3, 5, 12), yOffset: 7 },
                { geometry: new THREE.DodecahedronGeometry(3), yOffset: 6 }
            ];
            
            const crownType = crownTypes[Math.floor(Math.random() * crownTypes.length)];
            const crownMaterial = new THREE.MeshPhongMaterial({ 
                color: new THREE.Color().setHSL(0.25, 0.8, 0.25 + Math.random() * 0.1)
            });
            
            const crown = new THREE.Mesh(crownType.geometry, crownMaterial);
            crown.position.y = crownType.yOffset;
            crown.castShadow = true;
            tree.add(crown);
            
            return tree;
        }

        // Create comprehensive tree distribution
        function createTrees() {
            // Trees in central park (20+)
            for (let i = 0; i < 25; i++) {
                const tree = createTree();
                const angle = Math.random() * Math.PI * 2;
                const radius = 30 + Math.random() * 60;
                tree.position.set(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
                trees.push(tree);
                scene.add(tree);
            }

            // Street trees along boulevards (every 25m)
            const streetTreePositions = [];
            
            // Main vertical streets
            for (let z = -200; z <= 200; z += 25) {
                streetTreePositions.push({ x: -110, z: z });
                streetTreePositions.push({ x: -90, z: z });
                streetTreePositions.push({ x: 90, z: z });
                streetTreePositions.push({ x: 110, z: z });
            }
            
            // Main horizontal streets
            for (let x = -200; x <= 200; x += 25) {
                if (Math.abs(x) > 20) { // Avoid center
                    streetTreePositions.push({ x: x, z: -110 });
                    streetTreePositions.push({ x: x, z: -90 });
                    streetTreePositions.push({ x: x, z: 90 });
                    streetTreePositions.push({ x: x, z: 110 });
                }
            }
            
            streetTreePositions.forEach(pos => {
                const tree = createTree();
                tree.position.set(pos.x, 0, pos.z);
                tree.scale.setScalar(0.8);
                trees.push(tree);
                scene.add(tree);
            });
        }

        // Create buildings
        function createBuildings() {
            const buildingPositions = [
                // PHASE 1 - COMPLETED (Blue/Gray)
                { x: -150, z: -150, type: 'office_tower', phase: 'phase1' },
                { x: -120, z: -150, type: 'tech_campus', phase: 'phase1' },
                { x: 150, z: 150, type: 'residential_tower', phase: 'phase1' },
                { x: 120, z: 150, type: 'residential_tower', phase: 'phase1' },
                { x: -150, z: 150, type: 'commercial_center', phase: 'phase1' },
                { x: -180, z: 0, type: 'medical_center', phase: 'phase1' },
                
                // PHASE 2 - UNDER CONSTRUCTION (Orange)
                { x: -150, z: -120, type: 'office_tower', phase: 'phase2' },
                { x: 150, z: 120, type: 'residential_tower', phase: 'phase2' },
                { x: -120, z: 120, type: 'education_hub', phase: 'phase2' },
                { x: 150, z: -150, type: 'tech_campus', phase: 'phase2' },
                { x: -50, z: -150, type: 'office_tower', phase: 'phase2' },
                { x: 50, z: 150, type: 'commercial_center', phase: 'phase2' },
                
                // PHASE 3 - PLANNED (Green/Transparent)
                { x: 120, z: -120, type: 'tech_campus', phase: 'phase3' },
                { x: 50, z: -150, type: 'office_tower', phase: 'phase3' },
                { x: -50, z: 150, type: 'commercial_center', phase: 'phase3' },
                { x: 180, z: 0, type: 'education_hub', phase: 'phase3' },
                
                // DATACENTER COMPLEX - PHASE 1 (Completed) - Repositioned to avoid water conflicts
                { x: -200, z: -200, type: 'datacenter_01', phase: 'phase1' },
                { x: -200, z: -140, type: 'datacenter_02', phase: 'phase1' },
                { x: -200, z: -80, type: 'datacenter_03', phase: 'phase1' },
                { x: -160, z: -170, type: 'substation_500kv', phase: 'phase1' },
                
                // DATACENTER EXPANSION - PHASE 2 (Under Construction) - Repositioned
                { x: -200, z: -20, type: 'datacenter_02', phase: 'phase2' },
                { x: -260, z: -140, type: 'datacenter_01', phase: 'phase2' },
                
                // FUTURE DATACENTER - PHASE 3 (Planned) - Repositioned
                { x: -260, z: -80, type: 'datacenter_03', phase: 'phase3' }
            ];

            buildingPositions.forEach(pos => {
                let building;
                if (pos.type.startsWith('datacenter') || pos.type === 'substation_500kv') {
                    building = createDatacenterBuilding(pos.type, pos.x, pos.z, pos.phase);
                } else {
                    building = createBuilding(pos.type, pos.x, pos.z, pos.phase);
                }
                buildings.push(building);
                buildingPhases[pos.phase].buildings.push(building);
                scene.add(building);
                
                // Add 2-3 decorative trees around each building (except datacenter complex)
                if (!pos.type.startsWith('datacenter') && pos.type !== 'substation_500kv') {
                    for (let i = 0; i < 2 + Math.floor(Math.random() * 2); i++) {
                        const tree = createTree();
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 15 + Math.random() * 10;
                        tree.position.set(
                            pos.x + Math.cos(angle) * distance,
                            0,
                            pos.z + Math.sin(angle) * distance
                        );
                        tree.scale.setScalar(0.7);
                        trees.push(tree);
                        scene.add(tree);
                    }
                }
            });
            
            // Create datacenter complex infrastructure
            createDatacenterInfrastructure();
            
            // Create datacenter landscaping and green spaces
            createDatacenterLandscaping();
        }

        // Create detailed building with phase
        function createBuilding(type, x, z, phase = 'phase1') {
            const building = new THREE.Group();
            const config = buildingTypes[type];
            const height = config.minHeight + Math.random() * (config.maxHeight - config.minHeight);
            
            // Phase-specific color override
            const phaseColor = phaseColors[phase];
            
            // Base structure with phase-specific properties
            const baseGeometry = new THREE.BoxGeometry(20, height, 20);
            let baseMaterial;
            
            if (phase === 'phase3') {
                // Planned buildings - transparent wireframe
                baseMaterial = new THREE.MeshPhongMaterial({ 
                    color: phaseColor,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.4,
                    wireframe: true
                });
            } else {
                // Completed and construction buildings
                baseMaterial = new THREE.MeshPhongMaterial({ 
                    color: phaseColor,
                    shininess: phase === 'phase1' ? 100 : 50
                });
            }
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = height / 2;
            base.castShadow = true;
            base.receiveShadow = true;
            building.add(base);

            // Glass windows pattern
            const windowMaterial = new THREE.MeshPhongMaterial({
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.6,
                shininess: 200
            });

            for (let floor = 0; floor < Math.floor(height / 3); floor++) {
                for (let side = 0; side < 4; side++) {
                    for (let window = 0; window < 4; window++) {
                        const windowMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 2, 0.1),
                            windowMaterial
                        );
                        
                        const angle = (side * Math.PI) / 2;
                        const radius = 10.05;
                        windowMesh.position.set(
                            Math.cos(angle) * radius + Math.sin(angle) * (window - 1.5) * 4,
                            floor * 3 + 1.5,
                            Math.sin(angle) * radius - Math.cos(angle) * (window - 1.5) * 4
                        );
                        windowMesh.rotation.y = angle;
                        building.add(windowMesh);
                    }
                }
            }

            // Rooftop features
            if (type === 'office_tower' || type === 'tech_campus') {
                // Helipad
                const helipadGroup = new THREE.Group();
                const helipad = new THREE.Mesh(
                    new THREE.CylinderGeometry(8, 8, 0.5, 32),
                    new THREE.MeshPhongMaterial({ color: 0x333333 })
                );
                helipad.position.y = height + 0.25;
                helipadGroup.add(helipad);
                
                // H marking
                const hMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const hParts = [
                    { pos: [0, height + 0.5, 0], size: [1, 0.1, 4] },
                    { pos: [-1.5, height + 0.5, 0], size: [1, 0.1, 4] },
                    { pos: [1.5, height + 0.5, 0], size: [1, 0.1, 4] },
                    { pos: [0, height + 0.5, 0], size: [4, 0.1, 1] }
                ];
                
                hParts.forEach(part => {
                    const mesh = new THREE.Mesh(
                        new THREE.BoxGeometry(...part.size),
                        hMaterial
                    );
                    mesh.position.set(...part.pos);
                    helipadGroup.add(mesh);
                });
                
                building.add(helipadGroup);
            }

            // Solar panels for eco buildings
            if (type === 'tech_campus' || type === 'education_hub') {
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        const panel = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 0.3, 2),
                            new THREE.MeshPhongMaterial({ 
                                color: 0x00008b,
                                shininess: 150
                            })
                        );
                        panel.position.set(
                            (i - 1.5) * 4,
                            height + 0.5,
                            (j - 1.5) * 3
                        );
                        panel.rotation.x = -0.2;
                        building.add(panel);
                    }
                }
            }

            // LED strips for modern buildings
            if (type === 'commercial_center' || type === 'residential_tower') {
                const ledMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.5
                });
                
                for (let i = 0; i < 4; i++) {
                    const led = new THREE.Mesh(
                        new THREE.BoxGeometry(19.5, 0.5, 0.1),
                        ledMaterial
                    );
                    const angle = (i * Math.PI) / 2;
                    led.position.set(
                        Math.cos(angle) * 10.1,
                        height - 1,
                        Math.sin(angle) * 10.1
                    );
                    led.rotation.y = angle;
                    building.add(led);
                }
            }

            // Add construction elements for phase 2
            if (phase === 'phase2') {
                addConstructionElements(building, height);
            }
            
            // Store building info
            building.userData = {
                type: type,
                name: config.name,
                height: Math.floor(height),
                floors: Math.floor(height / 3),
                features: config.features,
                phase: phase,
                phaseColor: phaseColor
            };

            building.position.set(x, 0, z);
            return building;
        }
        
        // Create specialized datacenter building
        function createDatacenterBuilding(type, x, z, phase = 'phase1') {
            const building = new THREE.Group();
            const config = buildingTypes[type];
            
            if (type === 'substation_500kv') {
                return createSubstation500KV(x, z, phase);
            }
            
            const height = config.minHeight + Math.random() * (config.maxHeight - config.minHeight);
            const phaseColor = phaseColors[phase];
            
            // Datacenter main building - more rectangular, industrial design
            const baseGeometry = new THREE.BoxGeometry(45, height, 25);
            let baseMaterial;
            
            if (phase === 'phase3') {
                baseMaterial = new THREE.MeshPhongMaterial({ 
                    color: phaseColor,
                    transparent: true,
                    opacity: 0.4,
                    wireframe: true
                });
            } else {
                baseMaterial = new THREE.MeshPhongMaterial({ 
                    color: phaseColor,
                    shininess: phase === 'phase1' ? 100 : 50
                });
            }
            
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = height / 2;
            base.castShadow = true;
            base.receiveShadow = true;
            building.add(base);
            
            // Industrial ventilation grilles - minimal windows for security
            const grilleMaterial = new THREE.MeshPhongMaterial({
                color: 0x404040,
                transparent: true,
                opacity: 0.8
            });
            
            // Side ventilation grilles
            for (let side = 0; side < 4; side++) {
                for (let floor = 0; floor < Math.floor(height / 4); floor++) {
                    const grille = new THREE.Mesh(
                        new THREE.BoxGeometry(8, 1.5, 0.1),
                        grilleMaterial
                    );
                    
                    const angle = (side * Math.PI) / 2;
                    const radius = side % 2 === 0 ? 22.6 : 12.6;
                    grille.position.set(
                        Math.cos(angle) * radius,
                        floor * 4 + 2,
                        Math.sin(angle) * radius
                    );
                    grille.rotation.y = angle;
                    building.add(grille);
                }
            }
            
            // Massive cooling towers on roof
            for (let i = 0; i < 4; i++) {
                const coolingTower = new THREE.Group();
                
                // Tower base
                const towerBase = new THREE.Mesh(
                    new THREE.CylinderGeometry(3, 4, 8, 16),
                    new THREE.MeshPhongMaterial({ color: 0x606060 })
                );
                towerBase.position.y = height + 4;
                coolingTower.add(towerBase);
                
                // Tower top
                const towerTop = new THREE.Mesh(
                    new THREE.CylinderGeometry(2, 3, 3, 16),
                    new THREE.MeshPhongMaterial({ color: 0x808080 })
                );
                towerTop.position.y = height + 9.5;
                coolingTower.add(towerTop);
                
                // Steam effect
                const steam = new THREE.Mesh(
                    new THREE.SphereGeometry(1.5, 8, 8),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.3
                    })
                );
                steam.position.y = height + 12;
                coolingTower.add(steam);
                
                // Position towers
                const angle = (i / 4) * Math.PI * 2;
                coolingTower.position.set(
                    Math.cos(angle) * 15,
                    0,
                    Math.sin(angle) * 8
                );
                building.add(coolingTower);
            }
            
            // Backup generators building
            const generatorBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(15, 6, 10),
                new THREE.MeshPhongMaterial({ color: 0x8b4513 })
            );
            generatorBuilding.position.set(25, 3, 0);
            building.add(generatorBuilding);
            
            // Generator exhaust stacks
            for (let i = 0; i < 3; i++) {
                const stack = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.5, 8, 8),
                    new THREE.MeshPhongMaterial({ color: 0x2c2c2c })
                );
                stack.position.set(20 + i * 3, 10, 0);
                building.add(stack);
            }
            
            // Solar panel array on roof
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 3; j++) {
                    const panel = new THREE.Mesh(
                        new THREE.BoxGeometry(6, 0.2, 4),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x000080,
                            shininess: 200
                        })
                    );
                    panel.position.set(
                        (i - 2.5) * 7,
                        height + 0.5,
                        (j - 1) * 5
                    );
                    panel.rotation.x = -0.2;
                    building.add(panel);
                }
            }
            
            // Security perimeter fence
            const fenceHeight = 4;
            const fenceMaterial = new THREE.MeshPhongMaterial({ color: 0x404040 });
            
            // Fence posts
            const fencePositions = [
                // Front fence
                { x: 35, z: -20 }, { x: 35, z: -10 }, { x: 35, z: 0 }, { x: 35, z: 10 }, { x: 35, z: 20 },
                // Back fence  
                { x: -35, z: -20 }, { x: -35, z: -10 }, { x: -35, z: 0 }, { x: -35, z: 10 }, { x: -35, z: 20 },
                // Side fences
                { x: -25, z: 25 }, { x: -15, z: 25 }, { x: -5, z: 25 }, { x: 5, z: 25 }, { x: 15, z: 25 }, { x: 25, z: 25 },
                { x: -25, z: -25 }, { x: -15, z: -25 }, { x: -5, z: -25 }, { x: 5, z: -25 }, { x: 15, z: -25 }, { x: 25, z: -25 }
            ];
            
            fencePositions.forEach(pos => {
                const post = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, fenceHeight, 8),
                    fenceMaterial
                );
                post.position.set(pos.x, fenceHeight/2, pos.z);
                building.add(post);
            });
            
            // Security gate
            const gate = new THREE.Mesh(
                new THREE.BoxGeometry(8, 3, 0.2),
                new THREE.MeshPhongMaterial({ color: 0x2c2c2c })
            );
            gate.position.set(35, 1.5, 0);
            building.add(gate);
            
            // Warning lights on building corners
            const warningLightPositions = [
                { x: 22, y: height + 2, z: 12 },
                { x: 22, y: height + 2, z: -12 },
                { x: -22, y: height + 2, z: 12 },
                { x: -22, y: height + 2, z: -12 }
            ];
            
            warningLightPositions.forEach(pos => {
                const light = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 8, 8),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xff0000,
                        emissive: 0xff0000,
                        emissiveIntensity: 0.5
                    })
                );
                light.position.set(pos.x, pos.y, pos.z);
                building.add(light);
            });
            
            // Satellite dishes for communication
            for (let i = 0; i < 2; i++) {
                const dish = new THREE.Group();
                
                // Dish base
                const dishBase = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 2, 8),
                    new THREE.MeshPhongMaterial({ color: 0x606060 })
                );
                dishBase.position.y = height + 1;
                dish.add(dishBase);
                
                // Dish
                const dishMesh = new THREE.Mesh(
                    new THREE.SphereGeometry(2, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2),
                    new THREE.MeshPhongMaterial({ color: 0xffffff })
                );
                dishMesh.position.y = height + 2;
                dishMesh.rotation.x = -Math.PI / 4;
                dish.add(dishMesh);
                
                dish.position.set((i - 0.5) * 20, 0, 15);
                building.add(dish);
            }
            
            // Store building info
            building.userData = {
                type: type,
                name: config.name,
                height: Math.floor(height),
                floors: Math.floor(height / 3),
                features: config.features,
                phase: phase,
                phaseColor: phaseColor,
                icon: config.icon
            };

            building.position.set(x, 2.0, z); // Adjusted to sit on foundation pad
            return building;
        }
        
        // Create 500KV substation
        function createSubstation500KV(x, z, phase = 'phase1') {
            const substation = new THREE.Group();
            const phaseColor = phaseColors[phase];
            
            // Control building
            const controlBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(20, 8, 15),
                new THREE.MeshPhongMaterial({ color: phaseColor })
            );
            controlBuilding.position.y = 4;
            substation.add(controlBuilding);
            
            // High voltage equipment yard
            const equipmentYard = new THREE.Mesh(
                new THREE.BoxGeometry(60, 0.5, 40),
                new THREE.MeshPhongMaterial({ color: 0x606060 })
            );
            equipmentYard.position.y = 0.25;
            substation.add(equipmentYard);
            
            // Transformers
            for (let i = 0; i < 3; i++) {
                const transformer = new THREE.Group();
                
                // Main transformer body
                const transformerBody = new THREE.Mesh(
                    new THREE.CylinderGeometry(3, 3, 6, 16),
                    new THREE.MeshPhongMaterial({ color: 0x8b4513 })
                );
                transformerBody.position.y = 3;
                transformer.add(transformerBody);
                
                // Cooling fins
                for (let j = 0; j < 8; j++) {
                    const fin = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 6, 1),
                        new THREE.MeshPhongMaterial({ color: 0x404040 })
                    );
                    const angle = (j / 8) * Math.PI * 2;
                    fin.position.set(
                        Math.cos(angle) * 3.2,
                        3,
                        Math.sin(angle) * 3.2
                    );
                    fin.rotation.y = angle;
                    transformer.add(fin);
                }
                
                transformer.position.set((i - 1) * 15, 0, -10);
                substation.add(transformer);
            }
            
            // High voltage power lines support structures
            const supportPositions = [
                { x: -25, z: 15 }, { x: 0, z: 15 }, { x: 25, z: 15 },
                { x: -25, z: -15 }, { x: 0, z: -15 }, { x: 25, z: -15 }
            ];
            
            supportPositions.forEach(pos => {
                const support = new THREE.Group();
                
                // Main tower
                const tower = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 1, 25, 8),
                    new THREE.MeshPhongMaterial({ color: 0x708090 })
                );
                tower.position.y = 12.5;
                support.add(tower);
                
                // Cross arms
                for (let i = 0; i < 3; i++) {
                    const arm = new THREE.Mesh(
                        new THREE.BoxGeometry(12, 0.3, 0.3),
                        new THREE.MeshPhongMaterial({ color: 0x708090 })
                    );
                    arm.position.y = 20 + i * 2;
                    support.add(arm);
                    
                    // Insulators
                    for (let j = -1; j <= 1; j++) {
                        const insulator = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.2, 0.3, 2, 8),
                            new THREE.MeshPhongMaterial({ color: 0xffffff })
                        );
                        insulator.position.set(j * 4, 19 + i * 2, 0);
                        support.add(insulator);
                    }
                }
                
                support.position.set(pos.x, 0, pos.z);
                substation.add(support);
            });
            
            // Power cables between supports
            const cableMaterial = new THREE.MeshPhongMaterial({ color: 0x2c2c2c });
            for (let line = 0; line < 3; line++) {
                for (let i = 0; i < supportPositions.length - 1; i++) {
                    const start = supportPositions[i];
                    const end = supportPositions[i + 1];
                    
                    if (Math.abs(start.x - end.x) > 0 || Math.abs(start.z - end.z) > 0) {
                        const cable = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.05, 0.05, 
                                Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.z - start.z, 2)), 8),
                            cableMaterial
                        );
                        
                        cable.position.set(
                            (start.x + end.x) / 2,
                            20 + line * 2,
                            (start.z + end.z) / 2
                        );
                        
                        if (start.z === end.z) {
                            cable.rotation.z = Math.PI / 2;
                        } else {
                            cable.rotation.x = Math.PI / 2;
                        }
                        
                        substation.add(cable);
                    }
                }
            }
            
            // Warning signs
            const signPositions = [
                { x: 30, z: 0, rotation: -Math.PI/2 },
                { x: -30, z: 0, rotation: Math.PI/2 },
                { x: 0, z: 20, rotation: 0 },
                { x: 0, z: -20, rotation: Math.PI }
            ];
            
            signPositions.forEach(pos => {
                const signPost = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 3, 8),
                    new THREE.MeshPhongMaterial({ color: 0x404040 })
                );
                signPost.position.set(pos.x, 1.5, pos.z);
                substation.add(signPost);
                
                const sign = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 1, 0.1),
                    new THREE.MeshPhongMaterial({ color: 0xffff00 })
                );
                sign.position.set(pos.x, 3, pos.z);
                sign.rotation.y = pos.rotation;
                substation.add(sign);
                
                // Danger symbol
                const dangerSymbol = new THREE.Mesh(
                    new THREE.ConeGeometry(0.3, 0.5, 3),
                    new THREE.MeshPhongMaterial({ color: 0xff0000 })
                );
                dangerSymbol.position.set(pos.x, 3, pos.z + 0.1);
                dangerSymbol.rotation.y = pos.rotation;
                substation.add(dangerSymbol);
            });
            
            // Security fence around substation
            const fenceHeight = 5;
            const perimeter = [
                // Front and back
                { start: { x: -35, z: 25 }, end: { x: 35, z: 25 } },
                { start: { x: -35, z: -25 }, end: { x: 35, z: -25 } },
                // Sides
                { start: { x: -35, z: -25 }, end: { x: -35, z: 25 } },
                { start: { x: 35, z: -25 }, end: { x: 35, z: 25 } }
            ];
            
            perimeter.forEach(fence => {
                const length = Math.sqrt(
                    Math.pow(fence.end.x - fence.start.x, 2) + 
                    Math.pow(fence.end.z - fence.start.z, 2)
                );
                
                const fencePanel = new THREE.Mesh(
                    new THREE.BoxGeometry(length, fenceHeight, 0.1),
                    new THREE.MeshPhongMaterial({ 
                        color: 0x404040,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                
                fencePanel.position.set(
                    (fence.start.x + fence.end.x) / 2,
                    fenceHeight / 2,
                    (fence.start.z + fence.end.z) / 2
                );
                
                if (fence.start.z === fence.end.z) {
                    // Horizontal fence
                } else {
                    // Vertical fence
                    fencePanel.rotation.y = Math.PI / 2;
                }
                
                substation.add(fencePanel);
            });
            
            // Store building info
            substation.userData = {
                type: 'substation_500kv',
                name: buildingTypes.substation_500kv.name,
                height: 25,
                floors: 1,
                features: buildingTypes.substation_500kv.features,
                phase: phase,
                phaseColor: phaseColor,
                icon: buildingTypes.substation_500kv.icon
            };

            substation.position.set(x, 2.0, z); // Adjusted to sit on foundation pad
            return substation;
        }
        
        // Create datacenter complex infrastructure
        function createDatacenterInfrastructure() {
            // Main access road to datacenter complex - wider and longer - Updated position
            const accessRoad = new THREE.Mesh(
                new THREE.BoxGeometry(20, 0.2, 180),
                new THREE.MeshLambertMaterial({ color: 0x2c2c2c })
            );
            accessRoad.position.set(-120, 0.1, -110);
            scene.add(accessRoad);
            
            // Road markings - Updated position
            for (let i = -90; i <= 90; i += 20) {
                const marking = new THREE.Mesh(
                    new THREE.BoxGeometry(12, 0.05, 2),
                    new THREE.MeshBasicMaterial({ color: 0xffff00 })
                );
                marking.position.set(-120, 0.15, -110 + i);
                scene.add(marking);
            }
            
            // Datacenter complex entrance gate - more impressive
            const entranceGate = new THREE.Group();
            
            // Gate pillars
            for (let side = -1; side <= 1; side += 2) {
                const pillar = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 8, 3),
                    new THREE.MeshPhongMaterial({ color: 0x404040 })
                );
                pillar.position.set(-80, 4, -110 + side * 12);
                entranceGate.add(pillar);
                
                // Security cameras on pillars
                const camera = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.5, 0.5),
                    new THREE.MeshPhongMaterial({ color: 0x2c2c2c })
                );
                camera.position.set(-80, 6, -110 + side * 12);
                entranceGate.add(camera);
            }
            
            // Main gate arch
            const gateArch = new THREE.Mesh(
                new THREE.BoxGeometry(3, 2, 24),
                new THREE.MeshPhongMaterial({ color: 0x404040 })
            );
            gateArch.position.set(-80, 9, -110);
            entranceGate.add(gateArch);
            
            // Gate sign
            const gateSign = new THREE.Mesh(
                new THREE.BoxGeometry(16, 3, 0.3),
                new THREE.MeshPhongMaterial({ color: 0x0066ff })
            );
            gateSign.position.set(-80, 8, -110);
            entranceGate.add(gateSign);
            
            // Gate barriers
            for (let side = -1; side <= 1; side += 2) {
                const barrier = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 0.5, 10),
                    new THREE.MeshPhongMaterial({ color: 0xff0000 })
                );
                barrier.position.set(-78, 1, -110 + side * 7);
                barrier.rotation.y = side * 0.3;
                entranceGate.add(barrier);
            }
            
            scene.add(entranceGate);
            
            // Power line from substation to city - extended
            const powerLineSupports = [];
            for (let i = 0; i < 15; i++) {
                const support = new THREE.Group();
                
                const pole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.4, 0.5, 25, 8),
                    new THREE.MeshPhongMaterial({ color: 0x708090 })
                );
                pole.position.y = 12.5;
                support.add(pole);
                
                // Cross arm
                const arm = new THREE.Mesh(
                    new THREE.BoxGeometry(10, 0.4, 0.4),
                    new THREE.MeshPhongMaterial({ color: 0x708090 })
                );
                arm.position.y = 22;
                support.add(arm);
                
                // Power cables
                for (let j = -1; j <= 1; j++) {
                    const cable = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.04, 0.04, 35, 8),
                        new THREE.MeshPhongMaterial({ color: 0x2c2c2c })
                    );
                    cable.position.set(j * 3, 20, 17.5);
                    cable.rotation.x = Math.PI / 2;
                    support.add(cable);
                }
                
                support.position.set(-80 + i * 35, 0, -110);
                powerLineSupports.push(support);
                scene.add(support);
            }
            
            // Emergency backup power complex
            const backupPowerComplex = new THREE.Group();
            
            const backupPower = new THREE.Mesh(
                new THREE.BoxGeometry(40, 15, 25),
                new THREE.MeshPhongMaterial({ color: 0x8b4513 })
            );
            backupPower.position.y = 7.5;
            backupPowerComplex.add(backupPower);
            
            // Multiple fuel tanks
            for (let i = 0; i < 6; i++) {
                const tank = new THREE.Mesh(
                    new THREE.CylinderGeometry(4, 4, 10, 16),
                    new THREE.MeshPhongMaterial({ color: 0x2c2c2c })
                );
                tank.position.set(-30 + (i % 3) * 12, 5, -15 + Math.floor(i / 3) * 15);
                tank.rotation.z = Math.PI / 2;
                backupPowerComplex.add(tank);
                
                // Tank labels
                const label = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1, 0.1),
                    new THREE.MeshPhongMaterial({ color: 0xffff00 })
                );
                label.position.set(-30 + (i % 3) * 12, 9, -15 + Math.floor(i / 3) * 15);
                backupPowerComplex.add(label);
            }
            
            backupPowerComplex.position.set(-320, 0, -110);
            scene.add(backupPowerComplex);
            
            // Security checkpoint buildings - Updated positions
            const securityBuildings = [
                { x: -100, z: -130 },
                { x: -100, z: -90 }
            ];
            
            securityBuildings.forEach(pos => {
                const checkpoint = new THREE.Group();
                
                const building = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 4, 6),
                    new THREE.MeshPhongMaterial({ color: 0x606060 })
                );
                building.position.y = 2;
                checkpoint.add(building);
                
                // Security barrier
                const barrier = new THREE.Mesh(
                    new THREE.BoxGeometry(15, 1, 0.5),
                    new THREE.MeshPhongMaterial({ color: 0xff6600 })
                );
                barrier.position.set(0, 1, 8);
                checkpoint.add(barrier);
                
                checkpoint.position.set(pos.x, 0, pos.z);
                scene.add(checkpoint);
            });
            
            console.log('🏭 Enhanced datacenter complex infrastructure created');
        }
        
        // Create datacenter landscaping and green spaces
        function createDatacenterLandscaping() {
            // Create datacenter industrial zone foundation
            const datacenterZone = new THREE.Group();
            
            // Main datacenter industrial ground - matching main city ground thickness
            const industrialGround = new THREE.Mesh(
                new THREE.BoxGeometry(180, 0.2, 220),
                new THREE.MeshLambertMaterial({ color: 0x3a3a3a })
            );
            industrialGround.position.y = 0.1; // Same level as main ground
            industrialGround.receiveShadow = true;
            industrialGround.receiveShadow = true;
            datacenterZone.add(industrialGround);
            
            // Concrete foundation pads for each datacenter - Updated positions
            const datacenterPositions = [
                { x: -200, z: -200 }, { x: -200, z: -140 }, { x: -200, z: -80 },
                { x: -200, z: -20 }, { x: -260, z: -140 }, { x: -260, z: -80 },
                { x: -160, z: -170 } // substation
            ];
            
            datacenterPositions.forEach(pos => {
                // Main ground foundation for datacenter - reduced thickness for consistency  
                const groundFoundation = new THREE.Mesh(
                    new THREE.BoxGeometry(80, 1, 70),
                    new THREE.MeshLambertMaterial({ color: 0x404040 })
                );
                groundFoundation.position.set(pos.x, 0.7, pos.z); // Adjusted Y position
                groundFoundation.receiveShadow = true;
                datacenterZone.add(groundFoundation);
                
                // Concrete foundation pad on top
                const foundationPad = new THREE.Mesh(
                    new THREE.BoxGeometry(60, 0.8, 50),
                    new THREE.MeshLambertMaterial({ color: 0x6b7280 })
                );
                foundationPad.position.set(pos.x, 1.6, pos.z); // Adjusted to sit on ground foundation
                foundationPad.receiveShadow = true;
                datacenterZone.add(foundationPad);
                
                // Elevated walkway around datacenter - consistent with main ground
                const walkway = new THREE.Mesh(
                    new THREE.RingGeometry(32, 35, 32),
                    new THREE.MeshLambertMaterial({ color: 0x3a3a3a })
                );
                walkway.position.set(pos.x, 2.0, pos.z); // Adjusted Y position
                walkway.rotation.x = -Math.PI / 2;
                walkway.receiveShadow = true;
                datacenterZone.add(walkway);
                
                // Security perimeter marking
                const perimeterLine = new THREE.Mesh(
                    new THREE.RingGeometry(35, 36, 32),
                    new THREE.MeshBasicMaterial({ color: 0xfbbf24 })
                );
                perimeterLine.position.set(pos.x, 2.1, pos.z); // Adjusted Y position
                perimeterLine.rotation.x = -Math.PI / 2;
                datacenterZone.add(perimeterLine);
                
                // Ground-level utility access points
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const utility = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 1, 3),
                        new THREE.MeshPhongMaterial({ color: 0x475569 })
                    );
                    utility.position.set(
                        pos.x + Math.cos(angle) * 25,
                        1.7, // Adjusted Y position to sit on foundation pad
                        pos.z + Math.sin(angle) * 20
                    );
                    datacenterZone.add(utility);
                }
            });
            
            // Special foundation for substation 500KV - Updated position
            const substationPos = { x: -160, z: -170 };
            
            // Main ground foundation for substation - matching datacenter style
            const substationGroundFoundation = new THREE.Mesh(
                new THREE.BoxGeometry(90, 1, 80),
                new THREE.MeshLambertMaterial({ color: 0x404040 })
            );
            substationGroundFoundation.position.set(substationPos.x, 0.7, substationPos.z); // Adjusted Y
            substationGroundFoundation.receiveShadow = true;
            datacenterZone.add(substationGroundFoundation);
            
            // Concrete foundation pad for substation
            const substationFoundationPad = new THREE.Mesh(
                new THREE.BoxGeometry(70, 0.8, 60),
                new THREE.MeshLambertMaterial({ color: 0x6b7280 })
            );
            substationFoundationPad.position.set(substationPos.x, 1.6, substationPos.z); // Adjusted Y
            substationFoundationPad.receiveShadow = true;
            datacenterZone.add(substationFoundationPad);
            
            // Security perimeter for substation
            const substationPerimeter = new THREE.Mesh(
                new THREE.RingGeometry(40, 42, 32),
                new THREE.MeshBasicMaterial({ color: 0xff6b35 })
            );
            substationPerimeter.position.set(substationPos.x, 2.1, substationPos.z); // Adjusted Y
            substationPerimeter.rotation.x = -Math.PI / 2;
            datacenterZone.add(substationPerimeter);
            
            // Datacenter zone position - Updated to align with new building positions
            datacenterZone.position.set(-230, 0, -110);
            scene.add(datacenterZone);
            
            // Create winding river flowing from South to North - REALISTIC CURVED DESIGN
            const river = new THREE.Group();
            
            // Define river curve points for natural meandering
            const riverCurvePoints = [
                { x: -420, z: -220, width: 20, rotation: 0 },      // Start point (South)
                { x: -400, z: -200, width: 22, rotation: 0.3 },    // Curve right
                { x: -390, z: -180, width: 25, rotation: 0.1 },    // Slight left
                { x: -385, z: -160, width: 28, rotation: -0.2 },   // Curve left  
                { x: -390, z: -140, width: 30, rotation: -0.4 },   // More left
                { x: -400, z: -120, width: 28, rotation: -0.1 },   // Straighten
                { x: -395, z: -100, width: 26, rotation: 0.2 },    // Curve right
                { x: -385, z: -80, width: 24, rotation: 0.4 },     // More right
                { x: -370, z: -60, width: 22, rotation: 0.2 },     // Gentle right
                { x: -365, z: -40, width: 25, rotation: -0.1 },    // Slight left
                { x: -370, z: -20, width: 27, rotation: -0.3 },    // Curve left
                { x: -380, z: 0, width: 25, rotation: -0.2 },      // Gentle left
                { x: -375, z: 20, width: 23, rotation: 0.1 },      // Slight right
                { x: -365, z: 40, width: 26, rotation: 0.3 },      // Curve right
                { x: -350, z: 60, width: 24, rotation: 0.2 },      // Continue right
                { x: -345, z: 80, width: 22, rotation: 0 }         // End point (North)
            ];
            
            const riverMaterial = new THREE.MeshPhongMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });
            
            // Create curved river segments
            riverCurvePoints.forEach((point, index) => {
                const segmentLength = index < riverCurvePoints.length - 1 ? 25 : 20;
                
                // Main water segment
                const riverSegment = new THREE.Mesh(
                    new THREE.BoxGeometry(point.width, 1.2, segmentLength),
                    riverMaterial
                );
                riverSegment.position.set(point.x, 0.4, point.z);
                riverSegment.rotation.y = point.rotation;
                riverSegment.receiveShadow = true;
                riverSegment.name = `river-segment-${index}`;
                river.add(riverSegment);
                
                // River banks
                const bankMaterial = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
                
                // Left bank
                const leftBank = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 1.5, segmentLength + 2),
                    bankMaterial
                );
                leftBank.position.set(
                    point.x + Math.cos(point.rotation + Math.PI/2) * (point.width/2 + 4),
                    0.8,
                    point.z
                );
                leftBank.rotation.y = point.rotation;
                river.add(leftBank);
                
                // Right bank
                const rightBank = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 1.5, segmentLength + 2),
                    bankMaterial
                );
                rightBank.position.set(
                    point.x + Math.cos(point.rotation - Math.PI/2) * (point.width/2 + 4),
                    0.8,
                    point.z
                );
                rightBank.rotation.y = point.rotation;
                river.add(rightBank);
                
                // Add vegetation along banks
                if (index % 2 === 0) { // Every other segment
                    for (let side = -1; side <= 1; side += 2) {
                        const tree = createTree();
                        tree.position.set(
                            point.x + Math.cos(point.rotation + side * Math.PI/2) * (point.width/2 + 8 + Math.random() * 5),
                            0,
                            point.z + (Math.random() - 0.5) * 15
                        );
                        tree.scale.setScalar(0.7 + Math.random() * 0.3);
                        river.add(tree);
                    }
                }
                
                // Water flow effects
                if (index % 3 === 0) { // Every third segment
                    const ripple = new THREE.Mesh(
                        new THREE.RingGeometry(1.5, 3, 16),
                        new THREE.MeshBasicMaterial({
                            color: 0x87ceeb,
                            transparent: true,
                            opacity: 0.4
                        })
                    );
                    ripple.position.set(
                        point.x + (Math.random() - 0.5) * point.width * 0.5,
                        0.9,
                        point.z + (Math.random() - 0.5) * 10
                    );
                    ripple.rotation.x = -Math.PI / 2;
                    ripple.rotation.z = point.rotation;
                    ripple.name = 'river-ripple';
                    river.add(ripple);
                }
            });
            
            // Add small islands in wider sections
            const islandPositions = [
                { x: -390, z: -140, size: 8 },  // In the wide curve
                { x: -375, z: -85, size: 6 },   // In another wide section
                { x: -365, z: 35, size: 7 }     // In northern section
            ];
            
            islandPositions.forEach(island => {
                const islandMesh = new THREE.Mesh(
                    new THREE.CylinderGeometry(island.size, island.size + 1, 1.5, 12),
                    new THREE.MeshLambertMaterial({ color: 0x5d4e37 })
                );
                islandMesh.position.set(island.x, 0.7, island.z);
                river.add(islandMesh);
                
                // Trees on island
                for (let i = 0; i < 3; i++) {
                    const tree = createTree();
                    const angle = (i / 3) * Math.PI * 2;
                    tree.position.set(
                        island.x + Math.cos(angle) * (island.size * 0.6),
                        1.5,
                        island.z + Math.sin(angle) * (island.size * 0.6)
                    );
                    tree.scale.setScalar(0.6);
                    river.add(tree);
                }
            });
            
            // CREATE EASTERN BRANCH - Winding along the FAR RIGHT side of the map, OUTSIDE the city buildings
            const easternBranchPoints = [
                { x: -350, z: -80, width: 18, rotation: 0.8 },      // Branch from main river toward far east
                { x: -320, z: -70, width: 16, rotation: 1.0 },      // Strong curve toward far east
                { x: -280, z: -60, width: 15, rotation: 0.8 },      // Continue toward eastern edge
                { x: -240, z: -50, width: 17, rotation: 0.5 },      // Approach far eastern boundary
                { x: -200, z: -40, width: 18, rotation: 0.3 },      // Continue to eastern edge
                { x: -160, z: -30, width: 16, rotation: 0.1 },      // Near eastern boundary
                { x: -120, z: -20, width: 15, rotation: -0.1 },     // Reach eastern edge
                { x: -80, z: -10, width: 17, rotation: -0.2 },      // Flow along far eastern boundary
                { x: -40, z: 0, width: 19, rotation: -0.1 },        // Continue along far edge
                { x: 0, z: 10, width: 16, rotation: 0.1 },          // Far eastern side
                { x: 40, z: 20, width: 14, rotation: 0.2 },         // Continue along far edge
                { x: 80, z: 30, width: 15, rotation: 0.1 },         // Eastern boundary
                { x: 120, z: 40, width: 16, rotation: -0.1 },       // Continue east of buildings
                { x: 160, z: 50, width: 18, rotation: -0.2 },       // Far from buildings
                { x: 200, z: 60, width: 17, rotation: -0.1 },       // Eastern edge - START HERE
                { x: 240, z: 70, width: 15, rotation: 0.1 },        // Far eastern boundary
                { x: 280, z: 80, width: 14, rotation: 0.3 },        // Outside city limits
                { x: 320, z: 90, width: 16, rotation: 0.2 },        // Far eastern region
                { x: 350, z: 100, width: 18, rotation: 0.1 },       // Very far east
                { x: 380, z: 120, width: 17, rotation: -0.1 },      // Edge of map
                { x: 400, z: 140, width: 15, rotation: -0.2 },      // Far northeastern edge
                { x: 420, z: 160, width: 16, rotation: -0.1 },      // Continue along edge
                { x: 440, z: 180, width: 18, rotation: 0.1 },       // Far north edge
                { x: 450, z: 200, width: 17, rotation: 0.2 },       // Northeastern corner
                { x: 460, z: 220, width: 15, rotation: 0.1 },       // Final curve
                { x: 470, z: 240, width: 14, rotation: -0.1 }       // End at far northeastern corner
            ];
            
            // Create eastern branch segments
            easternBranchPoints.forEach((point, index) => {
                const segmentLength = 25;
                
                // Branch water segment
                const branchSegment = new THREE.Mesh(
                    new THREE.BoxGeometry(point.width, 1, segmentLength),
                    riverMaterial
                );
                branchSegment.position.set(point.x, 0.3, point.z);
                branchSegment.rotation.y = point.rotation;
                branchSegment.receiveShadow = true;
                branchSegment.name = `eastern-branch-segment-${index}`;
                river.add(branchSegment);
                
                // Branch banks
                const branchBankMaterial = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
                
                // Inner bank (toward city - west side)
                const innerBank = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 1.2, segmentLength + 2),
                    branchBankMaterial
                );
                innerBank.position.set(
                    point.x + Math.cos(point.rotation + Math.PI/2) * (point.width/2 + 3),
                    0.6,
                    point.z
                );
                innerBank.rotation.y = point.rotation;
                river.add(innerBank);
                
                // Outer bank (toward map edge - east side)
                const outerBank = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 1.5, segmentLength + 2),
                    branchBankMaterial
                );
                outerBank.position.set(
                    point.x + Math.cos(point.rotation - Math.PI/2) * (point.width/2 + 4),
                    0.7,
                    point.z
                );
                outerBank.rotation.y = point.rotation;
                river.add(outerBank);
                
                // Vegetation along eastern branch - dense on outer edge (wilderness)
                if (index % 2 === 0) { // Every second segment
                    // Sparse trees on inner side (toward city)
                    if (Math.random() > 0.6) { // 40% chance on city side
                        const tree = createTree();
                        tree.position.set(
                            point.x + Math.cos(point.rotation + Math.PI/2) * (point.width/2 + 7 + Math.random() * 3),
                            0,
                            point.z + (Math.random() - 0.5) * 15
                        );
                        tree.scale.setScalar(0.6 + Math.random() * 0.2);
                        river.add(tree);
                    }
                    
                    // Dense forest on outer edge (wilderness side)
                    for (let i = 0; i < 3; i++) { // Multiple trees on wilderness side
                        const tree = createTree();
                        tree.position.set(
                            point.x + Math.cos(point.rotation - Math.PI/2) * (point.width/2 + 8 + i * 4 + Math.random() * 3),
                            0,
                            point.z + (Math.random() - 0.5) * 18
                        );
                        tree.scale.setScalar(0.7 + Math.random() * 0.4);
                        river.add(tree);
                    }
                }
                
                // Water effects for eastern branch
                if (index % 3 === 0) { // Every third segment
                    const branchRipple = new THREE.Mesh(
                        new THREE.RingGeometry(1, 2.5, 12),
                        new THREE.MeshBasicMaterial({
                            color: 0x87ceeb,
                            transparent: true,
                            opacity: 0.4
                        })
                    );
                    branchRipple.position.set(
                        point.x + (Math.random() - 0.5) * point.width * 0.6,
                        0.8,
                        point.z + (Math.random() - 0.5) * 10
                    );
                    branchRipple.rotation.x = -Math.PI / 2;
                    branchRipple.rotation.z = point.rotation;
                    branchRipple.name = 'eastern-branch-ripple';
                    river.add(branchRipple);
                }
            });
            
            // Add ponds along FAR eastern branch - positioned well outside city limits
            const easternPondPositions = [
                { x: 250, z: 80, radius: 12, depth: 0.8 },    // Far eastern - south
                { x: 350, z: 120, radius: 10, depth: 0.7 },   // Very far east - middle
                { x: 420, z: 160, radius: 15, depth: 1.0 },   // Far northeast
                { x: 480, z: 230, radius: 18, depth: 1.2 }    // Northeastern wilderness terminus
            ];
            
            easternPondPositions.forEach((pond, index) => {
                // Main pond
                const pondMesh = new THREE.Mesh(
                    new THREE.CylinderGeometry(pond.radius, pond.radius + 3, pond.depth, 16),
                    riverMaterial
                );
                pondMesh.position.set(pond.x, pond.depth/2, pond.z);
                pondMesh.name = `eastern-pond-${index}`;
                river.add(pondMesh);
                
                // Natural pond shore
                const shore = new THREE.Mesh(
                    new THREE.CylinderGeometry(pond.radius + 4, pond.radius + 6, 0.4, 16),
                    new THREE.MeshLambertMaterial({ color: 0x8b7355 })
                );
                shore.position.set(pond.x, 0.2, pond.z);
                river.add(shore);
                
                // Dense forest around wilderness ponds
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const tree = createTree();
                    const radius = pond.radius + 8 + Math.random() * 8;
                    tree.position.set(
                        pond.x + Math.cos(angle) * radius,
                        0,
                        pond.z + Math.sin(angle) * radius
                    );
                    tree.scale.setScalar(0.8 + Math.random() * 0.5); // Larger wilderness trees
                    river.add(tree);
                }
                
                // Natural connecting streams
                if (index < easternPondPositions.length - 1) {
                    const connectingStream = new THREE.Mesh(
                        new THREE.BoxGeometry(pond.radius/3, 0.6, Math.random() * 25 + 20),
                        riverMaterial
                    );
                    connectingStream.position.set(
                        pond.x + (Math.random() - 0.5) * 15,
                        0.3,
                        pond.z + (Math.random() - 0.5) * 20
                    );
                    connectingStream.rotation.y = Math.random() * Math.PI;
                    river.add(connectingStream);
                }
            });
            
            // Waterfalls in wilderness along far eastern branch
            const easternWaterfallPositions = [
                { x: 200, z: 60, height: 2.5 },   // Entry to wilderness
                { x: 320, z: 90, height: 2.0 },   // Deep wilderness
                { x: 400, z: 140, height: 3.0 },  // Mountain region
                { x: 450, z: 200, height: 2.8 }   // Northern wilderness
            ];
            
            easternWaterfallPositions.forEach((fall, index) => {
                // Larger wilderness waterfall
                const waterfall = new THREE.Group();
                
                // Water curtain
                const curtain = new THREE.Mesh(
                    new THREE.BoxGeometry(10, fall.height, 0.6),
                    new THREE.MeshPhongMaterial({
                        color: 0x006994,
                        transparent: true,
                        opacity: 0.7,
                        shininess: 200
                    })
                );
                curtain.position.y = fall.height/2;
                waterfall.add(curtain);
                
                // Rocky base
                const rocks = new THREE.Mesh(
                    new THREE.CylinderGeometry(5, 8, 2, 8),
                    new THREE.MeshLambertMaterial({ color: 0x696969 })
                );
                rocks.position.y = 1;
                waterfall.add(rocks);
                
                // Mist effect
                const mist = new THREE.Mesh(
                    new THREE.SphereGeometry(3, 8, 8),
                    new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.5
                    })
                );
                mist.position.y = 1;
                mist.scale.y = 0.4;
                waterfall.add(mist);
                
                waterfall.position.set(fall.x, 0, fall.z);
                waterfall.name = `eastern-waterfall-${index}`;
                river.add(waterfall);
            });
            
            // Trees and vegetation are now integrated into river segments above
            
            // Water flow effects are now integrated into river segments above
            
            scene.add(river);
            
            // Large cooling lake for datacenters
            const coolingLake = new THREE.Group();
            
            // Main lake
            const lakeGeometry = new THREE.CylinderGeometry(45, 50, 2, 32);
            const lakeMaterial = new THREE.MeshPhongMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.9,
                shininess: 150
            });
            const lakeMesh = new THREE.Mesh(lakeGeometry, lakeMaterial);
            lakeMesh.position.y = 1;
            lakeMesh.receiveShadow = true;
            lakeMesh.name = 'cooling-lake';
            coolingLake.add(lakeMesh);
            
            // Lake shore
            const shoreGeometry = new THREE.CylinderGeometry(52, 55, 1, 32);
            const shoreMaterial = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
            const shoreMesh = new THREE.Mesh(shoreGeometry, shoreMaterial);
            shoreMesh.position.y = 0.5;
            coolingLake.add(shoreMesh);
            
            // Cooling water intake/outtake pipes
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const pipe = new THREE.Mesh(
                    new THREE.CylinderGeometry(1.5, 1.5, 15, 16),
                    new THREE.MeshPhongMaterial({ color: 0x606060 })
                );
                pipe.position.set(
                    Math.cos(angle) * 35,
                    7.5,
                    Math.sin(angle) * 35
                );
                pipe.rotation.x = Math.PI / 2;
                pipe.rotation.z = angle;
                coolingLake.add(pipe);
            }
            
            // Cooling lake position - Moved further west to completely avoid building conflicts
            coolingLake.position.set(-420, 0, -110);
            scene.add(coolingLake);
            
            // Bridge over river for datacenter access
            const bridge = new THREE.Group();
            
            // Bridge deck
            const bridgeDeck = new THREE.Mesh(
                new THREE.BoxGeometry(30, 1, 35),
                new THREE.MeshPhongMaterial({ color: 0x606060 })
            );
            bridgeDeck.position.y = 8;
            bridge.add(bridgeDeck);
            
            // Bridge supports
            const supportPositions = [
                { x: -12, z: -15 }, { x: 12, z: -15 },
                { x: -12, z: 15 }, { x: 12, z: 15 }
            ];
            
            supportPositions.forEach(pos => {
                const support = new THREE.Mesh(
                    new THREE.CylinderGeometry(1, 1.5, 8, 8),
                    new THREE.MeshPhongMaterial({ color: 0x404040 })
                );
                support.position.set(pos.x, 4, pos.z);
                bridge.add(support);
            });
            
            // Bridge railings
            for (let side = -1; side <= 1; side += 2) {
                const railing = new THREE.Mesh(
                    new THREE.BoxGeometry(30, 1.5, 0.2),
                    new THREE.MeshPhongMaterial({ color: 0x808080 })
                );
                railing.position.set(0, 9, side * 17);
                bridge.add(railing);
            }
            
            // Bridge over winding river for datacenter access - Positioned at optimal crossing point
            bridge.position.set(-385, 0, -160); // At one of the narrower river sections
            scene.add(bridge);
            
            // Additional bridges for the longer winding river
            const bridge2 = new THREE.Group();
            
            // Second bridge at northern section
            const bridgeDeck2 = new THREE.Mesh(
                new THREE.BoxGeometry(35, 1, 30),
                new THREE.MeshPhongMaterial({ color: 0x606060 })
            );
            bridgeDeck2.position.y = 8;
            bridge2.add(bridgeDeck2);
            
            // Bridge supports for second bridge
            const supportPositions2 = [
                { x: -14, z: -12 }, { x: 14, z: -12 },
                { x: -14, z: 12 }, { x: 14, z: 12 }
            ];
            
            supportPositions2.forEach(pos => {
                const support = new THREE.Mesh(
                    new THREE.CylinderGeometry(1, 1.5, 8, 8),
                    new THREE.MeshPhongMaterial({ color: 0x404040 })
                );
                support.position.set(pos.x, 4, pos.z);
                bridge2.add(support);
            });
            
            // Bridge railings for second bridge
            for (let side = -1; side <= 1; side += 2) {
                const railing = new THREE.Mesh(
                    new THREE.BoxGeometry(35, 1.5, 0.2),
                    new THREE.MeshPhongMaterial({ color: 0x808080 })
                );
                railing.position.set(0, 9, side * 15);
                bridge2.add(railing);
            }
            
            bridge2.position.set(-375, 0, -80); // At northern curve
            scene.add(bridge2);
            
            // Third bridge - smaller pedestrian bridge
            const bridge3 = new THREE.Group();
            
            const bridgeDeck3 = new THREE.Mesh(
                new THREE.BoxGeometry(25, 0.8, 25),
                new THREE.MeshPhongMaterial({ color: 0x8b7355 })
            );
            bridgeDeck3.position.y = 6;
            bridge3.add(bridgeDeck3);
            
            // Arch supports
            for (let i = 0; i < 3; i++) {
                const arch = new THREE.Mesh(
                    new THREE.TorusGeometry(3, 0.5, 8, 16, Math.PI),
                    new THREE.MeshPhongMaterial({ color: 0x654321 })
                );
                arch.position.set((i - 1) * 8, 3, 0);
                arch.rotation.z = Math.PI;
                bridge3.add(arch);
            }
            
            bridge3.position.set(-365, 0, 20); // In northern section
            scene.add(bridge3);
            
            // Bridges for FAR Eastern Branch - Connecting wilderness areas
            const easternBridges = [
                { x: 200, z: 60, type: 'vehicle', name: 'Wilderness Access Bridge' },
                { x: 280, z: 80, type: 'pedestrian', name: 'Forest Trail Bridge' },
                { x: 350, z: 100, type: 'vehicle', name: 'Wilderness Highway Bridge' },
                { x: 400, z: 140, type: 'pedestrian', name: 'Mountain Trail Bridge' },
                { x: 440, z: 180, type: 'vehicle', name: 'Northern Wilderness Bridge' },
                { x: 460, z: 220, type: 'pedestrian', name: 'Remote Area Bridge' }
            ];
            
            easternBridges.forEach((bridgeData, index) => {
                const easternBridge = new THREE.Group();
                
                if (bridgeData.type === 'vehicle') {
                    // Sturdy wilderness vehicle bridge
                    const deck = new THREE.Mesh(
                        new THREE.BoxGeometry(30, 1.5, 35),
                        new THREE.MeshPhongMaterial({ color: 0x606060 })
                    );
                    deck.position.y = 8;
                    easternBridge.add(deck);
                    
                    // Heavy concrete supports for wilderness roads
                    const supportPositions = [
                        { x: -12, z: -15 }, { x: 12, z: -15 },
                        { x: -12, z: 15 }, { x: 12, z: 15 }
                    ];
                    
                    supportPositions.forEach(pos => {
                        const support = new THREE.Mesh(
                            new THREE.CylinderGeometry(1.5, 2.2, 8, 8),
                            new THREE.MeshPhongMaterial({ color: 0x404040 })
                        );
                        support.position.set(pos.x, 4, pos.z);
                        easternBridge.add(support);
                    });
                    
                    // Strong guard rails
                    for (let side = -1; side <= 1; side += 2) {
                        const railing = new THREE.Mesh(
                            new THREE.BoxGeometry(30, 1.2, 0.4),
                            new THREE.MeshPhongMaterial({ color: 0x808080 })
                        );
                        railing.position.set(0, 9, side * 18);
                        easternBridge.add(railing);
                    }
                    
                } else {
                    // Rustic wilderness pedestrian bridge
                    const deck = new THREE.Mesh(
                        new THREE.BoxGeometry(20, 1, 25),
                        new THREE.MeshPhongMaterial({ color: 0x8b4513 })
                    );
                    deck.position.y = 5;
                    easternBridge.add(deck);
                    
                    // Wooden arch supports
                    for (let i = 0; i < 3; i++) {
                        const arch = new THREE.Mesh(
                            new THREE.TorusGeometry(3, 0.5, 8, 16, Math.PI),
                            new THREE.MeshPhongMaterial({ color: 0x654321 })
                        );
                        arch.position.set((i - 1) * 8, 2.5, 0);
                        arch.rotation.z = Math.PI;
                        easternBridge.add(arch);
                    }
                    
                    // Wooden railings
                    for (let side = -1; side <= 1; side += 2) {
                        const railing = new THREE.Mesh(
                            new THREE.BoxGeometry(20, 1, 0.3),
                            new THREE.MeshPhongMaterial({ color: 0x654321 })
                        );
                        railing.position.set(0, 6, side * 13);
                        easternBridge.add(railing);
                    }
                }
                
                easternBridge.position.set(bridgeData.x, 0, bridgeData.z);
                easternBridge.name = `eastern-bridge-${index}`;
                easternBridge.userData = { 
                    type: bridgeData.type, 
                    name: bridgeData.name 
                };
                scene.add(easternBridge);
            });
            
            // Compact datacenter park (on industrial ground)
            const datacenterPark = new THREE.Group();
            
            // Central green area within industrial zone
            const centralGreen = new THREE.Mesh(
                new THREE.BoxGeometry(50, 0.3, 35),
                new THREE.MeshLambertMaterial({ color: 0x22c55e })
            );
            centralGreen.position.y = 1.15;
            centralGreen.receiveShadow = true;
            datacenterPark.add(centralGreen);
            
            // Walking paths
            const pathMaterial = new THREE.MeshLambertMaterial({ color: 0xd4a574 });
            
            const mainPath = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.1, 32),
                pathMaterial
            );
            mainPath.position.y = 1.25;
            datacenterPark.add(mainPath);
            
            const crossPath = new THREE.Mesh(
                new THREE.BoxGeometry(47, 0.1, 3),
                pathMaterial
            );
            crossPath.position.y = 1.25;
            datacenterPark.add(crossPath);
            
            // Strategic trees
            for (let i = 0; i < 8; i++) {
                const tree = createTree();
                const angle = (i / 8) * Math.PI * 2;
                tree.position.set(
                    Math.cos(angle) * 18,
                    1,
                    Math.sin(angle) * 12
                );
                tree.scale.setScalar(0.8);
                datacenterPark.add(tree);
            }
            
            // Small decorative flower garden instead of pond to avoid water confusion
            const flowerGarden = new THREE.Group();
            
            // Garden base
            const gardenBase = new THREE.Mesh(
                new THREE.CylinderGeometry(6, 6, 0.2, 16),
                new THREE.MeshLambertMaterial({ color: 0x228b22 })
            );
            gardenBase.position.y = 0.1;
            flowerGarden.add(gardenBase);
            
            // Colorful flowers instead of water
            const flowerColors = [0xff1493, 0xffff00, 0xff6347, 0xda70d6, 0x00ff00];
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const flower = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    new THREE.MeshPhongMaterial({ 
                        color: flowerColors[Math.floor(Math.random() * flowerColors.length)]
                    })
                );
                flower.position.set(
                    Math.cos(angle) * (2 + Math.random() * 3),
                    0.3,
                    Math.sin(angle) * (2 + Math.random() * 3)
                );
                flowerGarden.add(flower);
            }
            
            flowerGarden.position.set(10, 0, -5);
            playgroundGroup.add(flowerGarden);
            
            // Datacenter park position - Updated to align with new layout
            datacenterPark.position.set(-200, 0, -110);
            scene.add(datacenterPark);
            
            // Remove individual building buffer zones - just add perimeter trees - Updated positions
            const datacenterTreePositions = [
                { x: -200, z: -200 }, { x: -200, z: -140 }, { x: -200, z: -80 },
                { x: -200, z: -20 }, { x: -260, z: -140 }, { x: -260, z: -80 }
            ];
            
            datacenterTreePositions.forEach(pos => {
                // Only perimeter trees, no green zones
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const radius = 40;
                    const tree = createTree();
                    tree.position.set(
                        pos.x + Math.cos(angle) * radius,
                        0,
                        pos.z + Math.sin(angle) * radius
                    );
                    tree.scale.setScalar(0.7);
                    trees.push(tree);
                    scene.add(tree);
                }
            });
            
            // River connection to cooling lake - Natural channels connecting main river to far eastern branch
            const connectionChannel = new THREE.Mesh(
                new THREE.BoxGeometry(40, 1, 12),
                riverMaterial
            );
            connectionChannel.position.set(-407, 0.5, -125);
            connectionChannel.rotation.y = Math.PI / 8;
            scene.add(connectionChannel);
            
            // Additional connecting channels for natural look
            const smallChannel1 = new THREE.Mesh(
                new THREE.BoxGeometry(25, 0.8, 8),
                riverMaterial
            );
            smallChannel1.position.set(-415, 0.4, -135);
            smallChannel1.rotation.y = -Math.PI / 6;
            scene.add(smallChannel1);
            
            const smallChannel2 = new THREE.Mesh(
                new THREE.BoxGeometry(30, 0.8, 10),
                riverMaterial
            );
            smallChannel2.position.set(-400, 0.4, -115);
            smallChannel2.rotation.y = Math.PI / 4;
            scene.add(smallChannel2);
            
            // Eastern branch connection to main system - long channel to far eastern wilderness
            const eastBranchConnector = new THREE.Mesh(
                new THREE.BoxGeometry(80, 0.8, 18),
                riverMaterial
            );
            eastBranchConnector.position.set(-300, 0.4, -85);
            eastBranchConnector.rotation.y = Math.PI / 4;
            scene.add(eastBranchConnector);
            
            // Additional connector segments for natural flow
            const connector2 = new THREE.Mesh(
                new THREE.BoxGeometry(60, 0.8, 15),
                riverMaterial
            );
            connector2.position.set(-250, 0.4, -70);
            connector2.rotation.y = Math.PI / 6;
            scene.add(connector2);
            
            const connector3 = new THREE.Mesh(
                new THREE.BoxGeometry(70, 0.8, 16),
                riverMaterial
            );
            connector3.position.set(-200, 0.4, -55);
            connector3.rotation.y = Math.PI / 8;
            scene.add(connector3);
            
            // Wetland area where eastern branch begins - transition zone
            const wetland = new THREE.Group();
            
            // Larger wetland base for transition area
            const wetlandBase = new THREE.Mesh(
                new THREE.CylinderGeometry(30, 35, 0.6, 16),
                new THREE.MeshLambertMaterial({ color: 0x556b2f })
            );
            wetlandBase.position.y = 0.3;
            wetland.add(wetlandBase);
            
            // Multiple marshy pools in transition area
            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2;
                const pool = new THREE.Mesh(
                    new THREE.CylinderGeometry(3 + Math.random() * 3, 4 + Math.random() * 3, 0.4, 12),
                    riverMaterial
                );
                pool.position.set(
                    Math.cos(angle) * (8 + Math.random() * 18),
                    0.5,
                    Math.sin(angle) * (8 + Math.random() * 18)
                );
                wetland.add(pool);
            }
            
            // Dense wetland vegetation in transition area
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 5 + Math.random() * 25;
                
                const reed = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.25, 2.5 + Math.random(), 6),
                    new THREE.MeshLambertMaterial({ color: 0x228b22 })
                );
                reed.position.set(
                    Math.cos(angle) * radius,
                    1.2 + Math.random() * 0.8,
                    Math.sin(angle) * radius
                );
                wetland.add(reed);
            }
            
            wetland.position.set(-320, 0, -80); // Transition area between main river and far eastern branch
            scene.add(wetland);
            
            // Additional small wetlands along the eastern branch route
            const easternWetlands = [
                { x: 150, z: 50, size: 15 },   // Early wilderness
                { x: 300, z: 90, size: 20 },   // Mid wilderness
                { x: 430, z: 170, size: 25 }   // Deep wilderness
            ];
            
            easternWetlands.forEach((wetlandData, index) => {
                const wildernessWetland = new THREE.Group();
                
                // Wilderness wetland base
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(wetlandData.size, wetlandData.size + 5, 0.5, 16),
                    new THREE.MeshLambertMaterial({ color: 0x556b2f })
                );
                base.position.y = 0.25;
                wildernessWetland.add(base);
                
                // Multiple pools
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const pool = new THREE.Mesh(
                        new THREE.CylinderGeometry(2 + Math.random() * 2, 3 + Math.random() * 2, 0.3, 12),
                        riverMaterial
                    );
                    pool.position.set(
                        Math.cos(angle) * (wetlandData.size * 0.6 + Math.random() * 8),
                        0.4,
                        Math.sin(angle) * (wetlandData.size * 0.6 + Math.random() * 8)
                    );
                    wildernessWetland.add(pool);
                }
                
                // Dense wilderness vegetation
                for (let i = 0; i < 15; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 3 + Math.random() * wetlandData.size;
                    
                    const reed = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.15, 0.3, 3 + Math.random() * 2, 6),
                        new THREE.MeshLambertMaterial({ color: 0x228b22 })
                    );
                    reed.position.set(
                        Math.cos(angle) * radius,
                        1.5 + Math.random(),
                        Math.sin(angle) * radius
                    );
                    wildernessWetland.add(reed);
                }
                
                wildernessWetland.position.set(wetlandData.x, 0, wetlandData.z);
                wildernessWetland.name = `wilderness-wetland-${index}`;
                scene.add(wildernessWetland);
            });
            
            // Water treatment facility
            const waterTreatment = new THREE.Group();
            
            const treatmentBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(25, 8, 15),
                new THREE.MeshPhongMaterial({ color: 0x708090 })
            );
            treatmentBuilding.position.y = 4;
            waterTreatment.add(treatmentBuilding);
            
            // Treatment tanks
            for (let i = 0; i < 4; i++) {
                const tank = new THREE.Mesh(
                    new THREE.CylinderGeometry(4, 4, 6, 16),
                    new THREE.MeshPhongMaterial({ color: 0x606060 })
                );
                tank.position.set((i - 1.5) * 8, 3, -12);
                waterTreatment.add(tank);
            }
            
            // Water treatment facility - Positioned along the winding river
            waterTreatment.position.set(-440, 0, -190);
            scene.add(waterTreatment);
            
            // Datacenter internal roads (on industrial ground) - Updated positions
            const internalRoads = [
                // Main datacenter boulevard
                { pos: [-200, 1.1, -110], size: [12, 0.1, 180] },
                // Cross roads
                { pos: [-170, 1.1, -200], size: [60, 0.1, 8] },
                { pos: [-170, 1.1, -140], size: [60, 0.1, 8] },
                { pos: [-170, 1.1, -80], size: [60, 0.1, 8] },
                { pos: [-170, 1.1, -20], size: [60, 0.1, 8] },
                // Connection to bridge
                { pos: [-180, 1.1, -110], size: [80, 0.1, 10] }
            ];
            
            internalRoads.forEach(road => {
                const roadMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(...road.size),
                    new THREE.MeshLambertMaterial({ color: 0x1f2937 })
                );
                roadMesh.position.set(...road.pos);
                roadMesh.receiveShadow = true;
                scene.add(roadMesh);
                
                // Road markings
                if (road.size[0] > road.size[2]) {
                    for (let i = -road.size[0]/2 + 8; i < road.size[0]/2; i += 16) {
                        const marking = new THREE.Mesh(
                            new THREE.BoxGeometry(6, 0.05, 1.5),
                            new THREE.MeshBasicMaterial({ color: 0xfbbf24 })
                        );
                        marking.position.set(road.pos[0] + i, road.pos[1] + 0.05, road.pos[2]);
                        scene.add(marking);
                    }
                } else {
                    for (let i = -road.size[2]/2 + 8; i < road.size[2]/2; i += 16) {
                        const marking = new THREE.Mesh(
                            new THREE.BoxGeometry(1.5, 0.05, 6),
                            new THREE.MeshBasicMaterial({ color: 0xfbbf24 })
                        );
                        marking.position.set(road.pos[0], road.pos[1] + 0.05, road.pos[2] + i);
                        scene.add(marking);
                    }
                }
            });
            
            // Compact parking areas (on industrial ground) - Updated positions
            const parkingAreas = [
                { x: -240, z: -200, width: 25, depth: 20 },
                { x: -240, z: -140, width: 25, depth: 20 },
                { x: -240, z: -80, width: 25, depth: 20 },
                { x: -160, z: -200, width: 20, depth: 15 },
                { x: -160, z: -140, width: 20, depth: 15 },
                { x: -160, z: -80, width: 20, depth: 15 }
            ];
            
            parkingAreas.forEach(area => {
                // Elevated parking on industrial ground
                const elevatedArea = { ...area, y: 1 };
                const parkingLot = createParkingLot(elevatedArea);
                parkingLot.position.y = 1;
                parkingLots.push(parkingLot);
                scene.add(parkingLot);
            });
            
            console.log('🏭 Datacenter industrial zone with proper ground created');
        }
        
        // Add construction elements for phase 2 buildings
        function addConstructionElements(building, height) {
            // Construction crane
            const craneGroup = new THREE.Group();
            
            // Crane mast
            const craneMast = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.5, height + 20, 8),
                new THREE.MeshPhongMaterial({ color: 0xffff00 })
            );
            craneMast.position.set(15, (height + 20) / 2, 15);
            craneGroup.add(craneMast);
            
            // Crane arm
            const craneArm = new THREE.Mesh(
                new THREE.BoxGeometry(30, 1, 1),
                new THREE.MeshPhongMaterial({ color: 0xffff00 })
            );
            craneArm.position.set(0, height + 15, 15);
            craneGroup.add(craneArm);
            
            // Hook
            const hook = new THREE.Mesh(
                new THREE.BoxGeometry(2, 2, 2),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            hook.position.set(-10, height + 5, 15);
            craneGroup.add(hook);
            
            building.add(craneGroup);
            
            // Scaffolding
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2;
                const scaffoldX = Math.cos(angle) * 12;
                const scaffoldZ = Math.sin(angle) * 12;
                
                const scaffold = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, height * 0.8, 0.3),
                    new THREE.MeshPhongMaterial({ color: 0x8b4513 })
                );
                scaffold.position.set(scaffoldX, height * 0.4, scaffoldZ);
                building.add(scaffold);
                
                // Horizontal scaffold bars
                for (let j = 0; j < Math.floor(height / 10); j++) {
                    const bar = new THREE.Mesh(
                        new THREE.BoxGeometry(24, 0.2, 0.2),
                        new THREE.MeshPhongMaterial({ color: 0x8b4513 })
                    );
                    bar.position.set(0, j * 10 + 5, scaffoldZ);
                    building.add(bar);
                }
            }
            
            // Construction materials
            for (let i = 0; i < 3; i++) {
                const material = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 2, 3),
                    new THREE.MeshPhongMaterial({ color: 0x654321 })
                );
                material.position.set(
                    (Math.random() - 0.5) * 15,
                    1,
                    (Math.random() - 0.5) * 15
                );
                building.add(material);
            }
        }

        // Create parking infrastructure
        function createParkingInfrastructure() {
            // 3-story parking garage
            const parkingGarage = createParkingGarage(-50, 50);
            scene.add(parkingGarage);
            
            // Surface parking lots
            const parkingLotPositions = [
                { x: -120, z: 50, width: 40, depth: 30 },
                { x: 120, z: -50, width: 35, depth: 40 },
                { x: 50, z: 50, width: 45, depth: 35 },
                { x: -50, z: -50, width: 40, depth: 40 }
            ];
            
            parkingLotPositions.forEach(lot => {
                const parkingLot = createParkingLot(lot);
                parkingLots.push(parkingLot);
                scene.add(parkingLot);
            });

            // Street parking along main roads
            createStreetParking();
        }

        // Create 3-story parking garage
        function createParkingGarage(x, z) {
            const garage = new THREE.Group();
            
            const width = 50;
            const depth = 40;
            const floorHeight = 4;
            const levels = 3;
            
            // Concrete material
            const concreteMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
            const darkConcrete = new THREE.MeshPhongMaterial({ color: 0x606060 });
            
            // Create each level
            for (let level = 0; level < levels; level++) {
                // Floor
                const floor = new THREE.Mesh(
                    new THREE.BoxGeometry(width, 0.5, depth),
                    concreteMaterial
                );
                floor.position.y = level * floorHeight;
                floor.receiveShadow = true;
                garage.add(floor);
                
                // Pillars
                const pillarGeometry = new THREE.CylinderGeometry(0.5, 0.5, floorHeight);
                const pillarPositions = [
                    { x: -width/2 + 5, z: -depth/2 + 5 },
                    { x: width/2 - 5, z: -depth/2 + 5 },
                    { x: -width/2 + 5, z: depth/2 - 5 },
                    { x: width/2 - 5, z: depth/2 - 5 },
                    { x: 0, z: -depth/2 + 5 },
                    { x: 0, z: depth/2 - 5 },
                    { x: -width/2 + 5, z: 0 },
                    { x: width/2 - 5, z: 0 }
                ];
                
                pillarPositions.forEach(pos => {
                    const pillar = new THREE.Mesh(pillarGeometry, darkConcrete);
                    pillar.position.set(pos.x, level * floorHeight + floorHeight/2, pos.z);
                    pillar.castShadow = true;
                    garage.add(pillar);
                });
                
                // Ramps between levels
                if (level < levels - 1) {
                    const ramp = new THREE.Mesh(
                        new THREE.BoxGeometry(10, 0.5, 20),
                        concreteMaterial
                    );
                    ramp.position.set(-width/2 + 10, level * floorHeight + floorHeight/2, 0);
                    ramp.rotation.x = -0.2;
                    garage.add(ramp);
                }
                
                // Parked cars on each level
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (Math.random() > 0.3) { // 70% occupancy
                            const car = createCar();
                            car.position.set(
                                -width/2 + 10 + col * 7,
                                level * floorHeight + 0.5,
                                -depth/2 + 8 + row * 12
                            );
                            car.rotation.y = row % 2 === 0 ? 0 : Math.PI;
                            garage.add(car);
                        }
                    }
                }
            }
            
            // Entrance/Exit signs
            const signMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const entranceSign = new THREE.Mesh(
                new THREE.BoxGeometry(8, 2, 0.2),
                signMaterial
            );
            entranceSign.position.set(-width/2 - 0.1, 3, 0);
            garage.add(entranceSign);
            
            // Add text (simulated)
            const textGeometry = new THREE.BoxGeometry(6, 1, 0.1);
            const textMesh = new THREE.Mesh(textGeometry, new THREE.MeshBasicMaterial({ color: 0x000000 }));
            textMesh.position.set(-width/2 - 0.2, 3, 0);
            garage.add(textMesh);
            
            garage.position.set(x, 0, z);
            garage.userData = { type: 'parking_garage', capacity: levels * 18 };
            
            return garage;
        }

        // Create surface parking lot
        function createParkingLot(config) {
            const lot = new THREE.Group();
            
            // Asphalt base
            const asphalt = new THREE.Mesh(
                new THREE.BoxGeometry(config.width, 0.1, config.depth),
                new THREE.MeshLambertMaterial({ color: 0x2c2c2c })
            );
            asphalt.receiveShadow = true;
            lot.add(asphalt);
            
            // Parking space markings
            const markingMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const spaceWidth = 3;
            const spaceDepth = 5;
            const rows = Math.floor(config.depth / (spaceDepth * 2));
            const cols = Math.floor(config.width / spaceWidth);
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    // Space lines
                    const lines = [
                        { // Front line
                            size: [spaceWidth, 0.05, 0.1],
                            pos: [
                                -config.width/2 + col * spaceWidth + spaceWidth/2,
                                0.05,
                                -config.depth/2 + row * spaceDepth * 2 + spaceDepth/2
                            ]
                        },
                        { // Side line
                            size: [0.1, 0.05, spaceDepth],
                            pos: [
                                -config.width/2 + col * spaceWidth,
                                0.05,
                                -config.depth/2 + row * spaceDepth * 2 + spaceDepth
                            ]
                        }
                    ];
                    
                    lines.forEach(line => {
                        const marking = new THREE.Mesh(
                            new THREE.BoxGeometry(...line.size),
                            markingMaterial
                        );
                        marking.position.set(...line.pos);
                        lot.add(marking);
                    });
                    
                    // Add parked cars randomly
                    if (Math.random() > 0.4) { // 60% occupancy
                        const car = createCar();
                        car.position.set(
                            -config.width/2 + col * spaceWidth + spaceWidth/2,
                            0.1,
                            -config.depth/2 + row * spaceDepth * 2 + spaceDepth
                        );
                        car.rotation.y = row % 2 === 0 ? 0 : Math.PI;
                        lot.add(car);
                    }
                }
            }
            
            // Light poles
            for (let i = 0; i < 4; i++) {
                const pole = createLightPole();
                pole.position.set(
                    (i % 2 === 0 ? -1 : 1) * config.width/2 * 0.8,
                    0,
                    (i < 2 ? -1 : 1) * config.depth/2 * 0.8
                );
                lot.add(pole);
            }
            
            lot.position.set(config.x, 0, config.z);
            lot.userData = { type: 'parking_lot', capacity: rows * cols };
            
            return lot;
        }

        // Create street parking
        function createStreetParking() {
            const parkingSpaces = [];
            
            // Along main streets
            const streetParkingAreas = [
                { start: -150, end: -30, z: -12, facing: 0 },
                { start: 30, end: 150, z: -12, facing: 0 },
                { start: -150, end: -30, z: 12, facing: Math.PI },
                { start: 30, end: 150, z: 12, facing: Math.PI }
            ];
            
            streetParkingAreas.forEach(area => {
                for (let x = area.start; x <= area.end; x += 8) {
                    if (Math.random() > 0.3) {
                        const car = createCar();
                        car.position.set(x, 0, area.z);
                        car.rotation.y = area.facing;
                        vehicles.push(car);
                        scene.add(car);
                    }
                    
                    // Parking meter
                    if (x % 16 === 0) {
                        const meter = createParkingMeter();
                        meter.position.set(x, 0, area.z + (area.facing === 0 ? -3 : 3));
                        streetFurniture.push(meter);
                        scene.add(meter);
                    }
                }
            });
        }

        // Create car model
        function createCar() {
            const car = new THREE.Group();
            
            const colors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0x000000, 0xffffff, 0xff6600];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            // Car body
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: color });
            
            // Main body
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(4, 1, 2),
                bodyMaterial
            );
            body.position.y = 0.5;
            car.add(body);
            
            // Cabin
            const cabin = new THREE.Mesh(
                new THREE.BoxGeometry(2.5, 0.8, 1.8),
                bodyMaterial
            );
            cabin.position.set(0, 1.2, 0);
            car.add(cabin);
            
            // Windows
            const windowMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x303030,
                transparent: true,
                opacity: 0.6
            });
            
            const frontWindow = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.6, 1.6),
                windowMaterial
            );
            frontWindow.position.set(1.2, 1.2, 0);
            car.add(frontWindow);
            
            const backWindow = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.6, 1.6),
                windowMaterial
            );
            backWindow.position.set(-1.2, 1.2, 0);
            car.add(backWindow);
            
            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            
            const wheelPositions = [
                { x: 1.5, y: 0.3, z: 0.8 },
                { x: 1.5, y: 0.3, z: -0.8 },
                { x: -1.5, y: 0.3, z: 0.8 },
                { x: -1.5, y: 0.3, z: -0.8 }
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.rotation.z = Math.PI / 2;
                car.add(wheel);
            });
            
            // Headlights
            const headlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff99 });
            for (let side = -0.5; side <= 0.5; side += 1) {
                const headlight = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    headlightMaterial
                );
                headlight.position.set(2, 0.5, side);
                car.add(headlight);
            }
            
            return car;
        }

        // Create street furniture
        function createStreetFurniture() {
            // Benches throughout the city
            const benchLocations = [
                { x: -30, z: 30 }, { x: 30, z: 30 },
                { x: -30, z: -30 }, { x: 30, z: -30 },
                { x: -70, z: 0 }, { x: 70, z: 0 },
                { x: 0, z: -70 }, { x: 0, z: 70 },
                { x: -130, z: 60 }, { x: 130, z: -60 },
                { x: -60, z: 130 }, { x: 60, z: -130 }
            ];
            
            benchLocations.forEach(loc => {
                const bench = createBench();
                bench.position.set(loc.x, 0, loc.z);
                bench.rotation.y = Math.random() * Math.PI;
                streetFurniture.push(bench);
                scene.add(bench);
            });
            
            // Trash bins
            const trashLocations = [
                { x: -25, z: 25 }, { x: 25, z: 25 },
                { x: -25, z: -25 }, { x: 25, z: -25 },
                { x: -100, z: 0 }, { x: 100, z: 0 },
                { x: 0, z: -100 }, { x: 0, z: 100 },
                { x: -140, z: 70 }, { x: 140, z: -70 }
            ];
            
            trashLocations.forEach(loc => {
                const trashBin = createTrashBin();
                trashBin.position.set(loc.x, 0, loc.z);
                streetFurniture.push(trashBin);
                scene.add(trashBin);
            });
            
            // Bus stops
            const busStopLocations = [
                { x: -100, z: -50, rotation: 0 },
                { x: 100, z: 50, rotation: Math.PI },
                { x: -50, z: 100, rotation: Math.PI/2 },
                { x: 50, z: -100, rotation: -Math.PI/2 }
            ];
            
            busStopLocations.forEach(loc => {
                const busStop = createBusStop();
                busStop.position.set(loc.x, 0, loc.z);
                busStop.rotation.y = loc.rotation;
                streetFurniture.push(busStop);
                scene.add(busStop);
            });
        }

        // Create bench
        function createBench() {
            const bench = new THREE.Group();
            
            const woodMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
            const metalMaterial = new THREE.MeshPhongMaterial({ color: 0x404040 });
            
            // Seat
            const seat = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.3, 1),
                woodMaterial
            );
            seat.position.y = 1;
            bench.add(seat);
            
            // Back
            const back = new THREE.Mesh(
                new THREE.BoxGeometry(4, 1.2, 0.2),
                woodMaterial
            );
            back.position.set(0, 1.6, -0.4);
            bench.add(back);
            
            // Legs
            const legPositions = [
                { x: -1.8, z: 0.3 },
                { x: 1.8, z: 0.3 },
                { x: -1.8, z: -0.3 },
                { x: 1.8, z: -0.3 }
            ];
            
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 1, 8),
                    metalMaterial
                );
                leg.position.set(pos.x, 0.5, pos.z);
                bench.add(leg);
            });
            
            // Armrests
            for (let side = -1; side <= 1; side += 2) {
                const armrest = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.8, 1),
                    metalMaterial
                );
                armrest.position.set(side * 2, 1.2, 0);
                bench.add(armrest);
            }
            
            return bench;
        }

        // Create trash bin
        function createTrashBin() {
            const bin = new THREE.Group();
            
            // Main cylinder
            const binBody = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.6, 1.5, 12),
                new THREE.MeshPhongMaterial({ color: 0x2f4f2f })
            );
            binBody.position.y = 0.75;
            bin.add(binBody);
            
            // Lid
            const lid = new THREE.Mesh(
                new THREE.CylinderGeometry(0.6, 0.5, 0.2, 12),
                new THREE.MeshPhongMaterial({ color: 0x1c1c1c })
            );
            lid.position.y = 1.6;
            bin.add(lid);
            
            // Opening
            const opening = new THREE.Mesh(
                new THREE.TorusGeometry(0.3, 0.1, 8, 12),
                new THREE.MeshPhongMaterial({ color: 0x000000 })
            );
            opening.position.y = 1.7;
            opening.rotation.x = Math.PI / 2;
            bin.add(opening);
            
            return bin;
        }

        // Create bus stop
        function createBusStop() {
            const busStop = new THREE.Group();
            
            const metalMaterial = new THREE.MeshPhongMaterial({ color: 0x606060 });
            const glassMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.3
            });
            
            // Support posts
            const postPositions = [
                { x: -2, z: -0.5 },
                { x: 2, z: -0.5 },
                { x: -2, z: 0.5 },
                { x: 2, z: 0.5 }
            ];
            
            postPositions.forEach(pos => {
                const post = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 3, 8),
                    metalMaterial
                );
                post.position.set(pos.x, 1.5, pos.z);
                busStop.add(post);
            });
            
            // Roof
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(5, 0.2, 2),
                metalMaterial
            );
            roof.position.y = 3;
            busStop.add(roof);
            
            // Back panel
            const backPanel = new THREE.Mesh(
                new THREE.BoxGeometry(4.5, 2.5, 0.1),
                glassMaterial
            );
            backPanel.position.set(0, 1.5, -0.5);
            busStop.add(backPanel);
            
            // Side panels
            for (let side = -1; side <= 1; side += 2) {
                const sidePanel = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 2.5, 1),
                    glassMaterial
                );
                sidePanel.position.set(side * 2.25, 1.5, 0);
                busStop.add(sidePanel);
            }
            
            // Bench
            const benchSeat = new THREE.Mesh(
                new THREE.BoxGeometry(3.5, 0.2, 0.8),
                new THREE.MeshPhongMaterial({ color: 0x8b4513 })
            );
            benchSeat.position.set(0, 0.8, 0);
            busStop.add(benchSeat);
            
            // Sign post
            const signPost = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 4, 8),
                metalMaterial
            );
            signPost.position.set(2.5, 2, 0);
            busStop.add(signPost);
            
            // Bus stop sign
            const sign = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 0.1),
                new THREE.MeshPhongMaterial({ color: 0x0000ff })
            );
            sign.position.set(2.5, 3.5, 0);
            busStop.add(sign);
            
            return busStop;
        }

        // Create infrastructure elements
        function createInfrastructure() {
            // Street lights every 40m
            const streetLightPositions = [];
            
            // Along main roads
            for (let i = -200; i <= 200; i += 40) {
                // Vertical roads
                streetLightPositions.push({ x: -15, z: i });
                streetLightPositions.push({ x: 15, z: i });
                streetLightPositions.push({ x: -105, z: i });
                streetLightPositions.push({ x: 105, z: i });
                
                // Horizontal roads
                if (Math.abs(i) > 20) {
                    streetLightPositions.push({ x: i, z: -15 });
                    streetLightPositions.push({ x: i, z: 15 });
                    streetLightPositions.push({ x: i, z: -105 });
                    streetLightPositions.push({ x: i, z: 105 });
                }
            }
            
            streetLightPositions.forEach(pos => {
                const light = createStreetLight();
                light.position.set(pos.x, 0, pos.z);
                lights.push(light);
                scene.add(light);
            });
            
            // Traffic lights at major intersections
            const intersections = [
                { x: -100, z: -100 },
                { x: 100, z: -100 },
                { x: -100, z: 100 },
                { x: 100, z: 100 },
                { x: 0, z: -100 },
                { x: 0, z: 100 },
                { x: -100, z: 0 },
                { x: 100, z: 0 }
            ];
            
            intersections.forEach(pos => {
                const trafficLight = createTrafficLight();
                trafficLight.position.set(pos.x + 10, 0, pos.z + 10);
                lights.push(trafficLight);
                scene.add(trafficLight);
            });
            
            // EV charging stations
            const chargingStations = [
                { x: -70, z: -70, rotation: 0 },
                { x: 70, z: 70, rotation: Math.PI },
                { x: -70, z: 70, rotation: Math.PI/2 },
                { x: 70, z: -70, rotation: -Math.PI/2 }
            ];
            
            chargingStations.forEach(station => {
                const charger = createEVChargingStation();
                charger.position.set(station.x, 0, station.z);
                charger.rotation.y = station.rotation;
                streetFurniture.push(charger);
                scene.add(charger);
            });
        }

        // Create street light
        function createStreetLight() {
            const streetLight = new THREE.Group();
            
            // Pole
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.2, 8, 8),
                new THREE.MeshPhongMaterial({ color: 0x404040 })
            );
            pole.position.y = 4;
            pole.castShadow = true;
            streetLight.add(pole);
            
            // Arm
            const arm = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.2, 0.2),
                new THREE.MeshPhongMaterial({ color: 0x404040 })
            );
            arm.position.set(1, 7.5, 0);
            streetLight.add(arm);
            
            // Light fixture
            const fixture = new THREE.Mesh(
                new THREE.ConeGeometry(0.5, 1, 8),
                new THREE.MeshPhongMaterial({ color: 0x606060 })
            );
            fixture.position.set(2, 7.5, 0);
            fixture.rotation.z = -Math.PI / 6;
            streetLight.add(fixture);
            
            // Light bulb (emissive)
            const bulb = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 8, 8),
                new THREE.MeshBasicMaterial({ 
                    color: 0xffffcc,
                    emissive: 0xffffcc,
                    emissiveIntensity: 0.5
                })
            );
            bulb.position.set(2, 7.3, 0);
            streetLight.add(bulb);
            
            // Add actual light source
            const pointLight = new THREE.PointLight(0xffffcc, 0.5, 20);
            pointLight.position.set(2, 7.3, 0);
            streetLight.add(pointLight);
            
            return streetLight;
        }

        // Create light pole for parking lots
        function createLightPole() {
            const pole = new THREE.Group();
            
            // Main pole
            const poleGeometry = new THREE.CylinderGeometry(0.2, 0.3, 10, 8);
            const poleMaterial = new THREE.MeshPhongMaterial({ color: 0x404040 });
            const poleMesh = new THREE.Mesh(poleGeometry, poleMaterial);
            poleMesh.position.y = 5;
            pole.add(poleMesh);
            
            // Light fixtures (4 directions)
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2;
                
                // Arm
                const arm = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 0.2, 0.2),
                    poleMaterial
                );
                arm.position.set(
                    Math.cos(angle) * 0.75,
                    9.5,
                    Math.sin(angle) * 0.75
                );
                arm.rotation.y = angle;
                pole.add(arm);
                
                // Light
                const light = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.4, 0.4),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffffcc,
                        emissive: 0xffffcc
                    })
                );
                light.position.set(
                    Math.cos(angle) * 1.5,
                    9.5,
                    Math.sin(angle) * 1.5
                );
                pole.add(light);
            }
            
            return pole;
        }

        // Create traffic light
        function createTrafficLight() {
            const trafficLight = new THREE.Group();
            
            // Pole
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 6, 8),
                new THREE.MeshPhongMaterial({ color: 0x404040 })
            );
            pole.position.y = 3;
            trafficLight.add(pole);
            
            // Light box
            const box = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 2.4, 0.8),
                new THREE.MeshPhongMaterial({ color: 0x2c2c2c })
            );
            box.position.y = 6.5;
            trafficLight.add(box);
            
            // Lights
            const lightColors = [0xff0000, 0xffff00, 0x00ff00];
            const lightPositions = [7.3, 6.5, 5.7];
            
            lightColors.forEach((color, index) => {
                const light = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    new THREE.MeshBasicMaterial({ 
                        color: color,
                        emissive: index === 2 ? color : 0x000000,
                        emissiveIntensity: 0.5
                    })
                );
                light.position.set(0.4, lightPositions[index], 0);
                trafficLight.add(light);
            });
            
            return trafficLight;
        }

        // Create EV charging station
        function createEVChargingStation() {
            const station = new THREE.Group();
            
            // Main unit
            const unit = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 3, 0.8),
                new THREE.MeshPhongMaterial({ color: 0x32cd32 })
            );
            unit.position.y = 1.5;
            station.add(unit);
            
            // Screen
            const screen = new THREE.Mesh(
                new THREE.BoxGeometry(1, 0.8, 0.1),
                new THREE.MeshPhongMaterial({ 
                    color: 0x000000,
                    emissive: 0x0066ff,
                    emissiveIntensity: 0.3
                })
            );
            screen.position.set(0, 2, 0.41);
            station.add(screen);
            
            // Charging cable
            const cable = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 2, 8),
                new THREE.MeshPhongMaterial({ color: 0x000000 })
            );
            cable.position.set(0.6, 1, 0.4);
            cable.rotation.z = 0.3;
            station.add(cable);
            
            // Connector
            const connector = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.2, 0.2),
                new THREE.MeshPhongMaterial({ color: 0x404040 })
            );
            connector.position.set(0.8, 0.2, 0.4);
            station.add(connector);
            
            // Status light
            const statusLight = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 8, 8),
                new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.5
                })
            );
            statusLight.position.set(0, 2.8, 0.4);
            station.add(statusLight);
            
            // Base
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.2, 1.2),
                new THREE.MeshPhongMaterial({ color: 0x606060 })
            );
            base.position.y = 0.1;
            station.add(base);
            
            return station;
        }

        // Create parking meter
        function createParkingMeter() {
            const meter = new THREE.Group();
            
            // Post
            const post = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8),
                new THREE.MeshPhongMaterial({ color: 0x606060 })
            );
            post.position.y = 0.75;
            meter.add(post);
            
            // Meter head
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.5, 0.3),
                new THREE.MeshPhongMaterial({ color: 0x404040 })
            );
            head.position.y = 1.5;
            meter.add(head);
            
            // Display
            const display = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.2, 0.05),
                new THREE.MeshPhongMaterial({ color: 0x000000 })
            );
            display.position.set(0, 1.5, 0.16);
            meter.add(display);
            
            // Coin slot
            const slot = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.02, 0.05),
                new THREE.MeshPhongMaterial({ color: 0x2c2c2c })
            );
            slot.position.set(0, 1.3, 0.16);
            meter.add(slot);
            
            return meter;
        }

        // Create water features - REMOVED central water features to avoid confusion with rivers
        function createWaterFeatures() {
            // Remove small ponds in parks to avoid creating river-like appearance in city center
            // parks.forEach((park, index) => {
            //     if (index > 0 && index < 4) { // Add to 3 small parks
            //         const pond = createPond();
            //         pond.position.copy(park.position);
            //         pond.position.x += 15;
            //         pond.position.z += 10;
            //         waterFeatures.push(pond);
            //         scene.add(pond);
            //     }
            // });
            
            // Remove decorative fountains in city to avoid river confusion
            // const fountainLocations = [
            //     { x: -130, z: -130 },
            //     { x: 130, z: 130 },
            //     { x: -130, z: 130 },
            //     { x: 130, z: -130 }
            // ];
            
            // fountainLocations.forEach(loc => {
            //     const fountain = createDecorativeFountain();
            //     fountain.position.set(loc.x, 0, loc.z);
            //     waterFeatures.push(fountain);
            //     scene.add(fountain);
            // });
        }

        // Create pond
        function createPond() {
            const pond = new THREE.Group();
            
            // Water surface
            const waterGeometry = new THREE.CircleGeometry(8, 32);
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = 0.1;
            pond.add(water);
            
            // Pond edge
            const edgeGeometry = new THREE.TorusGeometry(8, 0.5, 8, 32);
            const edgeMaterial = new THREE.MeshPhongMaterial({ color: 0x8b7355 });
            const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
            edge.rotation.x = -Math.PI / 2;
            edge.position.y = 0.3;
            pond.add(edge);
            
            // Decorative rocks
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(0.5 + Math.random() * 0.5),
                    new THREE.MeshPhongMaterial({ color: 0x696969 })
                );
                rock.position.set(
                    Math.cos(angle) * 7.5,
                    0.3,
                    Math.sin(angle) * 7.5
                );
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                pond.add(rock);
            }
            
            // Lily pads
            const lilyPadMaterial = new THREE.MeshPhongMaterial({ color: 0x228b22 });
            for (let i = 0; i < 5; i++) {
                const lilyPad = new THREE.Mesh(
                    new THREE.CircleGeometry(0.8, 16),
                    lilyPadMaterial
                );
                lilyPad.rotation.x = -Math.PI / 2;
                lilyPad.position.set(
                    (Math.random() - 0.5) * 12,
                    0.15,
                    (Math.random() - 0.5) * 12
                );
                pond.add(lilyPad);
            }
            
            return pond;
        }

        // Create decorative fountain
        function createDecorativeFountain() {
            const fountain = new THREE.Group();
            
            // Base pool
            const poolGeometry = new THREE.CylinderGeometry(5, 6, 1, 32);
            const poolMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
            const pool = new THREE.Mesh(poolGeometry, poolMaterial);
            pool.position.y = 0.5;
            fountain.add(pool);
            
            // Water in pool
            const poolWater = new THREE.Mesh(
                new THREE.CylinderGeometry(4.8, 5.8, 0.8, 32),
                new THREE.MeshPhongMaterial({
                    color: 0x006994,
                    transparent: true,
                    opacity: 0.8,
                    shininess: 100
                })
            );
            poolWater.position.y = 0.6;
            fountain.add(poolWater);
            
            // Central column
            const column = new THREE.Mesh(
                new THREE.CylinderGeometry(0.8, 1, 3, 16),
                new THREE.MeshPhongMaterial({ color: 0xa0a0a0 })
            );
            column.position.y = 2;
            fountain.add(column);
            
            // Top tier
            const topTier = new THREE.Mesh(
                new THREE.CylinderGeometry(2, 2.5, 0.5, 16),
                poolMaterial
            );
            topTier.position.y = 3.5;
            fountain.add(topTier);
            
            // Water jets
            const jetMaterial = new THREE.MeshPhongMaterial({
                color: 0x4682b4,
                transparent: true,
                opacity: 0.6
            });
            
            // Central jet
            const centralJet = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.3, 2, 8),
                jetMaterial
            );
            centralJet.position.y = 4.5;
            fountain.add(centralJet);
            
            // Side jets
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const sideJet = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.15, 1.5, 8),
                    jetMaterial
                );
                sideJet.position.set(
                    Math.cos(angle) * 1.5,
                    3.8,
                    Math.sin(angle) * 1.5
                );
                sideJet.rotation.z = -0.3;
                sideJet.rotation.y = angle;
                fountain.add(sideJet);
            }
            
            return fountain;
        }

        // Keyboard handler for camera and phase shortcuts
        function onKeyDown(event) {
            switch(event.key) {
                case '1':
                    setCameraView('aerial');
                    break;
                case '2':
                    setCameraView('street');
                    break;
                case '3':
                    setCameraView('birdseye');
                    break;
                case '4':
                    setCameraView('cinematic');
                    break;
                case '5':
                    setCameraView('datacenter');
                    break;
                case '6':
                    togglePhase('phase1');
                    break;
                case '7':
                    togglePhase('phase2');
                    break;
                case '8':
                    togglePhase('phase3');
                    break;
            }
        }

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Mouse click handler
        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(buildings.map(b => b.children[0]));

            if (intersects.length > 0) {
                const building = intersects[0].object.parent;
                if (building.userData.type) {
                    showBuildingInfo(building);
                }
            } else {
                hideBuildingInfo();
            }
        }

        // Mouse move handler
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        // Show building information popup
        function showBuildingInfo(building) {
            const info = building.userData;
            const popup = document.getElementById('buildingInfoPopup');
            
            // Update popup content
            document.getElementById('buildingIcon').textContent = info.icon || '🏢';
            document.getElementById('buildingTitle').textContent = info.name || 'Building Information';
            document.getElementById('buildingType').textContent = info.type || '-';
            document.getElementById('buildingHeight').textContent = info.height ? `${info.height}m` : '-';
            document.getElementById('buildingFloors').textContent = info.floors || '-';
            
            // Update features list
            const featuresList = document.getElementById('buildingFeatures');
            featuresList.innerHTML = '';
            if (info.features && info.features.length > 0) {
                info.features.forEach(feature => {
                    const li = document.createElement('li');
                    li.textContent = feature;
                    featuresList.appendChild(li);
                });
            } else {
                const li = document.createElement('li');
                li.textContent = 'Standard features';
                featuresList.appendChild(li);
            }
            
            // Update phase status
            const phaseElement = document.getElementById('buildingPhase');
            if (info.phase) {
                phaseElement.className = `info-value phase-status ${info.phase}`;
                switch(info.phase) {
                    case 'phase1':
                        phaseElement.textContent = 'HEART CORE - Hoàn thành';
                        break;
                    case 'phase2':
                        phaseElement.textContent = 'TECHNOLOGY HUB - Đang xây dựng';
                        break;
                    case 'phase3':
                        phaseElement.textContent = 'INNOVATION DISTRICT - Dự kiến';
                        break;
                    default:
                        phaseElement.textContent = 'Unknown Phase';
                }
            } else {
                phaseElement.className = 'info-value phase-status';
                phaseElement.textContent = '-';
            }
            
            // Show popup with animation
            popup.classList.add('show');
            
            // Highlight building
            if (selectedObject) {
                // Remove previous highlight
                selectedObject.traverse(child => {
                    if (child.isMesh && child.userData.originalMaterial) {
                        child.material = child.userData.originalMaterial;
                    }
                });
            }
            
            selectedObject = building;
            building.traverse(child => {
                if (child.isMesh) {
                    child.userData.originalMaterial = child.material;
                    const highlightMaterial = child.material.clone();
                    highlightMaterial.emissive = new THREE.Color(0x444444);
                    highlightMaterial.emissiveIntensity = 0.3;
                    child.material = highlightMaterial;
                }
            });
        }

        // Hide building information popup
        function hideBuildingInfo() {
            const popup = document.getElementById('buildingInfoPopup');
            popup.classList.remove('show');
            
            // Remove building highlight
            if (selectedObject) {
                selectedObject.traverse(child => {
                    if (child.isMesh && child.userData.originalMaterial) {
                        child.material = child.userData.originalMaterial;
                    }
                });
                selectedObject = null;
            }
        }

        // Toggle wireframe mode
        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            
            scene.traverse(child => {
                if (child.isMesh) {
                    child.material.wireframe = wireframeMode;
                }
            });
        }

        // Toggle landscape mode
        function toggleLandscapeMode() {
            landscapeMode = !landscapeMode;
            
            // Highlight trees and parks
            trees.forEach(tree => {
                tree.traverse(child => {
                    if (child.isMesh && child.material.color) {
                        if (landscapeMode) {
                            child.material.emissive = new THREE.Color(0x00ff00);
                            child.material.emissiveIntensity = 0.3;
                        } else {
                            child.material.emissive = new THREE.Color(0x000000);
                            child.material.emissiveIntensity = 0;
                        }
                    }
                });
            });
            
            parks.forEach(park => {
                park.traverse(child => {
                    if (child.isMesh && child.material.color) {
                        const isGreen = child.material.color.getHex() === 0x228b22 || 
                                       child.material.color.getHex() === 0x2d5016;
                        if (isGreen) {
                            if (landscapeMode) {
                                child.material.emissive = new THREE.Color(0x00ff00);
                                child.material.emissiveIntensity = 0.2;
                            } else {
                                child.material.emissive = new THREE.Color(0x000000);
                                child.material.emissiveIntensity = 0;
                            }
                        }
                    }
                });
            });
        }

        // Set time of day
        function setTimeOfDay(time) {
            timeOfDay = time;
            
            // Update button states
            document.querySelectorAll('.time-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update lighting and sky
            switch(time) {
                case 'morning':
                    scene.background.setHex(0x87CEEB);
                    updateLighting(0.6, 0.8, 0xffffff);
                    break;
                case 'noon':
                    scene.background.setHex(0x87CEEB);
                    updateLighting(0.8, 1.0, 0xffffff);
                    break;
                case 'evening':
                    scene.background.setHex(0xff6b35);
                    updateLighting(0.4, 0.6, 0xffa500);
                    break;
                case 'night':
                    scene.background.setHex(0x191970);
                    updateLighting(0.2, 0.3, 0x6495ed);
                    
                    // Turn on street lights
                    lights.forEach(light => {
                        light.traverse(child => {
                            if (child.isLight) {
                                child.intensity = 1.0;
                            }
                        });
                    });
                    break;
            }
        }

        // Update lighting
        function updateLighting(ambientIntensity, directionalIntensity, color) {
            scene.traverse(child => {
                if (child.isLight) {
                    if (child.type === 'AmbientLight') {
                        child.intensity = ambientIntensity;
                        child.color.setHex(color);
                    } else if (child.type === 'DirectionalLight') {
                        child.intensity = directionalIntensity;
                        child.color.setHex(color);
                    }
                }
            });
        }


        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            if (controls) {
                controls.update();
            }
            
            // Animate water features và cooling effects
            waterFeatures.forEach(feature => {
                feature.children.forEach(child => {
                    if (child.material && child.material.color.getHex() === 0x006994) {
                        child.rotation.z += 0.001;
                    }
                });
            });
            
            // Animate river flow
            scene.traverse(child => {
                if (child.name === 'river-ripple') {
                    child.rotation.z += 0.002;
                    child.material.opacity = 0.3 + Math.sin(Date.now() * 0.001) * 0.1;
                }
            });
            
            // Animate cooling lake
            scene.traverse(child => {
                if (child.name === 'cooling-lake') {
                    child.rotation.y += 0.0005;
                }
            });
            
            
            // Render scene
            renderer.render(scene, camera);
        }

        // Check WebGL support
        function checkWebGLSupport() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) {
                    throw new Error('WebGL không được hỗ trợ');
                }
                return true;
            } catch (e) {
                return false;
            }
        }

        // Initialize on load - using window.onload to ensure all scripts are loaded
        function attemptInitialization() {
            console.log('🚀 Attempting to initialize 3D Smart City...');
            
            initializeLoading();
            
            if (!checkWebGLSupport()) {
                showError('Trình duyệt của bạn không hỗ trợ WebGL. Vui lòng sử dụng trình duyệt hiện đại.');
                return;
            }
            
            // Check if Three.js loaded
            if (typeof THREE === 'undefined') {
                console.error('❌ Three.js not loaded yet');
                showError('Không thể tải Three.js. Vui lòng kiểm tra kết nối internet.');
                return;
            }
            
            // Check if OrbitControls loaded
            if (typeof THREE.OrbitControls === 'undefined') {
                console.error('❌ OrbitControls not loaded yet');
                showError('Không thể tải OrbitControls. Vui lòng kiểm tra kết nối internet.');
                return;
            }
            
            console.log('✅ All dependencies loaded successfully');
            
            // Start initialization with error handling
            init().catch(error => {
                console.error('Initialization error:', error);
                showError('Lỗi khởi tạo: ' + error.message);
            });
        }
        
        // Try multiple initialization strategies
        window.onload = () => {
            console.log('📄 Window loaded, attempting initialization...');
            attemptInitialization();
        };
        
        // Also try when DOM is ready (as backup)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('📄 DOM loaded, scheduling initialization check...');
                // Give scripts time to load
                setTimeout(() => {
                    if (typeof THREE === 'undefined' || typeof THREE.OrbitControls === 'undefined') {
                        console.log('⏳ Dependencies not ready, waiting for window.onload...');
                    }
                }, 1000);
            });
        }

        // Toggle info panel visibility
        function toggleInfoPanel() {
            const panel = document.getElementById('info-panel');
            const toggleBtn = document.querySelector('.panel-toggle');
            
            if (panel.classList.contains('hidden')) {
                // Show panel
                panel.classList.remove('hidden');
                toggleBtn.classList.remove('panel-hidden');
                toggleBtn.innerHTML = '✖';
                toggleBtn.title = 'Ẩn bảng thông tin';
            } else {
                // Hide panel
                panel.classList.add('hidden');
                toggleBtn.classList.add('panel-hidden');
                toggleBtn.innerHTML = '☰';
                toggleBtn.title = 'Hiện bảng thông tin';
            }
        }

        // Camera view positions and targets
        const cameraViews = {
            aerial: {
                position: { x: 200, y: 300, z: 200 },
                target: { x: 0, y: 0, z: 0 },
                name: 'Aerial View'
            },
            street: {
                position: { x: -50, y: 8, z: 50 },
                target: { x: 50, y: 5, z: -50 },
                name: 'Street View'
            },
            birdseye: {
                position: { x: 0, y: 250, z: 0 },
                target: { x: 0, y: 0, z: 0 },
                name: "Bird's Eye View"
            },
            cinematic: {
                position: { x: 150, y: 100, z: 150 },
                target: { x: 0, y: 0, z: 0 },
                name: 'Cinematic View'
            },
            datacenter: {
                position: { x: -100, y: 180, z: -50 },
                target: { x: -320, y: 20, z: -120 },
                name: 'Datacenter Complex View'
            }
        };

        // Smooth camera animation function
        function animateCamera(targetPos, targetLookAt, duration = 2000) {
            if (cameraAnimation) {
                cancelAnimationFrame(cameraAnimation);
            }
            
            const startPos = camera.position.clone();
            const startLookAt = controls.target.clone();
            const startTime = performance.now();
            
            function animate() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Smooth easing function
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                // Interpolate position
                camera.position.lerpVectors(startPos, targetPos, easeProgress);
                
                // Interpolate look-at target
                const currentTarget = new THREE.Vector3().lerpVectors(startLookAt, targetLookAt, easeProgress);
                controls.target.copy(currentTarget);
                controls.update();
                
                if (progress < 1) {
                    cameraAnimation = requestAnimationFrame(animate);
                } else {
                    cameraAnimation = null;
                }
            }
            
            animate();
        }

        // Set camera view function
        function setCameraView(viewName) {
            // Stop cinematic mode if active
            if (isCinematicMode) {
                isCinematicMode = false;
            }
            
            const view = cameraViews[viewName];
            if (!view) return;
            
            // Update button states
            document.querySelectorAll('.camera-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(viewName + 'ViewBtn').classList.add('active');
            
            currentCameraView = viewName;
            
            const targetPos = new THREE.Vector3(view.position.x, view.position.y, view.position.z);
            const targetLookAt = new THREE.Vector3(view.target.x, view.target.y, view.target.z);
            
            // Special handling for cinematic view
            if (viewName === 'cinematic') {
                startCinematicMode();
            } else {
                animateCamera(targetPos, targetLookAt);
            }
            
            console.log(`🎥 Switched to ${view.name}`);
        }

        // Cinematic mode with orbital rotation and dynamic targets
        function startCinematicMode() {
            isCinematicMode = true;
            cinematicRotation = 0;
            
            function cinematicLoop() {
                if (!isCinematicMode) return;
                
                cinematicRotation += 0.003; // Slower, more cinematic
                const radius = 180 + Math.sin(cinematicRotation * 0.3) * 50;
                const height = 100 + Math.sin(cinematicRotation * 0.7) * 30;
                
                const x = Math.cos(cinematicRotation) * radius;
                const z = Math.sin(cinematicRotation) * radius;
                const y = height;
                
                // Dynamic target points for more interesting shots
                const targetX = Math.sin(cinematicRotation * 0.5) * 50;
                const targetZ = Math.cos(cinematicRotation * 0.3) * 50;
                const targetY = Math.sin(cinematicRotation * 0.8) * 10;
                
                camera.position.set(x, y, z);
                controls.target.set(targetX, targetY, targetZ);
                controls.update();
                
                requestAnimationFrame(cinematicLoop);
            }
            
            cinematicLoop();
        }
        
        // Toggle building phase visibility
        function togglePhase(phaseName) {
            const phase = buildingPhases[phaseName];
            const button = document.getElementById(phaseName + 'Btn');
            
            // Toggle visibility
            phase.visible = !phase.visible;
            
            // Update button appearance
            if (phase.visible) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
            
            // Animate buildings visibility
            phase.buildings.forEach(building => {
                if (phase.visible) {
                    // Fade in
                    building.visible = true;
                    animateBuildingOpacity(building, 0, 1, 500);
                } else {
                    // Fade out
                    animateBuildingOpacity(building, 1, 0, 500, () => {
                        building.visible = false;
                    });
                }
            });
            
            console.log(`🏗️ ${phaseName} ${phase.visible ? 'shown' : 'hidden'}`);
        }
        
        // Animate building opacity
        function animateBuildingOpacity(building, fromOpacity, toOpacity, duration, callback) {
            const startTime = performance.now();
            
            function animate() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const currentOpacity = fromOpacity + (toOpacity - fromOpacity) * progress;
                
                // Apply opacity to all materials in the building
                building.traverse(child => {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.transparent = true;
                                mat.opacity = currentOpacity;
                            });
                        } else {
                            child.material.transparent = true;
                            child.material.opacity = currentOpacity;
                        }
                    }
                });
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else if (callback) {
                    callback();
                }
            }
            
            animate();
        }
        
        // Show all building phases
        function showAllPhases() {
            const button = document.getElementById('showAllBtn');
            const allPhases = ['phase1', 'phase2', 'phase3'];
            
            // Check if all phases are currently visible
            const allVisible = allPhases.every(phase => buildingPhases[phase].visible);
            
            if (allVisible) {
                // Hide all phases
                allPhases.forEach(phaseName => {
                    const phase = buildingPhases[phaseName];
                    const phaseButton = document.getElementById(phaseName + 'Btn');
                    
                    phase.visible = false;
                    phaseButton.classList.remove('active');
                    
                    // Fade out buildings
                    phase.buildings.forEach(building => {
                        animateBuildingOpacity(building, 1, 0, 500, () => {
                            building.visible = false;
                        });
                    });
                });
                
                button.textContent = 'SHOW ALL PHASES';
                button.innerHTML = '<span class="phase-indicator phase-all" style="background: linear-gradient(to right, #4682B4 0%, #FF8C00 50%, #32CD32 100%); width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>SHOW ALL PHASES';
                button.classList.remove('active');
                console.log('🏗️ All phases hidden');
            } else {
                // Show all phases
                allPhases.forEach(phaseName => {
                    const phase = buildingPhases[phaseName];
                    const phaseButton = document.getElementById(phaseName + 'Btn');
                    
                    if (!phase.visible) {
                        phase.visible = true;
                        phaseButton.classList.add('active');
                        
                        // Fade in buildings
                        phase.buildings.forEach(building => {
                            building.visible = true;
                            animateBuildingOpacity(building, 0, 1, 500);
                        });
                    }
                });
                
                button.textContent = 'HIDE ALL PHASES';
                button.innerHTML = '<span class="phase-indicator phase-all" style="background: linear-gradient(to right, #4682B4 0%, #FF8C00 50%, #32CD32 100%); width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>HIDE ALL PHASES';
                button.classList.add('active');
                console.log('🏗️ All phases shown');
            }
        }

        // Global function references for onclick handlers
        window.setTimeOfDay = setTimeOfDay;
        window.toggleWireframe = toggleWireframe;
        window.toggleLandscapeMode = toggleLandscapeMode;
        window.toggleInfoPanel = toggleInfoPanel;
        window.setCameraView = setCameraView;
        window.togglePhase = togglePhase;
        window.showAllPhases = showAllPhases;
        
        // Initialize popup close button
        document.addEventListener('DOMContentLoaded', () => {
            const popupCloseBtn = document.getElementById('popupCloseBtn');
            if (popupCloseBtn) {
                popupCloseBtn.addEventListener('click', hideBuildingInfo);
            }
            
            // Also close popup when clicking outside
            document.addEventListener('click', (event) => {
                const popup = document.getElementById('buildingInfoPopup');
                const isClickOnBuilding = event.target.tagName === 'CANVAS';
                const isClickInsidePopup = popup.contains(event.target);
                
                if (!isClickOnBuilding && !isClickInsidePopup && popup.classList.contains('show')) {
                    hideBuildingInfo();
                }
            });
        });
    </script>
</body>
</html>