<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Smart City - HEART Technology Park - v2.0</title>
    <meta name="description" content="Explore HEART Technology Park in immersive 3D - Vietnam's premier AI innovation hub">
    
    <!-- CSS Files -->
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/animations.css">
    <link rel="stylesheet" href="css/responsive.css">
    
    <!-- Preload fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    
    <!-- CRITICAL: Load THREE.js in head with multiple fallbacks -->
    <script>
        // THREE.js loader with multiple CDN fallbacks
        window.THREE_LOADED = false;
        window.THREE_CDN_URLS = [
            'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
            'https://unpkg.com/three@0.128.0/build/three.min.js',
            'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js',
            'https://threejs.org/build/three.min.js'
        ];
        
        function loadThreeJS(index = 0) {
            if (index >= window.THREE_CDN_URLS.length) {
                console.error('❌ All THREE.js CDN attempts failed');
                document.addEventListener('DOMContentLoaded', () => {
                    if (typeof showError === 'function') {
                        showError('Cannot load 3D library. Please check your internet connection and try again.');
                    } else {
                        alert('Cannot load 3D library. Please check your internet connection.');
                    }
                });
                return;
            }
            
            const script = document.createElement('script');
            script.src = window.THREE_CDN_URLS[index];
            
            script.onload = function() {
                if (typeof THREE !== 'undefined') {
                    window.THREE_LOADED = true;
                    console.log(`✅ THREE.js loaded successfully from CDN ${index + 1}`);
                    console.log(`   Version: ${THREE.REVISION}`);
                    // Dispatch custom event to notify THREE.js is ready
                    window.dispatchEvent(new Event('threejs-loaded'));
                } else {
                    console.error(`❌ THREE.js loaded but THREE is undefined from CDN ${index + 1}`);
                    loadThreeJS(index + 1);
                }
            };
            
            script.onerror = function() {
                console.error(`❌ Failed to load THREE.js from CDN ${index + 1}: ${window.THREE_CDN_URLS[index]}`);
                loadThreeJS(index + 1);
            };
            
            document.head.appendChild(script);
        }
        
        // Start loading THREE.js immediately
        loadThreeJS();
    </script>
    
    <!-- 3D Smart City Specific Styles -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #87CEEB 100%);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: relative;
            margin: 0;
            padding: 0;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s ease;
        }

        .loading-content {
            text-align: center;
            color: white;
        }

        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top: 4px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .loading-progress {
            font-size: 14px;
            opacity: 0.8;
            margin-top: 10px;
        }

        /* Website header integration - styles will come from main.css */

        /* Responsive adjustments for 3D controls */
        @media (max-width: 768px) {
            #controls {
                top: 80px;
                left: 10px;
                padding: 15px;
            }
            
            #info-panel {
                top: 80px;
                right: 10px;
                max-width: 280px;
                padding: 15px;
            }
            
            .panel-toggle.panel-hidden {
                top: 85px;
                left: 5px;
            }
            
            .camera-btn {
                font-size: 11px;
                padding: 8px 12px;
            }
            
            .phase-btn {
                font-size: 11px;
                padding: 8px 12px;
            }
            
            .phase-legend {
                font-size: 10px;
            }
        }

        #canvas-container {
            position: relative;
            width: 100vw;
            height: calc(100vh - 80px);
            margin-top: 80px;
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        #controls {
            position: absolute;
            top: 75px;
            left: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 6px;
            background: rgba(255, 255, 255, 0.85);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(8px);
            min-width: 160px;
            max-width: 180px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .control-group h3 {
            font-size: 11px;
            font-weight: 600;
            color: #333;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 4px;
            padding-bottom: 2px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .control-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 6px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.25);
            margin: 2px 0;
            line-height: 1.2;
        }

        .control-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        }

        .control-btn.active {
            background: #10b981;
            box-shadow: 0 2px 10px rgba(16, 185, 129, 0.3);
        }

        .control-btn.time-btn {
            background: #8b5cf6;
        }

        .control-btn.time-btn:hover {
            background: #7c3aed;
        }

        .control-btn.time-btn.active {
            background: #f59e0b;
        }

        .camera-btn {
            background: #8b5cf6;
            color: white;
            border: none;
            padding: 6px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.25);
            margin: 2px 0;
            width: 100%;
            display: flex;
            align-items: center;
            gap: 4px;
            line-height: 1.2;
        }

        .camera-btn:hover {
            background: #7c3aed;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
        }

        .camera-btn.active {
            background: #ec4899;
            box-shadow: 0 2px 10px rgba(236, 72, 153, 0.3);
        }

        .camera-btn.active:hover {
            background: #db2777;
        }

        .camera-controls {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .camera-controls h3 {
            font-size: 11px;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
            padding-bottom: 2px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .phase-btn {
            background: #475569;
            color: white;
            border: none;
            padding: 6px 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 2px 8px rgba(71, 85, 105, 0.25);
            margin: 2px 0;
            width: 100%;
            display: flex;
            align-items: center;
            gap: 4px;
            line-height: 1.2;
        }

        .phase-btn:hover {
            background: #334155;
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(71, 85, 105, 0.4);
        }

        .phase-btn.active {
            box-shadow: 0 2px 10px rgba(16, 185, 129, 0.3);
        }

        .phase-btn.phase1 {
            background: #4682b4;
            box-shadow: 0 2px 10px rgba(70, 130, 180, 0.3);
        }

        .phase-btn.phase1:hover {
            background: #36648b;
        }

        .phase-btn.phase1.active {
            background: #10b981;
        }

        .phase-btn.phase2 {
            background: #ff8c00;
            box-shadow: 0 2px 10px rgba(255, 140, 0, 0.3);
        }

        .phase-btn.phase2:hover {
            background: #e07b00;
        }

        .phase-btn.phase2.active {
            background: #10b981;
        }

        .phase-btn.phase3 {
            background: #32cd32;
            box-shadow: 0 2px 10px rgba(50, 205, 50, 0.3);
        }

        .phase-btn.phase3:hover {
            background: #228b22;
        }

        .phase-btn.phase3.active {
            background: #10b981;
        }

        .phase-controls {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .phase-controls h3 {
            font-size: 11px;
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
            padding-bottom: 2px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .phase-legend {
            margin-top: 6px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
            font-size: 9px;
        }

        .phase-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 2px 0;
        }

        .phase-color {
            width: 8px;
            height: 8px;
            border-radius: 2px;
        }

        .phase-color.completed {
            background: #4682b4;
        }

        .phase-color.construction {
            background: #ff8c00;
        }

        .phase-color.planned {
            background: #32cd32;
            opacity: 0.7;
        }

        #info-panel {
            position: absolute;
            top: 90px;
            right: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border-radius: 12px;
            padding: 20px;
            max-width: 320px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        #info-panel.hidden {
            transform: translateX(-100%);
            opacity: 0;
            pointer-events: none;
        }

        .panel-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: rgba(59, 130, 246, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 10px rgba(59, 130, 246, 0.3);
            z-index: 101;
            backdrop-filter: blur(5px);
            user-select: none;
        }

        .panel-toggle:hover {
            background: rgba(59, 130, 246, 1);
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        }

        .panel-toggle.panel-hidden {
            position: fixed;
            top: 100px;
            left: 10px;
            background: rgba(59, 130, 246, 0.9);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
            animation: pulse-glow 2s infinite;
        }

        .panel-toggle.panel-hidden:hover {
            left: 15px;
            background: rgba(59, 130, 246, 1);
            animation: none;
        }

        @keyframes pulse-glow {
            0% {
                box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
            }
            50% {
                box-shadow: 0 4px 20px rgba(59, 130, 246, 0.6), 0 0 10px rgba(59, 130, 246, 0.3);
            }
            100% {
                box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
            }
        }

        #info-panel h2 {
            color: #1e40af;
            font-size: 24px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding-right: 40px;
        }

        #info-panel h3 {
            color: #3b82f6;
            font-size: 16px;
            margin-top: 15px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #info-panel ul {
            list-style: none;
            padding-left: 0;
        }

        #info-panel li {
            padding: 4px 0;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #building-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            border-radius: 8px;
            padding: 15px;
            max-width: 300px;
            display: none;
            backdrop-filter: blur(10px);
        }


        .error-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10000;
        }

        .error-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
        }

        .error-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .error-title {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .error-message {
            font-size: 18px;
            opacity: 0.9;
            line-height: 1.6;
        }

        .icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-right: 4px;
        }
        
        /* Building Info Popup Styles */
        .building-info-popup {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(120%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            width: 320px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .building-info-popup.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        .popup-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            background: linear-gradient(135deg, #4c63d2 0%, #6c7ff2 100%);
            color: white;
            border-radius: 12px 12px 0 0;
        }
        
        .building-icon {
            font-size: 24px;
        }
        
        .building-title {
            flex: 1;
            font-size: 16px;
            font-weight: 600;
        }
        
        .popup-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.2s ease;
        }
        
        .popup-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .popup-content {
            padding: 15px;
        }
        
        .info-row {
            display: flex;
            margin-bottom: 12px;
            align-items: flex-start;
        }
        
        .info-row:last-child {
            margin-bottom: 0;
        }
        
        .info-label {
            font-weight: 600;
            color: #333;
            min-width: 80px;
            font-size: 13px;
        }
        
        .info-value {
            color: #666;
            font-size: 13px;
            flex: 1;
        }
        
        .features-list {
            list-style: none;
            padding: 0;
            margin: 0;
            color: #666;
            font-size: 12px;
        }
        
        .features-list li {
            padding: 2px 0;
            padding-left: 15px;
            position: relative;
        }
        
        .features-list li:before {
            content: "•";
            position: absolute;
            left: 0;
            color: #4c63d2;
        }
        
        .phase-status {
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            display: inline-block;
        }
        
        .phase-status.phase1 {
            background: rgba(70, 130, 180, 0.2);
            color: #4682B4;
        }
        
        .phase-status.phase2 {
            background: rgba(255, 140, 0, 0.2);
            color: #FF8C00;
        }
        
        .phase-status.phase3 {
            background: rgba(50, 205, 50, 0.2);
            color: #32CD32;
        }
        
        /* Mobile responsive */
        @media (max-width: 640px) {
            .building-info-popup {
                width: 90%;
                max-width: 320px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <h2 class="loading-text">Đang tải Enhanced Smart City...</h2>
            <p class="loading-progress" id="loading-progress">Khởi tạo WebGL...</p>
        </div>
    </div>

    <!-- Error Screen -->
    <div class="error-screen" id="error-screen">
        <div class="error-content">
            <div class="error-icon">⚠️</div>
            <h1 class="error-title">Lỗi Tải Smart City</h1>
            <p class="error-message" id="error-message">
                Không thể tải mô hình 3D. Vui lòng làm mới trang và thử lại.
            </p>
        </div>
    </div>

    <!-- Header -->
    <!-- Website Header -->
    <header class="header">
        <div class="header-container">
            <a href="index.html" class="logo">HEART</a>
            <nav class="nav">
                <a href="index.html">Home</a>
                <a href="about.html">About Us</a>
                <a href="master-plan.html">Master Plan</a>
                <a href="3d-smart-city.html" class="active">3D Smart City</a>
                <a href="facilities.html">Facilities</a>
                <a href="investment.html">Investment</a>
                <a href="technology.html">Technology</a>
                <a href="news.html">News</a>
                <a href="contact.html" class="contact-btn">Contact</a>
            </nav>
        </div>
    </header>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Information Panel -->
    <div id="info-panel">
        <button class="panel-toggle" onclick="toggleInfoPanel()" title="Ẩn/Hiện bảng thông tin">
            ✖
        </button>
        <h2>🏙️ Enhanced Smart City</h2>
        <p>Thành phố thông minh với cơ sở hạ tầng cảnh quan hoàn chỉnh</p>
        
        <h3>🌳 Tính năng cảnh quan:</h3>
        <ul>
            <li>✅ Công viên trung tâm 200x150m</li>
            <li>✅ 5 công viên nhỏ với sân chơi</li>
            <li>✅ 60+ cây xanh đô thị</li>
            <li>✅ Bãi đỗ xe 3 tầng</li>
            <li>✅ 4 bãi đỗ xe bề mặt</li>
            <li>✅ Đồ nội thất đường phố</li>
            <li>✅ Hệ thống đèn đường</li>
            <li>✅ 4 trạm sạc xe điện</li>
            <li>✅ Đài phun nước & hồ nước</li>
            <li>✅ Lối đi bộ & cơ sở hạ tầng</li>
        </ul>

        <h3>🎮 Điều khiển:</h3>
        <ul>
            <li>🖱️ Kéo chuột: Xoay camera</li>
            <li>🔍 Cuộn: Thu phóng</li>
            <li>👆 Click: Xem thông tin tòa nhà</li>
        </ul>
        
        <h3>⌨️ Phim tắt:</h3>
        <ul>
            <li>1-4: Camera Views</li>
            <li>5: Toggle Phase 1</li>
            <li>6: Toggle Phase 2</li>
            <li>7: Toggle Phase 3</li>
        </ul>
    </div>

    <!-- Controls -->
    <div id="controls">
        <div class="control-group">
            <h3>🕐 Thời gian trong ngày</h3>
            <button class="control-btn time-btn active" onclick="setTimeOfDay('morning')">Buổi sáng</button>
            <button class="control-btn time-btn" onclick="setTimeOfDay('noon')">Buổi trưa</button>
            <button class="control-btn time-btn" onclick="setTimeOfDay('evening')">Buổi chiều</button>
            <button class="control-btn time-btn" onclick="setTimeOfDay('night')">Buổi tối</button>
        </div>
        
        <div class="control-group">
            <h3>🎨 Chế độ hiển thị</h3>
            <button class="control-btn" onclick="toggleWireframe()">Khung dây</button>
            <button class="control-btn" onclick="toggleLandscapeMode()">Cảnh quan</button>
        </div>
        
        <div class="control-group camera-controls">
            <h3>📹 Camera Views</h3>
            <button class="camera-btn" id="aerialViewBtn" onclick="setCameraView('aerial')">🚁 Aerial View</button>
            <button class="camera-btn" id="streetViewBtn" onclick="setCameraView('street')">🚶 Street View</button>
            <button class="camera-btn" id="birdsEyeBtn" onclick="setCameraView('birdseye')">🦅 Bird's Eye</button>
            <button class="camera-btn" id="overviewViewBtn" onclick="setCameraView('overview')">🗺️ Full Overview</button>
            <button class="camera-btn" id="cinematicBtn" onclick="setCameraView('cinematic')">🎬 Cinematic</button>
        </div>
        
        <div class="control-group phase-controls">
            <div style="font-weight: bold; margin: 10px 0 8px 0; color: #2c3e50; font-size: 11px;">🏗️ Master Plan Phases</div>
            <button class="phase-btn phase1 active" id="phase1Btn" data-phase="1" onclick="togglePhase('phase1')">
                <span class="phase-indicator phase-1" style="background: #4682B4; width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>
                PHASE 1 - HEART CORE
            </button>
            <button class="phase-btn phase2 active" id="phase2Btn" data-phase="2" onclick="togglePhase('phase2')">
                <span class="phase-indicator phase-2" style="background: #FF8C00; width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>
                PHASE 2 - TECHNOLOGY HUB
            </button>
            <button class="phase-btn phase3 active" id="phase3Btn" data-phase="3" onclick="togglePhase('phase3')">
                <span class="phase-indicator phase-3" style="background: #32CD32; width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>
                PHASE 3 - INNOVATION DISTRICT
            </button>
            <button class="phase-btn" id="showAllBtn" onclick="showAllPhases()">
                <span class="phase-indicator phase-all" style="background: linear-gradient(to right, #4682B4 0%, #FF8C00 50%, #32CD32 100%); width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>
                SHOW ALL PHASES
            </button>
            
            <div class="phase-legend">
                <div class="phase-legend-item">
                    <div class="phase-color completed"></div>
                    <span>HEART CORE (Lõi HEART)</span>
                </div>
                <div class="phase-legend-item">
                    <div class="phase-color construction"></div>
                    <span>TECHNOLOGY HUB (Trung tâm Công nghệ)</span>
                </div>
                <div class="phase-legend-item">
                    <div class="phase-color planned"></div>
                    <span>INNOVATION DISTRICT (Khu Đổi mới)</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Building Info Popup -->
    <div class="building-info-popup" id="buildingInfoPopup">
        <div class="popup-header">
            <span class="building-icon" id="buildingIcon">🏢</span>
            <span class="building-title" id="buildingTitle">Building Information</span>
            <button class="popup-close" id="popupCloseBtn">✖</button>
        </div>
        <div class="popup-content">
            <div class="info-row">
                <span class="info-label">Loại:</span>
                <span class="info-value" id="buildingType">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Chiều cao:</span>
                <span class="info-value" id="buildingHeight">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Số tầng:</span>
                <span class="info-value" id="buildingFloors">-</span>
            </div>
            <div class="info-row">
                <span class="info-label">Tính năng:</span>
                <ul class="features-list" id="buildingFeatures"></ul>
            </div>
            <div class="info-row">
                <span class="info-label">Trạng thái:</span>
                <span class="info-value phase-status" id="buildingPhase">-</span>
            </div>
        </div>
    </div>


    <!-- Main Application Script -->
    <script>
        
        // Global loading state variables
        let isLoading = true;
        let loadingTimeout = null;
        
        // Global error display function
        function showError(message) {
            isLoading = false;
            if (loadingTimeout) clearTimeout(loadingTimeout);
            
            const errorScreen = document.getElementById('error-screen');
            const errorMessage = document.getElementById('error-message');
            
            if (errorScreen && errorMessage) {
                errorMessage.textContent = message;
                errorScreen.style.display = 'flex';
            }
            
            // Hide loading screen
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.style.display = 'none';
            }
            
            console.error('❌ ERROR:', message);
        }
        
        // ENHANCED: Promise-based THREE.js loader with multiple fallbacks
        function ensureThreeJSLoaded() {
            return new Promise((resolve, reject) => {
                console.log('🔄 Ensuring THREE.js is loaded...');
                
                // If THREE.js is already available
                if (typeof THREE !== 'undefined') {
                    console.log('✅ THREE.js already available');
                    resolve(THREE);
                    return;
                }
                
                // Try loading from multiple CDNs in sequence
                const cdnUrls = [
                    'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
                    'https://unpkg.com/three@0.128.0/build/three.min.js',
                    'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js',
                    'https://threejs.org/build/three.min.js'
                ];
                
                let currentCdnIndex = 0;
                
                function tryLoadFromCDN() {
                    if (currentCdnIndex >= cdnUrls.length) {
                        reject(new Error('All THREE.js CDN attempts failed'));
                        return;
                    }
                    
                    const script = document.createElement('script');
                    script.src = cdnUrls[currentCdnIndex];
                    
                    // Add timeout for each CDN attempt (5 seconds)
                    const timeoutId = setTimeout(() => {
                        console.error(`❌ Timeout loading THREE.js from CDN ${currentCdnIndex + 1}`);
                        script.remove();
                        currentCdnIndex++;
                        tryLoadFromCDN();
                    }, 5000);
                    
                    script.onload = () => {
                        clearTimeout(timeoutId);
                        
                        if (typeof THREE !== 'undefined') {
                            console.log(`✅ THREE.js loaded from CDN ${currentCdnIndex + 1}: ${cdnUrls[currentCdnIndex]}`);
                            console.log(`📦 THREE.js Version: ${THREE.REVISION}`);
                            
                            // Test basic functionality
                            try {
                                const testScene = new THREE.Scene();
                                console.log('✅ THREE.js functionality test passed');
                                resolve(THREE);
                            } catch (testError) {
                                console.error('❌ THREE.js functionality test failed:', testError);
                                reject(new Error('THREE.js loaded but not functional'));
                            }
                        } else {
                            console.error(`❌ THREE.js script loaded but THREE is undefined from CDN ${currentCdnIndex + 1}`);
                            currentCdnIndex++;
                            tryLoadFromCDN();
                        }
                    };
                    
                    script.onerror = () => {
                        clearTimeout(timeoutId);
                        console.error(`❌ Failed to load THREE.js from CDN ${currentCdnIndex + 1}: ${cdnUrls[currentCdnIndex]}`);
                        currentCdnIndex++;
                        tryLoadFromCDN();
                    };
                    
                    console.log(`🔄 Attempting to load THREE.js from CDN ${currentCdnIndex + 1}...`);
                    document.head.appendChild(script);
                }
                
                tryLoadFromCDN();
            });
        }
        
        // Wrapper function to maintain backward compatibility
        function waitForThreeJs(callback, timeout = 15000) {
            const timeoutId = setTimeout(() => {
                console.error('❌ Overall timeout waiting for THREE.js');
                showError('3D library loading timeout. Please check your internet connection and refresh the page.');
            }, timeout);
            
            ensureThreeJSLoaded()
                .then((THREE) => {
                    clearTimeout(timeoutId);
                    console.log('🚀 THREE.js ensured and ready for use');
                    callback();
                })
                .catch((error) => {
                    clearTimeout(timeoutId);
                    console.error('❌ Failed to ensure THREE.js:', error);
                    showError(`Cannot load 3D library: ${error.message}. Please refresh the page.`);
                });
        }
        
        // DEBUG: Add global THREE.js status checker
        window.checkThreeJS = function() {
            console.log('🔍 THREE.js Status Check:');
            console.log(`   THREE_LOADED flag: ${window.THREE_LOADED}`);
            console.log(`   typeof THREE: ${typeof THREE}`);
            
            if (typeof THREE !== 'undefined') {
                console.log(`   THREE.REVISION: ${THREE.REVISION}`);
                console.log(`   ✅ THREE.js is available and ready`);
                return true;
            } else {
                console.log(`   ❌ THREE.js is NOT available`);
                return false;
            }
        };
        
        // Add to window for console access
        window.THREE_STATUS = {
            loaded: () => window.THREE_LOADED,
            available: () => typeof THREE !== 'undefined',
            version: () => typeof THREE !== 'undefined' ? THREE.REVISION : 'Not loaded'
        };
        
        // Wrap all code to ensure Three.js is loaded
        waitForThreeJs(() => {
            console.log('🚀 Starting 3D Smart City initialization with THREE.js ready');
            console.log(`📦 THREE.js Version: ${THREE.REVISION}`);
        // Global variables
        let scene, camera, renderer, controls;
        let buildings = [];
        let trees = [];
        let parks = [];
        let parkingLots = [];
        let streetFurniture = [];
        let vehicles = [];
        let waterFeatures = [];
        let lights = [];
        let timeOfDay = 'morning';
        let wireframeMode = false;
        let landscapeMode = false;
        let raycaster, mouse;
        let selectedObject = null;
        let loadingTimeout;
        let isLoading = true;
        
        // Camera animation variables
        let currentCameraView = null;
        let cameraAnimation = null;
        let cinematicRotation = 0;
        let isCinematicMode = false;
        
        // Building phase system
        let buildingPhases = {
            phase1: { visible: true, buildings: [] },
            phase2: { visible: true, buildings: [] },
            phase3: { visible: true, buildings: [] }
        };
        
        // Phase colors and materials
        const phaseColors = {
            phase1: 0x4682B4,  // Steel blue - completed
            phase2: 0xFF8C00,  // Dark orange - construction
            phase3: 0x32CD32   // Lime green - planned
        };

        // Building types với thiết kế chi tiết
        const buildingTypes = {
            office_tower: { 
                minHeight: 40, 
                maxHeight: 80, 
                color: 0x4a90e2,
                name: 'Tòa văn phòng',
                icon: '🏢',
                features: ['Kính phản quang', 'Sảnh lớn', 'Thang máy tốc độ cao']
            },
            residential_tower: { 
                minHeight: 30, 
                maxHeight: 60, 
                color: 0xf5a623,
                name: 'Chung cư cao cấp',
                icon: '🏠',
                features: ['Ban công rộng', 'Hồ bơi trên mái', 'Phòng gym']
            },
            tech_campus: { 
                minHeight: 15, 
                maxHeight: 25, 
                color: 0x7ed321,
                name: 'Khu công nghệ',
                icon: '💻',
                features: ['Năng lượng mặt trời', 'Không gian mở', 'Phòng lab AI']
            },
            commercial_center: { 
                minHeight: 20, 
                maxHeight: 35, 
                color: 0xbd10e0,
                name: 'Trung tâm thương mại',
                icon: '🛍️',
                features: ['Food court', 'Rạp chiếu phim', 'Khu vui chơi']
            },
            medical_center: { 
                minHeight: 25, 
                maxHeight: 40, 
                color: 0xff0000,
                name: 'Bệnh viện thông minh',
                icon: '🏥',
                features: ['Cấp cứu 24/7', 'Helipad', 'AI chẩn đoán']
            },
            education_hub: { 
                minHeight: 15, 
                maxHeight: 30, 
                color: 0x50e3c2,
                name: 'Trung tâm giáo dục',
                features: ['Thư viện số', 'Phòng VR', 'Sân thể thao']
            }
        };

        // Park configurations
        // FIXED: Relocated parks to avoid road conflicts
        // Applied urban planning principles for logical green space distribution
        const parkConfigs = [
            // Central Park - Redesigned as proper plaza with road access
            { size: { x: 120, z: 80 }, position: { x: 30, z: 35 }, type: 'central' },
            
            // Small Parks - Positioned in safe zones between buildings
            { size: { x: 50, z: 50 }, position: { x: -160, z: 150 }, type: 'playground' },  // Northwest residential area
            { size: { x: 40, z: 60 }, position: { x: 170, z: -140 }, type: 'playground' },  // Southeast near offices
            { size: { x: 45, z: 45 }, position: { x: -170, z: -150 }, type: 'playground' }, // Southwest corner
            { size: { x: 55, z: 40 }, position: { x: 160, z: 140 }, type: 'playground' },   // Northeast business district
            { size: { x: 35, z: 50 }, position: { x: -50, z: -160 }, type: 'playground' }   // South residential buffer
        ];

        // Initialize loading with timeout protection
        function initializeLoading() {
            // Set timeout để tránh loading vô hạn
            loadingTimeout = setTimeout(() => {
                if (isLoading) {
                    console.error('⏰ Loading timeout sau 15 giây');
                    showError('Timeout khi tải. Vui lòng thử lại.');
                }
            }, 15000);

            // Update loading progress
            updateLoadingProgress('Đang tải Three.js...');
        }

        function updateLoadingProgress(message, percentage = null) {
            const progressElement = document.getElementById('loading-progress');
            if (progressElement) {
                const displayMessage = percentage ? `${message} (${percentage}%)` : message;
                progressElement.textContent = displayMessage;
            }
            
            const timestamp = new Date().toLocaleTimeString();
            console.log(`📊 [${timestamp}] ${message}`);
            
            // Add visual progress bar if percentage provided
            if (percentage !== null) {
                updateProgressBar(percentage);
            }
        }
        
        function updateProgressBar(percentage) {
            let progressBar = document.getElementById('progress-bar-fill');
            if (!progressBar) {
                // Create progress bar if it doesn't exist
                const progressContainer = document.createElement('div');
                progressContainer.id = 'progress-bar-container';
                progressContainer.style.cssText = `
                    width: 80%; max-width: 400px; height: 4px; 
                    background: rgba(255,255,255,0.2); border-radius: 2px; 
                    margin: 20px auto; overflow: hidden;
                `;
                
                progressBar = document.createElement('div');
                progressBar.id = 'progress-bar-fill';
                progressBar.style.cssText = `
                    height: 100%; background: #4CAF50; width: 0%; 
                    transition: width 0.3s ease; border-radius: 2px;
                `;
                
                progressContainer.appendChild(progressBar);
                document.getElementById('loading-screen').appendChild(progressContainer);
            }
            
            progressBar.style.width = percentage + '%';
        }

        function hideLoading() {
            isLoading = false;
            clearTimeout(loadingTimeout);
            
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }
        }

        // Moved showError inside wrapper - it needs access to isLoading and loadingTimeout

        // ASYNC: Main initialization function with THREE.js loading
        async function initSmartCity() {
            try {
                // Đảm bảo THREE.js loaded
                await ensureThreeJSLoaded();
                console.log('THREE.js loaded successfully:', THREE.REVISION);
                
                // Bây giờ mới khởi tạo scene
                initScene();
                initRenderer();
                initCamera();
                initLights();
                createBuildings();
                createTerrain();
                
                // Start render loop
                animate();
                
                // Hide loading screen
                hideLoadingScreen();
                
            } catch (error) {
                console.error('Initialization failed:', error);
                showErrorMessage('Failed to initialize 3D Smart City: ' + error.message);
            }
        }
        
        // Scene initialization
        function initScene() {
            updateLoadingProgress('Khởi tạo scene 3D...');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            // Fog removed for better visibility
        }
        
        // Camera initialization
        function initCamera() {
            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(150, 100, 150);
            camera.lookAt(0, 0, 0);
        }
        
        // Renderer initialization
        async function initRenderer() {

                // DEBUGGED: WebGL Initialization with Timeout and Progress Tracking
                updateLoadingProgress('Khởi tạo WebGL renderer...', 10);
                
                try {
                    // Add timeout for WebGL initialization
                    const webglInit = await Promise.race([
                        initializeWebGLWithDebug(),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('WebGL initialization timeout')), 10000)
                        )
                    ]);
                    
                    if (!webglInit.success) {
                        console.error('❌ WebGL initialization failed:', webglInit.errorMessage);
                        showError(webglInit.errorMessage);
                        return;
                    }
                    
                    // Store renderer globally with additional metadata
                    window.renderer = webglInit.renderer;
                    window.webglCapabilities = webglInit.capabilities;
                    window.renderQuality = webglInit.quality;
                    
                    updateLoadingProgress('WebGL initialization completed', 25);
                    console.log('🚀 WebGL System initialized successfully');
                    console.log(`   Quality Level: ${webglInit.quality.level}`);
                    console.log(`   Features: ${webglInit.capabilities.enabledFeatures.join(', ')}`);
                    
                } catch (error) {
                    console.error('❌ WebGL initialization error:', error);
                    // Fallback to simple WebGL renderer
                    updateLoadingProgress('Falling back to simple WebGL...', 15);
                    const fallbackResult = await createSimpleWebGLRenderer();
                    if (!fallbackResult.success) {
                        showError('WebGL initialization failed completely. Please check browser compatibility.');
                        return;
                    }
                    window.renderer = fallbackResult.renderer;
                }
                
                async function createSimpleWebGLRenderer() {
                    try {
                        // CRITICAL FIX: Check if THREE.js is loaded
                        if (typeof THREE === 'undefined') {
                            console.error('❌ THREE.js not loaded for simple renderer!');
                            return { success: false, errorMessage: 'THREE.js library not loaded' };
                        }
                        
                        const container = document.getElementById('canvas-container');
                        if (!container) {
                            return { success: false, errorMessage: 'Canvas container not found' };
                        }
                        
                        // Simple WebGL renderer creation
                        const renderer = new THREE.WebGLRenderer({
                            antialias: false,
                            alpha: false,
                            failIfMajorPerformanceCaveat: false
                        });
                        
                        renderer.setSize(window.innerWidth, window.innerHeight);
                        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                        
                        // Test renderer
                        const gl = renderer.getContext();
                        if (!gl || gl.isContextLost()) {
                            renderer.dispose();
                            return { success: false, errorMessage: 'WebGL context creation failed' };
                        }
                        
                        container.innerHTML = '';
                        container.appendChild(renderer.domElement);
                        
                        console.log('✅ Simple WebGL renderer created successfully');
                        return { success: true, renderer };
                        
                    } catch (error) {
                        console.error('Simple WebGL renderer failed:', error);
                        return { success: false, errorMessage: error.message };
                    }
                }
                
                async function initializeWebGLWithDebug() {
                    console.log('🔧 Starting WebGL initialization with debug tracking...');
                    
                    const container = document.getElementById('canvas-container');
                    if (!container) {
                        return { success: false, errorMessage: 'Canvas container not found - DOM not ready' };
                    }
                    
                    try {
                        // Step 1: Device Analysis (with timeout)
                        console.log('📱 Step 1: Analyzing device capabilities...');
                        const deviceInfo = await Promise.race([
                            Promise.resolve(analyzeDeviceCapabilities()),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Device analysis timeout')), 2000))
                        ]);
                        console.log('✅ Device analysis completed:', deviceInfo);
                        
                        // Step 2: WebGL Context Creation (with timeout)  
                        console.log('🎮 Step 2: Creating WebGL context...');
                        const webglResult = await Promise.race([
                            createRobustWebGLContext(container, deviceInfo),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('WebGL context creation timeout')), 3000))
                        ]);
                        
                        if (!webglResult.success) {
                            return webglResult;
                        }
                        console.log('✅ WebGL context created successfully');
                        
                        // Step 3: Simplified Capabilities Analysis (faster)
                        console.log('🔍 Step 3: Analyzing WebGL capabilities...');
                        const capabilities = await Promise.race([
                            analyzeWebGLCapabilitiesFast(webglResult.renderer),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Capabilities analysis timeout')), 2000))
                        ]);
                        console.log('✅ Capabilities analysis completed');
                        
                        // Step 4: Quality Determination (simplified)
                        console.log('⚙️ Step 4: Determining quality level...');
                        const qualityLevel = determineOptimalQualityFast(deviceInfo, capabilities);
                        console.log('✅ Quality level determined:', qualityLevel.level);
                        
                        // Step 5: Renderer Configuration (essential only)
                        console.log('🎨 Step 5: Configuring renderer...');
                        configureRendererBasic(webglResult.renderer, qualityLevel);
                        console.log('✅ Renderer configured');
                        
                        // Step 6: Basic Error Handling (essential only)
                        console.log('🛡️ Step 6: Setting up error handling...');
                        setupBasicErrorHandling(webglResult.renderer, container);
                        console.log('✅ Error handling activated');
                        
                        return {
                            success: true,
                            renderer: webglResult.renderer,
                            capabilities,
                            quality: qualityLevel,
                            deviceInfo
                        };
                        
                    } catch (error) {
                        console.error('❌ WebGL initialization step failed:', error);
                        return {
                            success: false,
                            errorMessage: `WebGL initialization failed: ${error.message}`
                        };
                    }
                }
                
                // Faster version of capabilities analysis
                async function analyzeWebGLCapabilitiesFast(renderer) {
                    const gl = renderer.getContext();
                    const capabilities = {
                        webglVersion: gl instanceof WebGL2RenderingContext ? 2 : 1,
                        maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                        extensions: {},
                        enabledFeatures: [],
                        limitations: []
                    };
                    
                    // Check only essential extensions (fast)
                    const essentialExts = ['WEBGL_depth_texture', 'OES_texture_float', 'OES_standard_derivatives'];
                    essentialExts.forEach(extName => {
                        const ext = gl.getExtension(extName);
                        capabilities.extensions[extName] = !!ext;
                        if (ext) capabilities.enabledFeatures.push(extName);
                    });
                    
                    // Quick performance test (simplified)
                    const startTime = performance.now();
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    const endTime = performance.now();
                    capabilities.performance = { 
                        duration: endTime - startTime,
                        score: endTime - startTime < 5 ? 'good' : 'fair'
                    };
                    
                    console.log('🔍 Fast WebGL capabilities:', capabilities);
                    return capabilities;
                }
                
                // Simplified quality determination
                function determineOptimalQualityFast(deviceInfo, capabilities) {
                    let level = 'medium';
                    
                    if (deviceInfo.isMobile) {
                        level = deviceInfo.deviceClass === 'high' ? 'medium' : 'low';
                    } else {
                        level = deviceInfo.deviceClass === 'high' ? 'high' : 'medium';
                    }
                    
                    return {
                        level,
                        shadows: capabilities.extensions['WEBGL_depth_texture'] && level !== 'low',
                        antialiasing: level === 'high' && !deviceInfo.isMobile,
                        pixelRatio: Math.min(window.devicePixelRatio, level === 'high' ? 2 : 1.5)
                    };
                }
                
                // Basic renderer configuration (essential settings only)
                function configureRendererBasic(renderer, quality) {
                    renderer.setPixelRatio(quality.pixelRatio);
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    
                    // Basic shadow configuration
                    if (quality.shadows) {
                        renderer.shadowMap.enabled = true;
                        renderer.shadowMap.type = THREE.PCFShadowMap;
                    }
                    
                    // Basic color space (with fallback)
                    try {
                        renderer.outputColorSpace = THREE.SRGBColorSpace;
                    } catch (e) {
                        console.warn('SRGBColorSpace not supported');
                    }
                }
                
                // Simplified error handling (essential only)
                function setupBasicErrorHandling(renderer, container) {
                    const canvas = renderer.domElement;
                    
                    canvas.addEventListener('webglcontextlost', (event) => {
                        event.preventDefault();
                        console.error('❌ WebGL context lost!');
                        showError('WebGL context lost. Please reload the page.');
                    });
                    
                    canvas.addEventListener('webglcontextrestored', () => {
                        console.log('✅ WebGL context restored');
                        location.reload(); // Simple solution: reload page
                    });
                }
                
                function analyzeDeviceCapabilities() {
                    const ua = navigator.userAgent;
                    const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
                    const isIOS = /iPad|iPhone|iPod/.test(ua);
                    const isSafari = /Safari/.test(ua) && !/Chrome/.test(ua);
                    
                    const deviceMemory = navigator.deviceMemory || (isMobile ? 2 : 8);
                    const hardwareConcurrency = navigator.hardwareConcurrency || (isMobile ? 2 : 4);
                    
                    const deviceClass = deviceMemory >= 8 && hardwareConcurrency >= 8 ? 'high' :
                                       deviceMemory >= 4 && hardwareConcurrency >= 4 ? 'medium' : 'low';
                    
                    return {
                        isMobile, isIOS, isSafari, deviceMemory, hardwareConcurrency, deviceClass,
                        pixelRatio: window.devicePixelRatio || 1,
                        screenSize: { width: screen.width, height: screen.height },
                        viewportSize: { width: window.innerWidth, height: window.innerHeight }
                    };
                }
                
                async function createRobustWebGLContext(container, deviceInfo) {
                    // CRITICAL FIX: Check if THREE.js is loaded first
                    if (typeof THREE === 'undefined') {
                        console.error('❌ THREE.js not loaded yet!');
                        return {
                            success: false,
                            errorMessage: 'THREE.js library not loaded. Please check your internet connection.'
                        };
                    }
                    
                    const canvas = document.createElement('canvas');
                    canvas.style.display = 'block';
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    
                    // Context configuration based on device capabilities
                    const contextConfigs = [
                        // Ultra High Quality (Desktop High-End)
                        {
                            name: 'Ultra',
                            condition: !deviceInfo.isMobile && deviceInfo.deviceClass === 'high',
                            config: {
                                canvas, antialias: true, powerPreference: "high-performance",
                                alpha: false, premultipliedAlpha: false, stencil: true, depth: true,
                                preserveDrawingBuffer: false, failIfMajorPerformanceCaveat: false,
                                desynchronized: false
                            }
                        },
                        // High Quality (Desktop Mid-Range)
                        {
                            name: 'High', 
                            condition: !deviceInfo.isMobile && deviceInfo.deviceClass === 'medium',
                            config: {
                                canvas, antialias: true, powerPreference: "high-performance",
                                alpha: false, stencil: true, depth: true, 
                                failIfMajorPerformanceCaveat: false
                            }
                        },
                        // Medium Quality (Desktop Low-End / Mobile High-End)
                        {
                            name: 'Medium',
                            condition: (!deviceInfo.isMobile && deviceInfo.deviceClass === 'low') || 
                                      (deviceInfo.isMobile && deviceInfo.deviceClass === 'high'),
                            config: {
                                canvas, antialias: deviceInfo.pixelRatio <= 1.5,
                                powerPreference: "default", alpha: false,
                                stencil: false, depth: true, failIfMajorPerformanceCaveat: false
                            }
                        },
                        // Low Quality (Mobile Low-End)
                        {
                            name: 'Low',
                            condition: deviceInfo.isMobile && deviceInfo.deviceClass !== 'high',
                            config: {
                                canvas, antialias: false, powerPreference: "default",
                                alpha: false, stencil: false, depth: true,
                                failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false
                            }
                        }
                    ];
                    
                    // Try configurations in order of preference
                    for (const configSet of contextConfigs) {
                        if (configSet.condition) {
                            try {
                                const renderer = new THREE.WebGLRenderer(configSet.config);
                                
                                // Immediate context validation
                                const gl = renderer.getContext();
                                if (!gl || gl.isContextLost()) {
                                    renderer.dispose();
                                    continue;
                                }
                                
                                // Test basic rendering capability
                                renderer.setSize(256, 256);
                                const testScene = new THREE.Scene();
                                const testCamera = new THREE.PerspectiveCamera();
                                renderer.render(testScene, testCamera);
                                testScene.clear();
                                
                                // Resize to actual dimensions
                                renderer.setSize(window.innerWidth, window.innerHeight);
                                
                                container.innerHTML = '';
                                container.appendChild(canvas);
                                
                                console.log(`✅ ${configSet.name} quality WebGL renderer created successfully`);
                                return { success: true, renderer, qualityLevel: configSet.name.toLowerCase() };
                                
                            } catch (error) {
                                console.warn(`${configSet.name} quality WebGL failed:`, error.message);
                                continue;
                            }
                        }
                    }
                    
                    // All WebGL strategies failed - provide comprehensive error
                    const errorDetails = {
                        userAgent: navigator.userAgent,
                        webglSupported: !!window.WebGLRenderingContext,
                        webgl2Supported: !!window.WebGL2RenderingContext,
                        deviceInfo
                    };
                    
                    console.error('❌ All WebGL initialization strategies failed', errorDetails);
                    
                    return {
                        success: false,
                        errorMessage: `WebGL initialization failed on this device.\n\n` +
                                    `Device: ${deviceInfo.deviceClass}-end ${deviceInfo.isMobile ? 'mobile' : 'desktop'}\n` +
                                    `Memory: ${deviceInfo.deviceMemory}GB\n` +
                                    `Browser: ${deviceInfo.isSafari ? 'Safari' : deviceInfo.isIOS ? 'iOS' : 'Other'}\n\n` +
                                    `Solutions:\n` +
                                    `1. Enable Hardware Acceleration in browser settings\n` +
                                    `2. Update your graphics drivers\n` +
                                    `3. Try Chrome or Firefox (latest version)\n` +
                                    `4. Restart your browser\n` +
                                    `5. Check GPU compatibility: ${errorDetails.webglSupported ? 'WebGL supported' : 'WebGL NOT supported'}`
                    };
                }
                
                async function analyzeWebGLCapabilities(renderer) {
                    const gl = renderer.getContext();
                    const capabilities = {
                        webglVersion: gl instanceof WebGL2RenderingContext ? 2 : 1,
                        maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                        maxRenderbufferSize: gl.getParameter(gl.MAX_RENDERBUFFER_SIZE),
                        maxViewportDims: gl.getParameter(gl.MAX_VIEWPORT_DIMS),
                        maxVertexAttribs: gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
                        maxVertexUniformVectors: gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
                        maxFragmentUniformVectors: gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),
                        maxVaryingVectors: gl.getParameter(gl.MAX_VARYING_VECTORS),
                        extensions: {},
                        enabledFeatures: [],
                        limitations: []
                    };
                    
                    // Critical extensions
                    const criticalExts = [
                        'OES_texture_float', 'OES_texture_half_float', 'OES_standard_derivatives',
                        'WEBGL_depth_texture', 'OES_element_index_uint', 'OES_vertex_array_object'
                    ];
                    
                    // Optional extensions  
                    const optionalExts = [
                        'EXT_texture_filter_anisotropic', 'WEBGL_compressed_texture_s3tc',
                        'WEBGL_compressed_texture_pvrtc', 'WEBGL_compressed_texture_etc1',
                        'EXT_disjoint_timer_query', 'WEBGL_draw_buffers'
                    ];
                    
                    [...criticalExts, ...optionalExts].forEach(extName => {
                        const ext = gl.getExtension(extName) || 
                                   gl.getExtension('WEBKIT_' + extName) || 
                                   gl.getExtension('MOZ_' + extName);
                        capabilities.extensions[extName] = !!ext;
                        if (ext) capabilities.enabledFeatures.push(extName);
                    });
                    
                    // Feature availability determination
                    if (capabilities.extensions['WEBGL_depth_texture']) capabilities.enabledFeatures.push('shadows');
                    if (capabilities.extensions['OES_texture_float']) capabilities.enabledFeatures.push('float_textures');
                    if (capabilities.extensions['EXT_texture_filter_anisotropic']) capabilities.enabledFeatures.push('anisotropic_filtering');
                    
                    // Limitations detection
                    if (capabilities.maxTextureSize < 2048) capabilities.limitations.push('low_texture_resolution');
                    if (capabilities.maxViewportDims[0] < 2048) capabilities.limitations.push('limited_viewport');
                    if (!capabilities.extensions['OES_texture_float']) capabilities.limitations.push('no_float_textures');
                    
                    // Performance testing
                    const perfResult = await performanceTest(gl);
                    capabilities.performance = perfResult;
                    
                    console.log('🔍 WebGL Capabilities Analysis:', capabilities);
                    return capabilities;
                }
                
                async function performanceTest(gl) {
                    const startTime = performance.now();
                    
                    // Create test resources
                    const testTexture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, testTexture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 512, 512, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                    
                    const testFramebuffer = gl.createFramebuffer();
                    gl.bindFramebuffer(gl.FRAMEBUFFER, testFramebuffer);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, testTexture, 0);
                    
                    // Performance test: render to texture
                    for (let i = 0; i < 10; i++) {
                        gl.clear(gl.COLOR_BUFFER_BIT);
                    }
                    
                    // Cleanup
                    gl.deleteTexture(testTexture);
                    gl.deleteFramebuffer(testFramebuffer);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    
                    const endTime = performance.now();
                    const duration = endTime - startTime;
                    
                    const score = duration < 5 ? 'excellent' : 
                                 duration < 15 ? 'good' : 
                                 duration < 50 ? 'fair' : 'poor';
                    
                    return { duration, score };
                }
                
                function determineOptimalQuality(deviceInfo, capabilities) {
                    let baseQuality = deviceInfo.isMobile ? 'medium' : 'high';
                    
                    // Upgrade quality based on capabilities
                    if (!deviceInfo.isMobile && capabilities.performance.score === 'excellent' && 
                        deviceInfo.deviceClass === 'high' && capabilities.maxTextureSize >= 4096) {
                        baseQuality = 'ultra';
                    }
                    
                    // Downgrade quality based on limitations
                    if (capabilities.limitations.includes('low_texture_resolution') || 
                        capabilities.performance.score === 'poor') {
                        baseQuality = deviceInfo.isMobile ? 'low' : 'medium';
                    }
                    
                    const qualityConfig = {
                        ultra: {
                            level: 'ultra',
                            shadows: true, 
                            antialiasing: true,
                            postProcessing: true,
                            particleCount: 5000,
                            textureQuality: 'high',
                            geometryDetail: 'high',
                            pixelRatio: Math.min(window.devicePixelRatio, 2)
                        },
                        high: {
                            level: 'high', 
                            shadows: capabilities.extensions['WEBGL_depth_texture'],
                            antialiasing: true,
                            postProcessing: capabilities.extensions['WEBGL_draw_buffers'],
                            particleCount: 3000,
                            textureQuality: 'high',
                            geometryDetail: 'medium',
                            pixelRatio: Math.min(window.devicePixelRatio, 1.5)
                        },
                        medium: {
                            level: 'medium',
                            shadows: capabilities.extensions['WEBGL_depth_texture'],
                            antialiasing: deviceInfo.pixelRatio <= 1.5,
                            postProcessing: false,
                            particleCount: 1500,
                            textureQuality: 'medium', 
                            geometryDetail: 'medium',
                            pixelRatio: Math.min(window.devicePixelRatio, 1.25)
                        },
                        low: {
                            level: 'low',
                            shadows: false,
                            antialiasing: false,
                            postProcessing: false,
                            particleCount: 500,
                            textureQuality: 'low',
                            geometryDetail: 'low',
                            pixelRatio: 1
                        }
                    };
                    
                    return qualityConfig[baseQuality];
                }
                
                function configureRendererForQuality(renderer, quality, capabilities) {
                    // Basic renderer configuration
                    renderer.setPixelRatio(quality.pixelRatio);
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    
                    // Advanced renderer settings based on capabilities
                    try {
                        renderer.outputColorSpace = THREE.SRGBColorSpace;
                        
                        if (quality.level === 'ultra' || quality.level === 'high') {
                            renderer.toneMapping = THREE.ACESFilmicToneMapping;
                            renderer.toneMappingExposure = 1.2;
                        } else {
                            renderer.toneMapping = THREE.LinearToneMapping;
                            renderer.toneMappingExposure = 1.0;
                        }
                        
                    } catch (e) {
                        console.warn('Advanced color space configuration not supported:', e.message);
                    }
                    
                    // Shadow configuration
                    if (quality.shadows && capabilities.extensions['WEBGL_depth_texture']) {
                        renderer.shadowMap.enabled = true;
                        renderer.shadowMap.type = quality.level === 'ultra' ? 
                            THREE.PCFSoftShadowMap : THREE.PCFShadowMap;
                        console.log(`✅ Shadows enabled (${quality.level} quality)`);
                    } else {
                        renderer.shadowMap.enabled = false;
                        console.log('⚠️ Shadows disabled (not supported or low quality)');
                    }
                    
                    // Performance optimizations for lower quality
                    if (quality.level === 'low' || quality.level === 'medium') {
                        renderer.setPixelRatio(quality.pixelRatio);
                        renderer.info.autoReset = false; // Manual reset for performance monitoring
                    }
                    
                    console.log(`⚙️ Renderer configured for ${quality.level} quality`);
                }
                
                async function initializeAdvancedFeatures(renderer, capabilities) {
                    const gl = renderer.getContext();
                    const features = [];
                    
                    // Anisotropic filtering
                    if (capabilities.extensions['EXT_texture_filter_anisotropic']) {
                        const anisotropyExt = gl.getExtension('EXT_texture_filter_anisotropic');
                        const maxAnisotropy = gl.getParameter(anisotropyExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                        renderer.capabilities.getMaxAnisotropy = () => maxAnisotropy;
                        features.push(`anisotropic_filtering_${maxAnisotropy}x`);
                    }
                    
                    // Float texture support
                    if (capabilities.extensions['OES_texture_float']) {
                        features.push('float_textures');
                    }
                    
                    // Multiple render targets
                    if (capabilities.extensions['WEBGL_draw_buffers']) {
                        const maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);
                        features.push(`draw_buffers_${maxDrawBuffers}`);
                    }
                    
                    // Vertex array objects for better performance
                    if (capabilities.extensions['OES_vertex_array_object']) {
                        features.push('vertex_array_objects');
                    }
                    
                    // Initialize performance monitoring
                    if (capabilities.extensions['EXT_disjoint_timer_query']) {
                        setupPerformanceMonitoring(gl);
                        features.push('gpu_timing');
                    }
                    
                    console.log(`🚀 Advanced WebGL features initialized: ${features.join(', ')}`);
                    return features;
                }
                
                function setupPerformanceMonitoring(gl) {
                    const timerExt = gl.getExtension('EXT_disjoint_timer_query');
                    if (!timerExt) return;
                    
                    window.webglPerformance = {
                        startTimer() {
                            const query = timerExt.createQueryEXT();
                            timerExt.beginQueryEXT(timerExt.TIME_ELAPSED_EXT, query);
                            return query;
                        },
                        endTimer(query) {
                            timerExt.endQueryEXT(timerExt.TIME_ELAPSED_EXT);
                            return query;
                        },
                        getResult(query) {
                            const available = timerExt.getQueryObjectEXT(query, timerExt.QUERY_RESULT_AVAILABLE_EXT);
                            if (available) {
                                const time = timerExt.getQueryObjectEXT(query, timerExt.QUERY_RESULT_EXT);
                                timerExt.deleteQueryEXT(query);
                                return time / 1000000; // Convert to milliseconds
                            }
                            return null;
                        }
                    };
                }
                
                function setupEnterpriseErrorHandling(renderer, container) {
                    const canvas = renderer.domElement;
                    const gl = renderer.getContext();
                    
                    // Context loss handling with automatic recovery
                    let contextLostCount = 0;
                    let sceneState = null;
                    
                    canvas.addEventListener('webglcontextlost', (event) => {
                        event.preventDefault();
                        contextLostCount++;
                        
                        console.error(`❌ WebGL context lost (occurrence #${contextLostCount})`);
                        
                        // Save scene state for reconstruction
                        if (window.scene && window.camera) {
                            sceneState = {
                                cameraPosition: window.camera.position.clone(),
                                cameraRotation: window.camera.rotation.clone(),
                                sceneChildren: window.scene.children.length
                            };
                        }
                        
                        // Show user-friendly message
                        showTemporaryMessage('WebGL context lost. Attempting recovery...', 3000);
                        
                        // Stop animation loop to prevent errors
                        if (window.animationId) {
                            cancelAnimationFrame(window.animationId);
                            window.animationId = null;
                        }
                    });
                    
                    canvas.addEventListener('webglcontextrestored', async () => {
                        console.log('✅ WebGL context restored - rebuilding scene...');
                        
                        try {
                            // Reconfigure renderer
                            const capabilities = await analyzeWebGLCapabilities(renderer);
                            const deviceInfo = analyzeDeviceCapabilities();
                            const quality = determineOptimalQuality(deviceInfo, capabilities);
                            
                            configureRendererForQuality(renderer, quality, capabilities);
                            await initializeAdvancedFeatures(renderer, capabilities);
                            
                            // Restore scene if possible
                            if (sceneState && window.scene && window.camera) {
                                window.camera.position.copy(sceneState.cameraPosition);
                                window.camera.rotation.copy(sceneState.cameraRotation);
                                console.log('📍 Camera state restored');
                            }
                            
                            // Restart animation loop
                            if (window.animate && !window.animationId) {
                                window.animate();
                                console.log('🎬 Animation loop restarted');
                            }
                            
                            showTemporaryMessage('WebGL context recovered successfully!', 2000);
                            
                        } catch (error) {
                            console.error('❌ Failed to recover from context loss:', error);
                            showError('WebGL recovery failed. Please reload the page.');
                        }
                    });
                    
                    // Memory pressure handling
                    if ('memory' in performance) {
                        setInterval(() => {
                            const memInfo = performance.memory;
                            const usage = memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit;
                            
                            if (usage > 0.85) {
                                console.warn('⚠️ High memory usage detected:', Math.round(usage * 100) + '%');
                                // Could trigger garbage collection or reduce quality
                                if (window.webglCapabilities) {
                                    console.log('💾 Consider reducing scene complexity');
                                }
                            }
                        }, 10000);
                    }
                    
                    // Error boundary for WebGL operations
                    window.safeWebGLOperation = function(operation, errorMessage = 'WebGL operation failed') {
                        try {
                            if (gl.isContextLost()) {
                                console.warn('⚠️ Skipping WebGL operation - context lost');
                                return null;
                            }
                            return operation();
                        } catch (error) {
                            console.error('❌', errorMessage, error);
                            return null;
                        }
                    };
                    
                    console.log('🛡️ Enterprise error handling and recovery system activated');
                }
                
                function showTemporaryMessage(message, duration = 3000) {
                    const messageEl = document.createElement('div');
                    messageEl.style.cssText = `
                        position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
                        background: rgba(0,0,0,0.8); color: white; padding: 10px 20px;
                        border-radius: 5px; z-index: 10001; font-family: Arial, sans-serif;
                    `;
                    messageEl.textContent = message;
                    document.body.appendChild(messageEl);
                    
                    setTimeout(() => {
                        if (messageEl.parentNode) {
                            messageEl.parentNode.removeChild(messageEl);
                        }
                    }, duration);
                }
                
                // Canvas container and DOM setup already handled above in WebGL initialization

                updateLoadingProgress('Tải OrbitControls...', 30);
                
                // Load OrbitControls with timeout protection
                try {
                    await Promise.race([
                        loadOrbitControls(),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('OrbitControls loading timeout after 5 seconds')), 5000)
                        )
                    ]);
                    console.log('✅ OrbitControls loaded successfully');
                } catch (error) {
                    console.error('❌ OrbitControls loading failed:', error);
                    // Create fallback controls
                    console.log('🔄 Creating fallback camera controls...');
                    setupFallbackControls();
                    updateLoadingProgress('Fallback controls activated', 35);
                }
                
                // Raycaster for mouse interaction
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();

                updateLoadingProgress('Tạo ánh sáng...', 40);
                
                // Lighting
                setupLighting();
                console.log('✅ Lighting setup completed');

                updateLoadingProgress('Xây dựng nền và đường...', 45);
                
                // Create city elements (with progress tracking)
                createGround();
                console.log('✅ Ground created');
                
                createRoads();
                console.log('✅ Roads created');
                
                updateLoadingProgress('Tạo công viên và cây xanh...', 55);
                createParks();
                console.log('✅ Parks created');
                
                createTrees();
                console.log('✅ Trees created');
                
                updateLoadingProgress('Xây dựng tòa nhà...', 65);
                createBuildings();
                console.log('✅ Buildings created');
                
                updateLoadingProgress('Tạo trung tâm dữ liệu...', 75);
                createDataCenterCluster();
                console.log('✅ Data center cluster created');
                
                updateLoadingProgress('Hoàn thiện hệ thống...', 85);
                
                updateLoadingProgress('Tạo bãi đỗ xe...', 88);
                createParkingInfrastructure();
                console.log('✅ Parking infrastructure created');
                
                updateLoadingProgress('Thêm nội thất đường phố...', 92);
                createStreetFurniture();
                createInfrastructure();
                console.log('✅ Street furniture and infrastructure created');
                
                updateLoadingProgress('Tạo tính năng nước...', 95);
                createWaterFeatures();
                console.log('✅ Water features created');
                
                createRiver();
                console.log('✅ River created');

                updateLoadingProgress('Thiết lập event listeners...', 98);
                // Event listeners
                window.addEventListener('resize', onWindowResize);
                window.addEventListener('keydown', onKeyDown);
                renderer.domElement.addEventListener('click', onMouseClick);
                renderer.domElement.addEventListener('mousemove', onMouseMove);
                console.log('✅ Event listeners attached');

                updateLoadingProgress('Hoàn tất! Khởi động render...', 100);
                
                // Restore data centers after scene is fully loaded - DISABLED to use createDataCenterCluster instead
                console.log('🏢 Data centers already created by createDataCenterCluster...');
                // COMMENTED OUT - This was overriding the proper data centers
                // setTimeout(() => {
                //     if (window.restoreOriginalDataCenters) {
                //         restoreOriginalDataCenters();
                //     } else {
                //         console.error('❌ restoreOriginalDataCenters function not found');
                //     }
                // }, 500); // Small delay to ensure scene is ready
                
                // Debug scene after restoration  
                setTimeout(() => {
                    if (window.debugSceneObjects) {
                        debugSceneObjects();
                    }
                }, 200);
                
                console.log('🎬 Starting animation loop...');
                // Start animation
                animate();
                
                console.log('🚫 Initializing anti-blinking system...');
                // Initialize Anti-Blinking System to eliminate all flashing effects
                try {
                    initAntiBlinkingSystem();
                    console.log('✅ Anti-blinking system activated');
                } catch (error) {
                    console.warn('⚠️ Anti-blinking system failed:', error.message);
                }
                
                // Final success message and hide loading
                console.log('🎉 3D Smart City initialization completed successfully!');
                console.log('📊 Scene statistics:');
                console.log(`   - Total objects: ${scene.children.length}`);
                console.log(`   - WebGL quality: ${window.renderQuality ? window.renderQuality.level : 'basic'}`);
                console.log(`   - Controls: ${window.controls ? 'active' : 'fallback'}`);
                
                // Hide loading after confirming everything is ready
                setTimeout(() => {
                    console.log('🎬 First frame rendered - hiding loading screen');
                    hideLoading();
                }, 300);

            } catch (error) {
                console.error('❌ Lỗi khởi tạo:', error);
                showError('Lỗi khởi tạo 3D scene: ' + error.message);
            }
        }

        // Load OrbitControls dynamically
        async function loadOrbitControls() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js';
                script.onload = () => {
                    try {
                        controls = new THREE.OrbitControls(camera, renderer.domElement);
                        controls.enableDamping = true;
                        controls.dampingFactor = 0.05;
                        controls.maxPolarAngle = Math.PI / 2.2;
                        controls.minDistance = 50;
                        controls.maxDistance = 1000;
                        resolve();
                    } catch (error) {
                        reject(error);
                    }
                };
                script.onerror = reject;
                document.body.appendChild(script);
            });
        }
        
        // Fallback controls when OrbitControls fails to load
        function setupFallbackControls() {
            console.log('🔄 Setting up fallback camera controls...');
            
            // Basic keyboard and mouse controls
            let isMouseDown = false;
            let mousePosition = { x: 0, y: 0 };
            const rotateSpeed = 0.005;
            const moveSpeed = 2;
            
            // Mouse controls for camera rotation
            renderer.domElement.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mousePosition.x = event.clientX;
                mousePosition.y = event.clientY;
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!isMouseDown) return;
                
                const deltaX = event.clientX - mousePosition.x;
                const deltaY = event.clientY - mousePosition.y;
                
                // Rotate camera around scene center
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                
                spherical.theta -= deltaX * rotateSpeed;
                spherical.phi += deltaY * rotateSpeed;
                
                // Constrain phi to prevent flipping
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
                
                mousePosition.x = event.clientX;
                mousePosition.y = event.clientY;
            });
            
            // Mouse wheel for zooming
            renderer.domElement.addEventListener('wheel', (event) => {
                const zoomFactor = event.deltaY > 0 ? 1.1 : 0.9;
                const direction = camera.position.clone().normalize();
                camera.position.multiplyScalar(zoomFactor);
                
                // Constrain zoom limits
                const distance = camera.position.length();
                if (distance < 50) {
                    camera.position.setLength(50);
                } else if (distance > 1000) {
                    camera.position.setLength(1000);
                }
                
                camera.lookAt(0, 0, 0);
                event.preventDefault();
            });
            
            // Create a fallback controls object to maintain API compatibility
            window.controls = {
                enableDamping: false,
                dampingFactor: 0,
                update: function() {
                    // No-op for compatibility
                },
                enabled: true
            };
            
            console.log('✅ Fallback controls activated');
        }

        // Setup lighting system
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // Directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -150;
            directionalLight.shadow.camera.right = 150;
            directionalLight.shadow.camera.top = 150;
            directionalLight.shadow.camera.bottom = -150;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Hemisphere light for better ambient
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x545454, 0.4);
            scene.add(hemisphereLight);
        }

        // Create ground với terrain optimized - PRECISELY SIZED to data center boundaries
        function createGround() {
            // OPTIMIZED ground platform - precisely bounded to cooling tower positions
            // Analysis shows rightmost towers at X=460, so limiting ground to X=480 with padding
            // This reduces ground size by ~41% width and ~51% height for better performance
            
            // Calculated boundaries: X(-350 to 480), Z(-250 to 280)
            // Adding buffer for river final point and visual aesthetics
            const groundWidth = 850;   // Reduced from 1400 (39% reduction) 
            const groundHeight = 550;  // Reduced from 1000 (45% reduction) - adjusted for river
            
            const groundGeometry = new THREE.PlaneGeometry(groundWidth, groundHeight);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x3a3a3a,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            
            // Reposition ground center to accommodate the new smaller size
            // Center adjusted to X=65, Z=-4 to properly contain all cooling towers
            ground.position.set(65, 0, -4);
            ground.receiveShadow = true;
            
            // Add ground to scene and store reference for boundary checks
            ground.userData = {
                type: 'ground',
                boundaries: {
                    minX: 65 - groundWidth/2,  // -360
                    maxX: 65 + groundWidth/2,  //  490  
                    minZ: -4 - groundHeight/2, // -279
                    maxZ: -4 + groundHeight/2  //  271
                }
            };
            
            scene.add(ground);
            
            console.log('🏗️ Ground terrain updated:');
            console.log(`   Size: ${groundWidth}×${groundHeight} (${((1400-groundWidth)/1400*100).toFixed(1)}% width reduction)`);
            console.log(`   Center: (${ground.position.x}, ${ground.position.z})`);
            console.log(`   Boundaries: X(${ground.userData.boundaries.minX} to ${ground.userData.boundaries.maxX}), Z(${ground.userData.boundaries.minZ} to ${ground.userData.boundaries.maxZ})`);
        }

        // Create road system
        function createRoads() {
            const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x2c2c2c });
            
            // Main roads
            const roads = [
                { pos: [0, 0.1, 0], size: [20, 0.1, 500] }, // Main vertical
                { pos: [0, 0.1, 0], size: [500, 0.1, 20] }, // Main horizontal
                { pos: [100, 0.1, 0], size: [15, 0.1, 500] }, // East vertical
                { pos: [-100, 0.1, 0], size: [15, 0.1, 500] }, // West vertical
                { pos: [0, 0.1, 100], size: [500, 0.1, 15] }, // North horizontal
                { pos: [0, 0.1, -100], size: [500, 0.1, 15] }, // South horizontal
            ];

            roads.forEach(road => {
                const geometry = new THREE.BoxGeometry(...road.size);
                const mesh = new THREE.Mesh(geometry, roadMaterial);
                mesh.position.set(...road.pos);
                mesh.receiveShadow = true;
                scene.add(mesh);

                // Add road markings
                const markingMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const markingGeometry = new THREE.BoxGeometry(
                    road.size[0] > 20 ? 2 : road.size[0] * 0.1,
                    0.2,
                    road.size[2] > 20 ? 2 : road.size[2] * 0.1
                );

                // Create dashed line effect
                const numMarkings = road.size[0] > road.size[2] ? 
                    Math.floor(road.size[0] / 10) : Math.floor(road.size[2] / 10);
                
                for (let i = 0; i < numMarkings; i += 2) {
                    const marking = new THREE.Mesh(markingGeometry, markingMaterial);
                    if (road.size[0] > road.size[2]) {
                        marking.position.set(
                            road.pos[0] - road.size[0]/2 + i * 10 + 5,
                            road.pos[1] + 0.1,
                            road.pos[2]
                        );
                    } else {
                        marking.position.set(
                            road.pos[0],
                            road.pos[1] + 0.1,
                            road.pos[2] - road.size[2]/2 + i * 10 + 5
                        );
                    }
                    scene.add(marking);
                }
            });
        }

        // Create central park với đường đi figure-8
        function createCentralPark(config) {
            const park = new THREE.Group();
            
            // Park base
            const parkGeometry = new THREE.BoxGeometry(config.size.x, 0.5, config.size.z);
            const parkMaterial = new THREE.MeshLambertMaterial({ color: 0x228b22 });
            const parkBase = new THREE.Mesh(parkGeometry, parkMaterial);
            parkBase.receiveShadow = true;
            park.add(parkBase);

            // Figure-8 walking paths
            const pathMaterial = new THREE.MeshLambertMaterial({ color: 0xd4a574 });
            
            // Create figure-8 path với curves
            const curve1 = new THREE.EllipseCurve(
                -30, 0, 40, 30, 0, 2 * Math.PI, false, 0
            );
            const curve2 = new THREE.EllipseCurve(
                30, 0, 40, 30, 0, 2 * Math.PI, false, 0
            );

            const points1 = curve1.getPoints(50);
            const points2 = curve2.getPoints(50);

            // Create path meshes
            [points1, points2].forEach(points => {
                points.forEach((point, i) => {
                    if (i < points.length - 1) {
                        const pathSegment = new THREE.BoxGeometry(5, 0.1, 2);
                        const pathMesh = new THREE.Mesh(pathSegment, pathMaterial);
                        pathMesh.position.set(point.x, 0.3, point.y);
                        
                        // Rotate to align with curve
                        const nextPoint = points[i + 1];
                        const angle = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);
                        pathMesh.rotation.y = -angle;
                        
                        park.add(pathMesh);
                    }
                });
            });

            // Central fountain
            const fountainGroup = new THREE.Group();
            
            // Fountain base
            const fountainBase = new THREE.Mesh(
                new THREE.CylinderGeometry(8, 10, 2, 32),
                new THREE.MeshPhongMaterial({ color: 0x808080 })
            );
            fountainBase.position.y = 1;
            fountainGroup.add(fountainBase);

            // Water effect
            const waterGeometry = new THREE.CylinderGeometry(7, 7, 3, 32);
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.7,
                shininess: 100
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.position.y = 2.5;
            fountainGroup.add(water);

            // Water jets
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const jet = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.5, 4, 8),
                    waterMaterial
                );
                jet.position.set(
                    Math.cos(angle) * 5,
                    4,
                    Math.sin(angle) * 5
                );
                fountainGroup.add(jet);
            }

            park.add(fountainGroup);

            // Circular benches around fountain
            const benchMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const bench = new THREE.Group();
                
                // Bench seat
                const seat = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 0.5, 1),
                    benchMaterial
                );
                seat.position.y = 1;
                bench.add(seat);
                
                // Bench back
                const back = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 1.5, 0.2),
                    benchMaterial
                );
                back.position.set(0, 1.75, -0.4);
                bench.add(back);
                
                bench.position.set(
                    Math.cos(angle) * 15,
                    0,
                    Math.sin(angle) * 15
                );
                bench.rotation.y = -angle;
                park.add(bench);
            }

            // Park entrances (4 points)
            const entrances = [
                { x: 0, z: config.size.z/2 - 5 },    // North
                { x: 0, z: -config.size.z/2 + 5 },   // South
                { x: config.size.x/2 - 5, z: 0 },    // East
                { x: -config.size.x/2 + 5, z: 0 }    // West
            ];

            entrances.forEach(entrance => {
                const gate = new THREE.Group();
                
                // Gate pillars
                for (let side = -1; side <= 1; side += 2) {
                    const pillar = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 4, 1),
                        new THREE.MeshPhongMaterial({ color: 0x808080 })
                    );
                    pillar.position.set(side * 3, 2, 0);
                    gate.add(pillar);
                }
                
                // Gate arch
                const arch = new THREE.Mesh(
                    new THREE.BoxGeometry(7, 1, 1),
                    new THREE.MeshPhongMaterial({ color: 0x808080 })
                );
                arch.position.y = 4.5;
                gate.add(arch);
                
                gate.position.set(entrance.x, 0, entrance.z);
                if (entrance.x !== 0) gate.rotation.y = Math.PI / 2;
                park.add(gate);
            });

            // Decorative elements
            // Flower beds
            const flowerColors = [0xff1493, 0xffff00, 0xff6347, 0xda70d6];
            for (let i = 0; i < 20; i++) {
                const flower = new THREE.Mesh(
                    new THREE.SphereGeometry(1, 8, 8),
                    new THREE.MeshPhongMaterial({ 
                        color: flowerColors[Math.floor(Math.random() * flowerColors.length)]
                    })
                );
                flower.position.set(
                    (Math.random() - 0.5) * config.size.x * 0.8,
                    0.5,
                    (Math.random() - 0.5) * config.size.z * 0.8
                );
                park.add(flower);
            }

            park.position.set(config.position.x, 0, config.position.z);
            return park;
        }

        // Create small parks với playgrounds
        function createSmallPark(config) {
            const park = new THREE.Group();
            
            // Park base
            const parkGeometry = new THREE.BoxGeometry(config.size.x, 0.5, config.size.z);
            const parkMaterial = new THREE.MeshLambertMaterial({ color: 0x2d5016 });
            const parkBase = new THREE.Mesh(parkGeometry, parkMaterial);
            parkBase.receiveShadow = true;
            park.add(parkBase);

            // Playground equipment
            const playgroundGroup = new THREE.Group();
            
            // Slide
            const slideGroup = new THREE.Group();
            // Slide structure
            const slideBase = new THREE.Mesh(
                new THREE.BoxGeometry(2, 4, 6),
                new THREE.MeshPhongMaterial({ color: 0xff4500 })
            );
            slideBase.position.set(0, 2, 0);
            slideGroup.add(slideBase);
            
            // Slide surface
            const slideSurface = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 0.2, 6),
                new THREE.MeshPhongMaterial({ color: 0xffff00 })
            );
            slideSurface.position.set(0, 2.5, 0);
            slideSurface.rotation.x = -0.3;
            slideGroup.add(slideSurface);
            
            // Ladder
            for (let i = 0; i < 5; i++) {
                const step = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 0.2, 0.5),
                    new THREE.MeshPhongMaterial({ color: 0x8b4513 })
                );
                step.position.set(0, i * 0.8, -3);
                slideGroup.add(step);
            }
            
            slideGroup.position.set(-10, 0, 0);
            playgroundGroup.add(slideGroup);

            // Swings
            const swingSet = new THREE.Group();
            
            // Swing frame
            const frameMaterial = new THREE.MeshPhongMaterial({ color: 0x4169e1 });
            // A-frame sides
            for (let side = -1; side <= 1; side += 2) {
                const sideFrame = new THREE.Group();
                
                const leg1 = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 5, 8),
                    frameMaterial
                );
                leg1.position.set(side * 2, 2.5, -1);
                leg1.rotation.z = side * 0.2;
                sideFrame.add(leg1);
                
                const leg2 = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 5, 8),
                    frameMaterial
                );
                leg2.position.set(side * 2, 2.5, 1);
                leg2.rotation.z = side * 0.2;
                sideFrame.add(leg2);
                
                swingSet.add(sideFrame);
            }
            
            // Top bar
            const topBar = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 6, 8),
                frameMaterial
            );
            topBar.position.y = 4.5;
            topBar.rotation.z = Math.PI / 2;
            swingSet.add(topBar);
            
            // Swings (3)
            for (let i = -1; i <= 1; i++) {
                const swing = new THREE.Group();
                
                // Chains
                const chainMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 });
                for (let side = -0.3; side <= 0.3; side += 0.6) {
                    const chain = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05, 0.05, 3, 4),
                        chainMaterial
                    );
                    chain.position.set(side, 3, 0);
                    swing.add(chain);
                }
                
                // Seat
                const seat = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.1, 0.4),
                    new THREE.MeshPhongMaterial({ color: 0x000000 })
                );
                seat.position.y = 1.5;
                swing.add(seat);
                
                swing.position.x = i * 1.5;
                swingSet.add(swing);
            }
            
            swingSet.position.set(5, 0, 0);
            playgroundGroup.add(swingSet);

            // Seesaw
            const seesawGroup = new THREE.Group();
            
            // Base
            const seesawBase = new THREE.Mesh(
                new THREE.ConeGeometry(0.5, 1, 4),
                new THREE.MeshPhongMaterial({ color: 0x32cd32 })
            );
            seesawBase.position.y = 0.5;
            seesawGroup.add(seesawBase);
            
            // Plank
            const plank = new THREE.Mesh(
                new THREE.BoxGeometry(6, 0.3, 0.8),
                new THREE.MeshPhongMaterial({ color: 0x8b4513 })
            );
            plank.position.y = 1;
            seesawGroup.add(plank);
            
            // Handles
            for (let side = -1; side <= 1; side += 2) {
                const handle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8),
                    new THREE.MeshPhongMaterial({ color: 0xff0000 })
                );
                handle.position.set(side * 2.5, 1.4, 0);
                seesawGroup.add(handle);
            }
            
            seesawGroup.position.set(0, 0, 8);
            playgroundGroup.add(seesawGroup);

            // Sandbox
            const sandbox = new THREE.Group();
            
            // Sandbox walls
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
            const walls = [
                { pos: [0, 0.5, 2], size: [4, 1, 0.2] },
                { pos: [0, 0.5, -2], size: [4, 1, 0.2] },
                { pos: [2, 0.5, 0], size: [0.2, 1, 4] },
                { pos: [-2, 0.5, 0], size: [0.2, 1, 4] }
            ];
            
            walls.forEach(wall => {
                const wallMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(...wall.size),
                    wallMaterial
                );
                wallMesh.position.set(...wall.pos);
                sandbox.add(wallMesh);
            });
            
            // Sand
            const sand = new THREE.Mesh(
                new THREE.BoxGeometry(3.8, 0.8, 3.8),
                new THREE.MeshLambertMaterial({ color: 0xf4a460 })
            );
            sand.position.y = 0.4;
            sandbox.add(sand);
            
            sandbox.position.set(10, 0, -5);
            playgroundGroup.add(sandbox);

            playgroundGroup.position.set(0, 0.3, 0);
            park.add(playgroundGroup);

            // Walking path around playground
            const pathMaterial = new THREE.MeshLambertMaterial({ color: 0xd4a574 });
            const pathWidth = 2;
            const paths = [
                { pos: [0, 0.3, config.size.z/2 - 2], size: [config.size.x - 4, 0.1, pathWidth] },
                { pos: [0, 0.3, -config.size.z/2 + 2], size: [config.size.x - 4, 0.1, pathWidth] },
                { pos: [config.size.x/2 - 2, 0.3, 0], size: [pathWidth, 0.1, config.size.z - 4] },
                { pos: [-config.size.x/2 + 2, 0.3, 0], size: [pathWidth, 0.1, config.size.z - 4] }
            ];
            
            paths.forEach(path => {
                const pathMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(...path.size),
                    pathMaterial
                );
                pathMesh.position.set(...path.pos);
                park.add(pathMesh);
            });

            // Park benches
            const benchPositions = [
                { x: -config.size.x/2 + 5, z: config.size.z/2 - 5 },
                { x: config.size.x/2 - 5, z: config.size.z/2 - 5 },
                { x: -config.size.x/2 + 5, z: -config.size.z/2 + 5 },
                { x: config.size.x/2 - 5, z: -config.size.z/2 + 5 }
            ];
            
            benchPositions.forEach(pos => {
                const bench = createBench();
                bench.position.set(pos.x, 0, pos.z);
                park.add(bench);
            });

            // Small trees in park
            for (let i = 0; i < 5; i++) {
                const tree = createTree();
                tree.position.set(
                    (Math.random() - 0.5) * config.size.x * 0.8,
                    0,
                    (Math.random() - 0.5) * config.size.z * 0.8
                );
                tree.scale.setScalar(0.8);
                park.add(tree);
            }

            park.position.set(config.position.x, 0, config.position.z);
            return park;
        }

        // Collision detection for layout validation
        function validateParkRoadLayout() {
            const roadBoundaries = [
                { name: 'Main Vertical', x: [-10, 10], z: [-250, 250] },
                { name: 'Main Horizontal', x: [-250, 250], z: [-10, 10] },
                { name: 'East Vertical', x: [92.5, 107.5], z: [-250, 250] },
                { name: 'West Vertical', x: [-107.5, -92.5], z: [-250, 250] },
                { name: 'North Horizontal', x: [-250, 250], z: [92.5, 107.5] },
                { name: 'South Horizontal', x: [-250, 250], z: [-107.5, -92.5] }
            ];
            
            let conflicts = 0;
            
            parkConfigs.forEach((config, index) => {
                const parkX = [config.position.x - config.size.x/2, config.position.x + config.size.x/2];
                const parkZ = [config.position.z - config.size.z/2, config.position.z + config.size.z/2];
                
                roadBoundaries.forEach(road => {
                    // Check for overlap
                    if (parkX[0] < road.x[1] && parkX[1] > road.x[0] && 
                        parkZ[0] < road.z[1] && parkZ[1] > road.z[0]) {
                        console.warn(`⚠️ Park ${index} conflicts with ${road.name}`);
                        conflicts++;
                    }
                });
            });
            
            if (conflicts === 0) {
                console.log('✅ All parks positioned safely - no road conflicts!');
            }
            return conflicts === 0;
        }

        // Create all parks with validation
        function createParks() {
            // Validate layout before creating parks
            if (!validateParkRoadLayout()) {
                console.error('❌ Park-road conflicts detected! Check layout.');
            }
            
            parkConfigs.forEach(config => {
                let park;
                if (config.type === 'central') {
                    park = createCentralPark(config);
                } else {
                    park = createSmallPark(config);
                }
                parks.push(park);
                scene.add(park);
            });
            
            console.log(`🌳 Created ${parkConfigs.length} parks in conflict-free zones`);
        }

        // Create tree system
        function createTree() {
            const tree = new THREE.Group();
            
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 5, 8);
            const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2.5;
            trunk.castShadow = true;
            tree.add(trunk);
            
            // Crown variations
            const crownTypes = [
                { geometry: new THREE.SphereGeometry(3, 12, 8), yOffset: 6 },
                { geometry: new THREE.ConeGeometry(3, 5, 12), yOffset: 7 },
                { geometry: new THREE.DodecahedronGeometry(3), yOffset: 6 }
            ];
            
            const crownType = crownTypes[Math.floor(Math.random() * crownTypes.length)];
            const crownMaterial = new THREE.MeshPhongMaterial({ 
                color: new THREE.Color().setHSL(0.25, 0.8, 0.25 + Math.random() * 0.1)
            });
            
            const crown = new THREE.Mesh(crownType.geometry, crownMaterial);
            crown.position.y = crownType.yOffset;
            crown.castShadow = true;
            tree.add(crown);
            
            return tree;
        }

        // Create comprehensive tree distribution
        function createTrees() {
            // Trees in central park (20+)
            for (let i = 0; i < 25; i++) {
                const tree = createTree();
                const angle = Math.random() * Math.PI * 2;
                const radius = 30 + Math.random() * 60;
                tree.position.set(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
                trees.push(tree);
                scene.add(tree);
            }

            // Street trees along boulevards (every 25m)
            const streetTreePositions = [];
            
            // Main vertical streets
            for (let z = -200; z <= 200; z += 25) {
                streetTreePositions.push({ x: -110, z: z });
                streetTreePositions.push({ x: -90, z: z });
                streetTreePositions.push({ x: 90, z: z });
                streetTreePositions.push({ x: 110, z: z });
            }
            
            // Main horizontal streets
            for (let x = -200; x <= 200; x += 25) {
                if (Math.abs(x) > 20) { // Avoid center
                    streetTreePositions.push({ x: x, z: -110 });
                    streetTreePositions.push({ x: x, z: -90 });
                    streetTreePositions.push({ x: x, z: 90 });
                    streetTreePositions.push({ x: x, z: 110 });
                }
            }
            
            streetTreePositions.forEach(pos => {
                const tree = createTree();
                tree.position.set(pos.x, 0, pos.z);
                tree.scale.setScalar(0.8);
                trees.push(tree);
                scene.add(tree);
            });
        }

        // Create buildings
        function createBuildings() {
            const buildingPositions = [
                // PHASE 1 - COMPLETED (Blue/Gray)
                { x: -150, z: -150, type: 'office_tower', phase: 'phase1' },
                { x: -120, z: -150, type: 'tech_campus', phase: 'phase1' },
                { x: 80, z: 150, type: 'residential_tower', phase: 'phase1' },
                { x: 120, z: 150, type: 'residential_tower', phase: 'phase1' },
                { x: -150, z: 150, type: 'commercial_center', phase: 'phase1' },
                { x: -180, z: 40, type: 'medical_center', phase: 'phase1' },
                
                // PHASE 2 - UNDER CONSTRUCTION (Orange)
                { x: -150, z: -120, type: 'office_tower', phase: 'phase2' },
                { x: 50, z: 130, type: 'residential_tower', phase: 'phase2' },
                { x: -120, z: 130, type: 'education_hub', phase: 'phase2' },
                { x: 50, z: -150, type: 'tech_campus', phase: 'phase2' },
                { x: -50, z: -150, type: 'office_tower', phase: 'phase2' },
                { x: 50, z: 160, type: 'commercial_center', phase: 'phase2' },
                
                // PHASE 3 - PLANNED (Green/Transparent)
                { x: 120, z: -120, type: 'tech_campus', phase: 'phase3' },
                { x: -70, z: -150, type: 'office_tower', phase: 'phase3' },
                { x: -50, z: 160, type: 'commercial_center', phase: 'phase3' },
                { x: -90, z: 130, type: 'education_hub', phase: 'phase3' }
            ];

            buildingPositions.forEach(pos => {
                const building = createBuilding(pos.type, pos.x, pos.z, pos.phase);
                buildings.push(building);
                buildingPhases[pos.phase].buildings.push(building);
                scene.add(building);
                
                // Add 2-3 decorative trees around each building
                for (let i = 0; i < 2 + Math.floor(Math.random() * 2); i++) {
                    const tree = createTree();
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 15 + Math.random() * 10;
                    tree.position.set(
                        pos.x + Math.cos(angle) * distance,
                        0,
                        pos.z + Math.sin(angle) * distance
                    );
                    tree.scale.setScalar(0.7);
                    trees.push(tree);
                    scene.add(tree);
                }
            });
        }

        // Create detailed building with phase
        function createBuilding(type, x, z, phase = 'phase1') {
            const building = new THREE.Group();
            const config = buildingTypes[type];
            const height = config.minHeight + Math.random() * (config.maxHeight - config.minHeight);
            
            // Phase-specific color override
            const phaseColor = phaseColors[phase];
            
            // Base structure with phase-specific properties
            const baseGeometry = new THREE.BoxGeometry(20, height, 20);
            let baseMaterial;
            
            if (phase === 'phase3') {
                // Planned buildings - transparent wireframe
                baseMaterial = new THREE.MeshPhongMaterial({ 
                    color: phaseColor,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.4,
                    wireframe: true
                });
            } else {
                // Completed and construction buildings
                baseMaterial = new THREE.MeshPhongMaterial({ 
                    color: phaseColor,
                    shininess: phase === 'phase1' ? 100 : 50
                });
            }
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = height / 2;
            base.castShadow = true;
            base.receiveShadow = true;
            building.add(base);

            // Glass windows pattern
            const windowMaterial = new THREE.MeshPhongMaterial({
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.6,
                shininess: 200
            });

            for (let floor = 0; floor < Math.floor(height / 3); floor++) {
                for (let side = 0; side < 4; side++) {
                    for (let window = 0; window < 4; window++) {
                        const windowMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 2, 0.1),
                            windowMaterial
                        );
                        
                        const angle = (side * Math.PI) / 2;
                        const radius = 10.05;
                        windowMesh.position.set(
                            Math.cos(angle) * radius + Math.sin(angle) * (window - 1.5) * 4,
                            floor * 3 + 1.5,
                            Math.sin(angle) * radius - Math.cos(angle) * (window - 1.5) * 4
                        );
                        windowMesh.rotation.y = angle;
                        building.add(windowMesh);
                    }
                }
            }

            // Rooftop features
            if (type === 'office_tower' || type === 'tech_campus') {
                // Helipad
                const helipadGroup = new THREE.Group();
                const helipad = new THREE.Mesh(
                    new THREE.CylinderGeometry(8, 8, 0.5, 32),
                    new THREE.MeshPhongMaterial({ color: 0x333333 })
                );
                helipad.position.y = height + 0.25;
                helipadGroup.add(helipad);
                
                // H marking
                const hMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const hParts = [
                    { pos: [0, height + 0.5, 0], size: [1, 0.1, 4] },
                    { pos: [-1.5, height + 0.5, 0], size: [1, 0.1, 4] },
                    { pos: [1.5, height + 0.5, 0], size: [1, 0.1, 4] },
                    { pos: [0, height + 0.5, 0], size: [4, 0.1, 1] }
                ];
                
                hParts.forEach(part => {
                    const mesh = new THREE.Mesh(
                        new THREE.BoxGeometry(...part.size),
                        hMaterial
                    );
                    mesh.position.set(...part.pos);
                    helipadGroup.add(mesh);
                });
                
                building.add(helipadGroup);
            }

            // Solar panels for eco buildings
            if (type === 'tech_campus' || type === 'education_hub') {
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        const panel = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 0.3, 2),
                            new THREE.MeshPhongMaterial({ 
                                color: 0x00008b,
                                shininess: 150
                            })
                        );
                        panel.position.set(
                            (i - 1.5) * 4,
                            height + 0.5,
                            (j - 1.5) * 3
                        );
                        panel.rotation.x = -0.2;
                        building.add(panel);
                    }
                }
            }

            // LED strips for modern buildings
            if (type === 'commercial_center' || type === 'residential_tower') {
                const ledMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.5
                });
                
                for (let i = 0; i < 4; i++) {
                    const led = new THREE.Mesh(
                        new THREE.BoxGeometry(19.5, 0.5, 0.1),
                        ledMaterial
                    );
                    const angle = (i * Math.PI) / 2;
                    led.position.set(
                        Math.cos(angle) * 10.1,
                        height - 1,
                        Math.sin(angle) * 10.1
                    );
                    led.rotation.y = angle;
                    building.add(led);
                }
            }

            // Add construction elements for phase 2
            if (phase === 'phase2') {
                addConstructionElements(building, height);
            }
            
            // Store building info
            building.userData = {
                type: type,
                name: config.name,
                height: Math.floor(height),
                floors: Math.floor(height / 3),
                features: config.features,
                phase: phase,
                phaseColor: phaseColor
            };

            building.position.set(x, 0, z);
            return building;
        }
        
        // Add construction elements for phase 2 buildings
        function addConstructionElements(building, height) {
            // Construction crane
            const craneGroup = new THREE.Group();
            
            // Crane mast
            const craneMast = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.5, height + 20, 8),
                new THREE.MeshPhongMaterial({ color: 0xffff00 })
            );
            craneMast.position.set(15, (height + 20) / 2, 15);
            craneGroup.add(craneMast);
            
            // Crane arm
            const craneArm = new THREE.Mesh(
                new THREE.BoxGeometry(30, 1, 1),
                new THREE.MeshPhongMaterial({ color: 0xffff00 })
            );
            craneArm.position.set(0, height + 15, 15);
            craneGroup.add(craneArm);
            
            // Hook
            const hook = new THREE.Mesh(
                new THREE.BoxGeometry(2, 2, 2),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            hook.position.set(-10, height + 5, 15);
            craneGroup.add(hook);
            
            building.add(craneGroup);
            
            // Scaffolding
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2;
                const scaffoldX = Math.cos(angle) * 12;
                const scaffoldZ = Math.sin(angle) * 12;
                
                const scaffold = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, height * 0.8, 0.3),
                    new THREE.MeshPhongMaterial({ color: 0x8b4513 })
                );
                scaffold.position.set(scaffoldX, height * 0.4, scaffoldZ);
                building.add(scaffold);
                
                // Horizontal scaffold bars
                for (let j = 0; j < Math.floor(height / 10); j++) {
                    const bar = new THREE.Mesh(
                        new THREE.BoxGeometry(24, 0.2, 0.2),
                        new THREE.MeshPhongMaterial({ color: 0x8b4513 })
                    );
                    bar.position.set(0, j * 10 + 5, scaffoldZ);
                    building.add(bar);
                }
            }
            
            // Construction materials
            for (let i = 0; i < 3; i++) {
                const material = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 2, 3),
                    new THREE.MeshPhongMaterial({ color: 0x654321 })
                );
                material.position.set(
                    (Math.random() - 0.5) * 15,
                    1,
                    (Math.random() - 0.5) * 15
                );
                building.add(material);
            }
        }

        // Create parking infrastructure
        function createParkingInfrastructure() {
            // REMOVED: 3-story parking garage - replaced with green park space
            // const parkingGarage = createParkingGarage(-50, 50);  // REMOVED
            // scene.add(parkingGarage);  // REMOVED
            
            // Add green park space where the parking garage was located
            const parkSpace = createParkGreenSpace(-50, 50);
            scene.add(parkSpace);
            
            // Surface parking lots
            const parkingLotPositions = [
                { x: -120, z: 50, width: 40, depth: 30 },
                { x: 120, z: -50, width: 35, depth: 40 },
                { x: 50, z: 50, width: 45, depth: 35 },
                { x: -50, z: -50, width: 40, depth: 40 }
            ];
            
            parkingLotPositions.forEach(lot => {
                const parkingLot = createParkingLot(lot);
                parkingLots.push(parkingLot);
                scene.add(parkingLot);
            });

            // Street parking along main roads
            createStreetParking();
        }

        // REMOVED: 3-story parking garage function - replaced with green park space
        // This entire function has been removed to eliminate the multi-level parking structure
        // The parking garage at position (-50, 50) has been replaced with green park space
        // Surface parking lots are preserved and unaffected by this removal
        
        // Create green park space to replace the removed multi-level parking garage
        function createParkGreenSpace(x, z) {
            const parkSpace = new THREE.Group();
            
            // Same dimensions as the removed parking garage for proper coverage
            const width = 50;
            const depth = 40;
            
            // Green grass base to cover the entire area
            const grassGeometry = new THREE.PlaneGeometry(width, depth);
            const grassMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4a7c59,  // Natural grass green
                side: THREE.DoubleSide 
            });
            const grassBase = new THREE.Mesh(grassGeometry, grassMaterial);
            grassBase.rotation.x = -Math.PI / 2;
            grassBase.position.y = 0.01; // Slightly above ground to prevent z-fighting
            grassBase.receiveShadow = true;
            parkSpace.add(grassBase);
            
            // Add scattered trees for natural park appearance
            const treePositions = [
                { x: -15, z: -10 },   // Front left area
                { x: 10, z: -15 },    // Front right area  
                { x: -8, z: 8 },      // Center left
                { x: 18, z: 12 },     // Center right
                { x: -20, z: 15 },    // Back left
                { x: 5, z: 18 },      // Back center
            ];
            
            treePositions.forEach(pos => {
                const tree = createParkTree();
                tree.position.set(pos.x, 0, pos.z);
                // Add slight random rotation for natural variation
                tree.rotation.y = Math.random() * Math.PI * 2;
                parkSpace.add(tree);
            });
            
            // Add a few decorative bushes
            const bushPositions = [
                { x: 0, z: -8 },      // Front center
                { x: -12, z: 5 },     // Mid left
                { x: 15, z: -5 },     // Mid right
            ];
            
            bushPositions.forEach(pos => {
                const bush = createParkBush();
                bush.position.set(pos.x, 0, pos.z);
                bush.rotation.y = Math.random() * Math.PI * 2;
                parkSpace.add(bush);
            });
            
            parkSpace.position.set(x, 0, z);
            parkSpace.userData = { 
                type: 'park_green_space', 
                description: 'Green park area replacing former multi-level parking garage',
                area: width * depth + ' sq units'
            };
            
            return parkSpace;
        }
        
        // Create a single park tree
        function createParkTree() {
            const tree = new THREE.Group();
            
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 4);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // Brown
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2;
            trunk.castShadow = true;
            tree.add(trunk);
            
            // Tree canopy (foliage)
            const canopyGeometry = new THREE.SphereGeometry(3, 16, 16);
            const canopyMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 }); // Forest green
            const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
            canopy.position.y = 5.5;
            canopy.castShadow = true;
            tree.add(canopy);
            
            return tree;
        }
        
        // Create a decorative bush
        function createParkBush() {
            const bush = new THREE.Group();
            
            // Small bush - hemisphere shape
            const bushGeometry = new THREE.SphereGeometry(1.2, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const bushMaterial = new THREE.MeshLambertMaterial({ color: 0x32CD32 }); // Lime green
            const bushMesh = new THREE.Mesh(bushGeometry, bushMaterial);
            bushMesh.position.y = 1.2;
            bushMesh.castShadow = true;
            bush.add(bushMesh);
            
            return bush;
        }

        // Create surface parking lot
        function createParkingLot(config) {
            const lot = new THREE.Group();
            
            // Asphalt base
            const asphalt = new THREE.Mesh(
                new THREE.BoxGeometry(config.width, 0.1, config.depth),
                new THREE.MeshLambertMaterial({ color: 0x2c2c2c })
            );
            asphalt.receiveShadow = true;
            lot.add(asphalt);
            
            // Parking space markings
            const markingMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const spaceWidth = 3;
            const spaceDepth = 5;
            const rows = Math.floor(config.depth / (spaceDepth * 2));
            const cols = Math.floor(config.width / spaceWidth);
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    // Space lines
                    const lines = [
                        { // Front line
                            size: [spaceWidth, 0.05, 0.1],
                            pos: [
                                -config.width/2 + col * spaceWidth + spaceWidth/2,
                                0.05,
                                -config.depth/2 + row * spaceDepth * 2 + spaceDepth/2
                            ]
                        },
                        { // Side line
                            size: [0.1, 0.05, spaceDepth],
                            pos: [
                                -config.width/2 + col * spaceWidth,
                                0.05,
                                -config.depth/2 + row * spaceDepth * 2 + spaceDepth
                            ]
                        }
                    ];
                    
                    lines.forEach(line => {
                        const marking = new THREE.Mesh(
                            new THREE.BoxGeometry(...line.size),
                            markingMaterial
                        );
                        marking.position.set(...line.pos);
                        lot.add(marking);
                    });
                    
                    // Add parked cars randomly
                    if (Math.random() > 0.4) { // 60% occupancy
                        const car = createCar();
                        car.position.set(
                            -config.width/2 + col * spaceWidth + spaceWidth/2,
                            0.1,
                            -config.depth/2 + row * spaceDepth * 2 + spaceDepth
                        );
                        car.rotation.y = row % 2 === 0 ? 0 : Math.PI;
                        lot.add(car);
                    }
                }
            }
            
            // Light poles
            for (let i = 0; i < 4; i++) {
                const pole = createLightPole();
                pole.position.set(
                    (i % 2 === 0 ? -1 : 1) * config.width/2 * 0.8,
                    0,
                    (i < 2 ? -1 : 1) * config.depth/2 * 0.8
                );
                lot.add(pole);
            }
            
            lot.position.set(config.x, 0, config.z);
            lot.userData = { type: 'parking_lot', capacity: rows * cols };
            
            return lot;
        }

        // Create street parking
        function createStreetParking() {
            const parkingSpaces = [];
            
            // Along main streets
            const streetParkingAreas = [
                { start: -150, end: -30, z: -12, facing: 0 },
                { start: 30, end: 150, z: -12, facing: 0 },
                { start: -150, end: -30, z: 12, facing: Math.PI },
                { start: 30, end: 150, z: 12, facing: Math.PI }
            ];
            
            streetParkingAreas.forEach(area => {
                for (let x = area.start; x <= area.end; x += 8) {
                    if (Math.random() > 0.3) {
                        const car = createCar();
                        car.position.set(x, 0, area.z);
                        car.rotation.y = area.facing;
                        vehicles.push(car);
                        scene.add(car);
                    }
                    
                    // Parking meter
                    if (x % 16 === 0) {
                        const meter = createParkingMeter();
                        meter.position.set(x, 0, area.z + (area.facing === 0 ? -3 : 3));
                        streetFurniture.push(meter);
                        scene.add(meter);
                    }
                }
            });
        }

        // Create car model
        function createCar() {
            const car = new THREE.Group();
            
            const colors = [0xff0000, 0x0000ff, 0x00ff00, 0xffff00, 0x000000, 0xffffff, 0xff6600];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            // Car body
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: color });
            
            // Main body
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(4, 1, 2),
                bodyMaterial
            );
            body.position.y = 0.5;
            car.add(body);
            
            // Cabin
            const cabin = new THREE.Mesh(
                new THREE.BoxGeometry(2.5, 0.8, 1.8),
                bodyMaterial
            );
            cabin.position.set(0, 1.2, 0);
            car.add(cabin);
            
            // Windows
            const windowMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x303030,
                transparent: true,
                opacity: 0.6
            });
            
            const frontWindow = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.6, 1.6),
                windowMaterial
            );
            frontWindow.position.set(1.2, 1.2, 0);
            car.add(frontWindow);
            
            const backWindow = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.6, 1.6),
                windowMaterial
            );
            backWindow.position.set(-1.2, 1.2, 0);
            car.add(backWindow);
            
            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            
            const wheelPositions = [
                { x: 1.5, y: 0.3, z: 0.8 },
                { x: 1.5, y: 0.3, z: -0.8 },
                { x: -1.5, y: 0.3, z: 0.8 },
                { x: -1.5, y: 0.3, z: -0.8 }
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.rotation.z = Math.PI / 2;
                car.add(wheel);
            });
            
            // Headlights
            const headlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff99 });
            for (let side = -0.5; side <= 0.5; side += 1) {
                const headlight = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    headlightMaterial
                );
                headlight.position.set(2, 0.5, side);
                car.add(headlight);
            }
            
            return car;
        }

        // Create street furniture
        function createStreetFurniture() {
            // Benches throughout the city
            const benchLocations = [
                { x: -30, z: 30 }, { x: 30, z: 30 },
                { x: -30, z: -30 }, { x: 30, z: -30 },
                { x: -70, z: 0 }, { x: 70, z: 0 },
                { x: 0, z: -70 }, { x: 0, z: 70 },
                { x: -130, z: 60 }, { x: 130, z: -60 },
                { x: -60, z: 130 }, { x: 60, z: -130 }
            ];
            
            benchLocations.forEach(loc => {
                const bench = createBench();
                bench.position.set(loc.x, 0, loc.z);
                bench.rotation.y = Math.random() * Math.PI;
                streetFurniture.push(bench);
                scene.add(bench);
            });
            
            // Trash bins
            const trashLocations = [
                { x: -25, z: 25 }, { x: 25, z: 25 },
                { x: -25, z: -25 }, { x: 25, z: -25 },
                { x: -100, z: 0 }, { x: 100, z: 0 },
                { x: 0, z: -100 }, { x: 0, z: 100 },
                { x: -140, z: 70 }, { x: 140, z: -70 }
            ];
            
            trashLocations.forEach(loc => {
                const trashBin = createTrashBin();
                trashBin.position.set(loc.x, 0, loc.z);
                streetFurniture.push(trashBin);
                scene.add(trashBin);
            });
            
            // Bus stops
            const busStopLocations = [
                { x: -100, z: -50, rotation: 0 },
                { x: 100, z: 50, rotation: Math.PI },
                { x: -50, z: 100, rotation: Math.PI/2 },
                { x: 50, z: -100, rotation: -Math.PI/2 }
            ];
            
            busStopLocations.forEach(loc => {
                const busStop = createBusStop();
                busStop.position.set(loc.x, 0, loc.z);
                busStop.rotation.y = loc.rotation;
                streetFurniture.push(busStop);
                scene.add(busStop);
            });
        }

        // Create bench
        function createBench() {
            const bench = new THREE.Group();
            
            const woodMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
            const metalMaterial = new THREE.MeshPhongMaterial({ color: 0x404040 });
            
            // Seat
            const seat = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.3, 1),
                woodMaterial
            );
            seat.position.y = 1;
            bench.add(seat);
            
            // Back
            const back = new THREE.Mesh(
                new THREE.BoxGeometry(4, 1.2, 0.2),
                woodMaterial
            );
            back.position.set(0, 1.6, -0.4);
            bench.add(back);
            
            // Legs
            const legPositions = [
                { x: -1.8, z: 0.3 },
                { x: 1.8, z: 0.3 },
                { x: -1.8, z: -0.3 },
                { x: 1.8, z: -0.3 }
            ];
            
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 1, 8),
                    metalMaterial
                );
                leg.position.set(pos.x, 0.5, pos.z);
                bench.add(leg);
            });
            
            // Armrests
            for (let side = -1; side <= 1; side += 2) {
                const armrest = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.8, 1),
                    metalMaterial
                );
                armrest.position.set(side * 2, 1.2, 0);
                bench.add(armrest);
            }
            
            return bench;
        }

        // Create trash bin
        function createTrashBin() {
            const bin = new THREE.Group();
            
            // Main cylinder
            const binBody = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.6, 1.5, 12),
                new THREE.MeshPhongMaterial({ color: 0x2f4f2f })
            );
            binBody.position.y = 0.75;
            bin.add(binBody);
            
            // Lid
            const lid = new THREE.Mesh(
                new THREE.CylinderGeometry(0.6, 0.5, 0.2, 12),
                new THREE.MeshPhongMaterial({ color: 0x1c1c1c })
            );
            lid.position.y = 1.6;
            bin.add(lid);
            
            // Opening
            const opening = new THREE.Mesh(
                new THREE.TorusGeometry(0.3, 0.1, 8, 12),
                new THREE.MeshPhongMaterial({ color: 0x000000 })
            );
            opening.position.y = 1.7;
            opening.rotation.x = Math.PI / 2;
            bin.add(opening);
            
            return bin;
        }

        // Create bus stop
        function createBusStop() {
            const busStop = new THREE.Group();
            
            const metalMaterial = new THREE.MeshPhongMaterial({ color: 0x606060 });
            const glassMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.3
            });
            
            // Support posts
            const postPositions = [
                { x: -2, z: -0.5 },
                { x: 2, z: -0.5 },
                { x: -2, z: 0.5 },
                { x: 2, z: 0.5 }
            ];
            
            postPositions.forEach(pos => {
                const post = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 3, 8),
                    metalMaterial
                );
                post.position.set(pos.x, 1.5, pos.z);
                busStop.add(post);
            });
            
            // Roof
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(5, 0.2, 2),
                metalMaterial
            );
            roof.position.y = 3;
            busStop.add(roof);
            
            // Back panel
            const backPanel = new THREE.Mesh(
                new THREE.BoxGeometry(4.5, 2.5, 0.1),
                glassMaterial
            );
            backPanel.position.set(0, 1.5, -0.5);
            busStop.add(backPanel);
            
            // Side panels
            for (let side = -1; side <= 1; side += 2) {
                const sidePanel = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 2.5, 1),
                    glassMaterial
                );
                sidePanel.position.set(side * 2.25, 1.5, 0);
                busStop.add(sidePanel);
            }
            
            // Bench
            const benchSeat = new THREE.Mesh(
                new THREE.BoxGeometry(3.5, 0.2, 0.8),
                new THREE.MeshPhongMaterial({ color: 0x8b4513 })
            );
            benchSeat.position.set(0, 0.8, 0);
            busStop.add(benchSeat);
            
            // Sign post
            const signPost = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 4, 8),
                metalMaterial
            );
            signPost.position.set(2.5, 2, 0);
            busStop.add(signPost);
            
            // Bus stop sign
            const sign = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 0.1),
                new THREE.MeshPhongMaterial({ color: 0x0000ff })
            );
            sign.position.set(2.5, 3.5, 0);
            busStop.add(sign);
            
            return busStop;
        }

        // Create infrastructure elements
        function createInfrastructure() {
            // Street lights every 40m
            const streetLightPositions = [];
            
            // Along main roads AND connecting highway to data center
            for (let i = -200; i <= 200; i += 40) {
                // Vertical roads
                streetLightPositions.push({ x: -15, z: i });
                streetLightPositions.push({ x: 15, z: i });
                streetLightPositions.push({ x: -105, z: i });
                streetLightPositions.push({ x: 105, z: i });
                
                // Horizontal roads
                if (Math.abs(i) > 20) {
                    streetLightPositions.push({ x: i, z: -15 });
                    streetLightPositions.push({ x: i, z: 15 });
                    streetLightPositions.push({ x: i, z: -105 });
                    streetLightPositions.push({ x: i, z: 105 });
                }
            }
            
            // Street lights along connecting highway to data center
            for (let i = 120; i <= 400; i += 50) {
                streetLightPositions.push({ x: i, z: -8 }); // North side of highway
                streetLightPositions.push({ x: i, z: 8 });  // South side of highway
            }
            
            streetLightPositions.forEach(pos => {
                const light = createStreetLight();
                light.position.set(pos.x, 0, pos.z);
                lights.push(light);
                scene.add(light);
            });
            
            // Traffic lights at major intersections AND data center entrance
            const intersections = [
                { x: -100, z: -100 },
                { x: 100, z: -100 },
                { x: -100, z: 100 },
                { x: 100, z: 100 },
                { x: 0, z: -100 },
                { x: 0, z: 100 },
                { x: -100, z: 0 },
                { x: 100, z: 0 },
                // Data center area intersections
                { x: 300, z: 0 },   // Main DC entrance
                { x: 350, z: 40 }   // DC area intersection
            ];
            
            intersections.forEach(pos => {
                const trafficLight = createTrafficLight();
                trafficLight.position.set(pos.x + 10, 0, pos.z + 10);
                lights.push(trafficLight);
                scene.add(trafficLight);
            });
            
            // EV charging stations
            const chargingStations = [
                { x: -70, z: -70, rotation: 0 },
                { x: 70, z: 70, rotation: Math.PI },
                { x: -70, z: 70, rotation: Math.PI/2 },
                { x: 70, z: -70, rotation: -Math.PI/2 }
            ];
            
            chargingStations.forEach(station => {
                const charger = createEVChargingStation();
                charger.position.set(station.x, 0, station.z);
                charger.rotation.y = station.rotation;
                streetFurniture.push(charger);
                scene.add(charger);
            });
        }

        // Create street light
        function createStreetLight() {
            const streetLight = new THREE.Group();
            
            // Pole
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.2, 8, 8),
                new THREE.MeshPhongMaterial({ color: 0x404040 })
            );
            pole.position.y = 4;
            pole.castShadow = true;
            streetLight.add(pole);
            
            // Arm
            const arm = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.2, 0.2),
                new THREE.MeshPhongMaterial({ color: 0x404040 })
            );
            arm.position.set(1, 7.5, 0);
            streetLight.add(arm);
            
            // Light fixture
            const fixture = new THREE.Mesh(
                new THREE.ConeGeometry(0.5, 1, 8),
                new THREE.MeshPhongMaterial({ color: 0x606060 })
            );
            fixture.position.set(2, 7.5, 0);
            fixture.rotation.z = -Math.PI / 6;
            streetLight.add(fixture);
            
            // Light bulb (emissive)
            const bulb = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 8, 8),
                new THREE.MeshBasicMaterial({ 
                    color: 0xffffcc,
                    emissive: 0xffffcc,
                    emissiveIntensity: 0.5
                })
            );
            bulb.position.set(2, 7.3, 0);
            streetLight.add(bulb);
            
            // Add actual light source
            const pointLight = new THREE.PointLight(0xffffcc, 0.5, 20);
            pointLight.position.set(2, 7.3, 0);
            streetLight.add(pointLight);
            
            return streetLight;
        }

        // Create light pole for parking lots
        function createLightPole() {
            const pole = new THREE.Group();
            
            // Main pole
            const poleGeometry = new THREE.CylinderGeometry(0.2, 0.3, 10, 8);
            const poleMaterial = new THREE.MeshPhongMaterial({ color: 0x404040 });
            const poleMesh = new THREE.Mesh(poleGeometry, poleMaterial);
            poleMesh.position.y = 5;
            pole.add(poleMesh);
            
            // Light fixtures (4 directions)
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2;
                
                // Arm
                const arm = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 0.2, 0.2),
                    poleMaterial
                );
                arm.position.set(
                    Math.cos(angle) * 0.75,
                    9.5,
                    Math.sin(angle) * 0.75
                );
                arm.rotation.y = angle;
                pole.add(arm);
                
                // Light
                const light = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.4, 0.4),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffffcc,
                        emissive: 0xffffcc
                    })
                );
                light.position.set(
                    Math.cos(angle) * 1.5,
                    9.5,
                    Math.sin(angle) * 1.5
                );
                pole.add(light);
            }
            
            return pole;
        }

        // Create traffic light
        function createTrafficLight() {
            const trafficLight = new THREE.Group();
            
            // Pole
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 6, 8),
                new THREE.MeshPhongMaterial({ color: 0x404040 })
            );
            pole.position.y = 3;
            trafficLight.add(pole);
            
            // Light box
            const box = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 2.4, 0.8),
                new THREE.MeshPhongMaterial({ color: 0x2c2c2c })
            );
            box.position.y = 6.5;
            trafficLight.add(box);
            
            // Lights
            const lightColors = [0xff0000, 0xffff00, 0x00ff00];
            const lightPositions = [7.3, 6.5, 5.7];
            
            lightColors.forEach((color, index) => {
                const light = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    new THREE.MeshBasicMaterial({ 
                        color: color,
                        emissive: index === 2 ? color : 0x000000,
                        emissiveIntensity: 0.5
                    })
                );
                light.position.set(0.4, lightPositions[index], 0);
                trafficLight.add(light);
            });
            
            return trafficLight;
        }

        // Create EV charging station
        function createEVChargingStation() {
            const station = new THREE.Group();
            
            // Main unit
            const unit = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 3, 0.8),
                new THREE.MeshPhongMaterial({ color: 0x32cd32 })
            );
            unit.position.y = 1.5;
            station.add(unit);
            
            // Screen
            const screen = new THREE.Mesh(
                new THREE.BoxGeometry(1, 0.8, 0.1),
                new THREE.MeshPhongMaterial({ 
                    color: 0x000000,
                    emissive: 0x0066ff,
                    emissiveIntensity: 0.3
                })
            );
            screen.position.set(0, 2, 0.41);
            station.add(screen);
            
            // Charging cable
            const cable = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 2, 8),
                new THREE.MeshPhongMaterial({ color: 0x000000 })
            );
            cable.position.set(0.6, 1, 0.4);
            cable.rotation.z = 0.3;
            station.add(cable);
            
            // Connector
            const connector = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.2, 0.2),
                new THREE.MeshPhongMaterial({ color: 0x404040 })
            );
            connector.position.set(0.8, 0.2, 0.4);
            station.add(connector);
            
            // Status light
            const statusLight = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 8, 8),
                new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.5
                })
            );
            statusLight.position.set(0, 2.8, 0.4);
            station.add(statusLight);
            
            // Base
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.2, 1.2),
                new THREE.MeshPhongMaterial({ color: 0x606060 })
            );
            base.position.y = 0.1;
            station.add(base);
            
            return station;
        }

        // Create parking meter
        function createParkingMeter() {
            const meter = new THREE.Group();
            
            // Post
            const post = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8),
                new THREE.MeshPhongMaterial({ color: 0x606060 })
            );
            post.position.y = 0.75;
            meter.add(post);
            
            // Meter head
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.5, 0.3),
                new THREE.MeshPhongMaterial({ color: 0x404040 })
            );
            head.position.y = 1.5;
            meter.add(head);
            
            // Display
            const display = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.2, 0.05),
                new THREE.MeshPhongMaterial({ color: 0x000000 })
            );
            display.position.set(0, 1.5, 0.16);
            meter.add(display);
            
            // Coin slot
            const slot = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.02, 0.05),
                new THREE.MeshPhongMaterial({ color: 0x2c2c2c })
            );
            slot.position.set(0, 1.3, 0.16);
            meter.add(slot);
            
            return meter;
        }

        // Create water features
        function createWaterFeatures() {
            // Small ponds in parks
            parks.forEach((park, index) => {
                if (index > 0 && index < 4) { // Add to 3 small parks
                    const pond = createPond();
                    pond.position.copy(park.position);
                    pond.position.x += 15;
                    pond.position.z += 10;
                    waterFeatures.push(pond);
                    scene.add(pond);
                }
            });
            
            // Decorative fountains
            const fountainLocations = [
                { x: -130, z: -130 },
                { x: 130, z: 130 },
                { x: -130, z: 130 },
                { x: 130, z: -130 }
            ];
            
            fountainLocations.forEach(loc => {
                const fountain = createDecorativeFountain();
                fountain.position.set(loc.x, 0, loc.z);
                waterFeatures.push(fountain);
                scene.add(fountain);
            });
        }

        // Create pond
        function createPond() {
            const pond = new THREE.Group();
            
            // Water surface
            const waterGeometry = new THREE.CircleGeometry(8, 32);
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = 0.1;
            pond.add(water);
            
            // Pond edge
            const edgeGeometry = new THREE.TorusGeometry(8, 0.5, 8, 32);
            const edgeMaterial = new THREE.MeshPhongMaterial({ color: 0x8b7355 });
            const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
            edge.rotation.x = -Math.PI / 2;
            edge.position.y = 0.3;
            pond.add(edge);
            
            // Decorative rocks
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(0.5 + Math.random() * 0.5),
                    new THREE.MeshPhongMaterial({ color: 0x696969 })
                );
                rock.position.set(
                    Math.cos(angle) * 7.5,
                    0.3,
                    Math.sin(angle) * 7.5
                );
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                pond.add(rock);
            }
            
            // Lily pads
            const lilyPadMaterial = new THREE.MeshPhongMaterial({ color: 0x228b22 });
            for (let i = 0; i < 5; i++) {
                const lilyPad = new THREE.Mesh(
                    new THREE.CircleGeometry(0.8, 16),
                    lilyPadMaterial
                );
                lilyPad.rotation.x = -Math.PI / 2;
                lilyPad.position.set(
                    (Math.random() - 0.5) * 12,
                    0.15,
                    (Math.random() - 0.5) * 12
                );
                pond.add(lilyPad);
            }
            
            return pond;
        }

        // Create decorative fountain
        function createDecorativeFountain() {
            const fountain = new THREE.Group();
            
            // Base pool
            const poolGeometry = new THREE.CylinderGeometry(5, 6, 1, 32);
            const poolMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
            const pool = new THREE.Mesh(poolGeometry, poolMaterial);
            pool.position.y = 0.5;
            fountain.add(pool);
            
            // Water in pool
            const poolWater = new THREE.Mesh(
                new THREE.CylinderGeometry(4.8, 5.8, 0.8, 32),
                new THREE.MeshPhongMaterial({
                    color: 0x006994,
                    transparent: true,
                    opacity: 0.8,
                    shininess: 100
                })
            );
            poolWater.position.y = 0.6;
            fountain.add(poolWater);
            
            // Central column
            const column = new THREE.Mesh(
                new THREE.CylinderGeometry(0.8, 1, 3, 16),
                new THREE.MeshPhongMaterial({ color: 0xa0a0a0 })
            );
            column.position.y = 2;
            fountain.add(column);
            
            // Top tier
            const topTier = new THREE.Mesh(
                new THREE.CylinderGeometry(2, 2.5, 0.5, 16),
                poolMaterial
            );
            topTier.position.y = 3.5;
            fountain.add(topTier);
            
            // Water jets
            const jetMaterial = new THREE.MeshPhongMaterial({
                color: 0x4682b4,
                transparent: true,
                opacity: 0.6
            });
            
            // Central jet
            const centralJet = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.3, 2, 8),
                jetMaterial
            );
            centralJet.position.y = 4.5;
            fountain.add(centralJet);
            
            // Side jets
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const sideJet = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.15, 1.5, 8),
                    jetMaterial
                );
                sideJet.position.set(
                    Math.cos(angle) * 1.5,
                    3.8,
                    Math.sin(angle) * 1.5
                );
                sideJet.rotation.z = -0.3;
                sideJet.rotation.y = angle;
                fountain.add(sideJet);
            }
            
            return fountain;
        }

        // Create winding river between smart city and data center
        function createRiver() {
            const riverGroup = new THREE.Group();
            
            // Define river path with natural curves
            const riverPoints = [
                new THREE.Vector3(180, 0, -250),  // Start north
                new THREE.Vector3(160, 0, -150),  // Bend west
                new THREE.Vector3(200, 0, -80),   // Curve east
                new THREE.Vector3(170, 0, -20),   // Bend west
                new THREE.Vector3(220, 0, 40),    // Wide curve east
                new THREE.Vector3(190, 0, 100),   // Bend west
                new THREE.Vector3(240, 0, 160),   // Curve east
                new THREE.Vector3(210, 0, 220),   // End south
                new THREE.Vector3(200, 0, 280)    // Final point
            ];
            
            // Create smooth curve
            const curve = new THREE.CatmullRomCurve3(riverPoints);
            curve.tension = 0.3; // Controls curve smoothness
            
            // Generate many points along the curve for smooth river
            const riverPathPoints = curve.getPoints(200);
            
            // Create river segments
            for (let i = 0; i < riverPathPoints.length - 1; i++) {
                const currentPoint = riverPathPoints[i];
                const nextPoint = riverPathPoints[i + 1];
                
                // Calculate direction and width variation
                const direction = new THREE.Vector3().subVectors(nextPoint, currentPoint);
                const length = direction.length();
                const width = 12 + Math.sin(i * 0.1) * 3; // Varying width 9-15
                
                // Create river segment
                const segmentGeometry = new THREE.BoxGeometry(width, 0.2, length);
                const segmentMaterial = new THREE.MeshPhongMaterial({
                    color: 0x1e6091,
                    transparent: true,
                    opacity: 0.8,
                    shininess: 100
                });
                
                const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                
                // Position and orient segment
                const midPoint = new THREE.Vector3().addVectors(currentPoint, nextPoint).multiplyScalar(0.5);
                segment.position.copy(midPoint);
                segment.position.y = -0.1; // Slightly below ground
                
                // Rotate to follow path
                segment.lookAt(nextPoint);
                segment.rotateX(Math.PI / 2);
                
                riverGroup.add(segment);
            }
            
            // Create river banks
            for (let i = 0; i < riverPathPoints.length - 1; i++) {
                const point = riverPathPoints[i];
                const nextPoint = riverPathPoints[i + 1];
                const direction = new THREE.Vector3().subVectors(nextPoint, point).normalize();
                const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x);
                
                const bankWidth = 2;
                const riverWidth = 12 + Math.sin(i * 0.1) * 3;
                
                // Left bank
                const leftBankPos = new THREE.Vector3().copy(point).add(perpendicular.clone().multiplyScalar(riverWidth/2 + bankWidth/2));
                const leftBank = new THREE.Mesh(
                    new THREE.BoxGeometry(bankWidth, 1, 2),
                    new THREE.MeshPhongMaterial({ color: 0x8b7355 })
                );
                leftBank.position.copy(leftBankPos);
                leftBank.position.y = 0.3;
                riverGroup.add(leftBank);
                
                // Right bank
                const rightBankPos = new THREE.Vector3().copy(point).add(perpendicular.clone().multiplyScalar(-(riverWidth/2 + bankWidth/2)));
                const rightBank = new THREE.Mesh(
                    new THREE.BoxGeometry(bankWidth, 1, 2),
                    new THREE.MeshPhongMaterial({ color: 0x8b7355 })
                );
                rightBank.position.copy(rightBankPos);
                rightBank.position.y = 0.3;
                riverGroup.add(rightBank);
                
                // Add riverside vegetation every few segments
                if (i % 15 === 0) {
                    // Left side trees
                    const leftTree = createTree();
                    leftTree.position.copy(leftBankPos);
                    leftTree.position.x += 3 + Math.random() * 2;
                    leftTree.position.y = 0;
                    leftTree.scale.setScalar(0.8 + Math.random() * 0.4);
                    trees.push(leftTree);
                    scene.add(leftTree);
                    
                    // Right side trees
                    const rightTree = createTree();
                    rightTree.position.copy(rightBankPos);
                    rightTree.position.x -= 3 + Math.random() * 2;
                    rightTree.position.y = 0;
                    rightTree.scale.setScalar(0.8 + Math.random() * 0.4);
                    trees.push(rightTree);
                    scene.add(rightTree);
                }
            }
            
            // Create bridges at key crossing points
            const bridgePositions = [
                { point: riverPathPoints[50], name: "North Bridge" },    // Near smart city
                { point: riverPathPoints[100], name: "Central Bridge" }, // Middle
                { point: riverPathPoints[150], name: "DC Bridge" }       // Near data center
            ];
            
            bridgePositions.forEach(bridge => {
                const bridgeStructure = createBridge();
                bridgeStructure.position.copy(bridge.point);
                bridgeStructure.position.y = 1;
                riverGroup.add(bridgeStructure);
            });
            
            scene.add(riverGroup);
            console.log('River created between smart city and data center');
        }
        
        // Create bridge structure
        function createBridge() {
            const bridge = new THREE.Group();
            
            // Bridge deck
            const deck = new THREE.Mesh(
                new THREE.BoxGeometry(30, 1, 20),
                new THREE.MeshPhongMaterial({ color: 0x606060 })
            );
            deck.position.y = 0;
            bridge.add(deck);
            
            // Bridge railings
            const leftRailing = new THREE.Mesh(
                new THREE.BoxGeometry(30, 1.5, 0.5),
                new THREE.MeshPhongMaterial({ color: 0x404040 })
            );
            leftRailing.position.set(0, 0.75, 9.75);
            bridge.add(leftRailing);
            
            const rightRailing = new THREE.Mesh(
                new THREE.BoxGeometry(30, 1.5, 0.5),
                new THREE.MeshPhongMaterial({ color: 0x404040 })
            );
            rightRailing.position.set(0, 0.75, -9.75);
            bridge.add(rightRailing);
            
            // Bridge supports
            for (let i = -1; i <= 1; i++) {
                const support = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.8, 6, 8),
                    new THREE.MeshPhongMaterial({ color: 0x505050 })
                );
                support.position.set(i * 12, -3, 0);
                bridge.add(support);
            }
            
            return bridge;
        }

        // Keyboard handler for camera and phase shortcuts
        function onKeyDown(event) {
            switch(event.key) {
                case '1':
                    setCameraView('aerial');
                    break;
                case '2':
                    setCameraView('street');
                    break;
                case '3':
                    setCameraView('birdseye');
                    break;
                case '4':
                    setCameraView('overview');
                    break;
                case '5':
                    setCameraView('cinematic');
                    break;
                case '6':
                    togglePhase('phase1');
                    break;
                case '7':
                    togglePhase('phase2');
                    break;
                case '8':
                    togglePhase('phase3');
                    break;
            }
        }

        // Window resize handler
        function onWindowResize() {
            if (!renderer || !camera) return;
            
            try {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                // Force render update
                if (scene && camera) {
                    renderer.render(scene, camera);
                }
            } catch (error) {
                console.error('Resize error:', error);
            }
        }

        // Mouse click handler
        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(buildings.map(b => b.children[0]));

            if (intersects.length > 0) {
                const building = intersects[0].object.parent;
                if (building.userData.type) {
                    showBuildingInfo(building);
                }
            } else {
                hideBuildingInfo();
            }
        }

        // Mouse move handler
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        // Show building information popup
        function showBuildingInfo(building) {
            const info = building.userData;
            const popup = document.getElementById('buildingInfoPopup');
            
            // Update popup content
            document.getElementById('buildingIcon').textContent = info.icon || '🏢';
            document.getElementById('buildingTitle').textContent = info.name || 'Building Information';
            document.getElementById('buildingType').textContent = info.type || '-';
            document.getElementById('buildingHeight').textContent = info.height ? `${info.height}m` : '-';
            document.getElementById('buildingFloors').textContent = info.floors || '-';
            
            // Update features list
            const featuresList = document.getElementById('buildingFeatures');
            featuresList.innerHTML = '';
            if (info.features && info.features.length > 0) {
                info.features.forEach(feature => {
                    const li = document.createElement('li');
                    li.textContent = feature;
                    featuresList.appendChild(li);
                });
            } else {
                const li = document.createElement('li');
                li.textContent = 'Standard features';
                featuresList.appendChild(li);
            }
            
            // Update phase status
            const phaseElement = document.getElementById('buildingPhase');
            if (info.phase) {
                phaseElement.className = `info-value phase-status ${info.phase}`;
                switch(info.phase) {
                    case 'phase1':
                        phaseElement.textContent = 'HEART CORE - Hoàn thành';
                        break;
                    case 'phase2':
                        phaseElement.textContent = 'TECHNOLOGY HUB - Đang xây dựng';
                        break;
                    case 'phase3':
                        phaseElement.textContent = 'INNOVATION DISTRICT - Dự kiến';
                        break;
                    default:
                        phaseElement.textContent = 'Unknown Phase';
                }
            } else {
                phaseElement.className = 'info-value phase-status';
                phaseElement.textContent = '-';
            }
            
            // Show popup with animation
            popup.classList.add('show');
            
            // Highlight building
            if (selectedObject) {
                // Remove previous highlight
                selectedObject.traverse(child => {
                    if (child.isMesh && child.userData.originalMaterial) {
                        child.material = child.userData.originalMaterial;
                    }
                });
            }
            
            selectedObject = building;
            building.traverse(child => {
                if (child.isMesh) {
                    child.userData.originalMaterial = child.material;
                    const highlightMaterial = child.material.clone();
                    highlightMaterial.emissive = new THREE.Color(0x444444);
                    highlightMaterial.emissiveIntensity = 0.3;
                    child.material = highlightMaterial;
                }
            });
        }

        // Hide building information popup
        function hideBuildingInfo() {
            const popup = document.getElementById('buildingInfoPopup');
            popup.classList.remove('show');
            
            // Remove building highlight
            if (selectedObject) {
                selectedObject.traverse(child => {
                    if (child.isMesh && child.userData.originalMaterial) {
                        child.material = child.userData.originalMaterial;
                    }
                });
                selectedObject = null;
            }
        }

        // Toggle wireframe mode
        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            
            scene.traverse(child => {
                if (child.isMesh) {
                    child.material.wireframe = wireframeMode;
                }
            });
        }

        // Toggle landscape mode
        function toggleLandscapeMode() {
            landscapeMode = !landscapeMode;
            
            // Highlight trees and parks
            trees.forEach(tree => {
                tree.traverse(child => {
                    if (child.isMesh && child.material.color) {
                        if (landscapeMode) {
                            child.material.emissive = new THREE.Color(0x00ff00);
                            child.material.emissiveIntensity = 0.3;
                        } else {
                            child.material.emissive = new THREE.Color(0x000000);
                            child.material.emissiveIntensity = 0;
                        }
                    }
                });
            });
            
            parks.forEach(park => {
                park.traverse(child => {
                    if (child.isMesh && child.material.color) {
                        const isGreen = child.material.color.getHex() === 0x228b22 || 
                                       child.material.color.getHex() === 0x2d5016;
                        if (isGreen) {
                            if (landscapeMode) {
                                child.material.emissive = new THREE.Color(0x00ff00);
                                child.material.emissiveIntensity = 0.2;
                            } else {
                                child.material.emissive = new THREE.Color(0x000000);
                                child.material.emissiveIntensity = 0;
                            }
                        }
                    }
                });
            });
        }

        // Set time of day
        function setTimeOfDay(time) {
            timeOfDay = time;
            
            // Update button states
            document.querySelectorAll('.time-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update lighting and sky
            switch(time) {
                case 'morning':
                    scene.background.setHex(0x87CEEB);
                    updateLighting(0.6, 0.8, 0xffffff);
                    break;
                case 'noon':
                    scene.background.setHex(0x87CEEB);
                    updateLighting(0.8, 1.0, 0xffffff);
                    break;
                case 'evening':
                    scene.background.setHex(0xff6b35);
                    updateLighting(0.4, 0.6, 0xffa500);
                    break;
                case 'night':
                    scene.background.setHex(0x191970);
                    updateLighting(0.2, 0.3, 0x6495ed);
                    
                    // Turn on street lights
                    lights.forEach(light => {
                        light.traverse(child => {
                            if (child.isLight) {
                                child.intensity = 1.0;
                            }
                        });
                    });
                    break;
            }
        }

        // Update lighting
        function updateLighting(ambientIntensity, directionalIntensity, color) {
            scene.traverse(child => {
                if (child.isLight) {
                    if (child.type === 'AmbientLight') {
                        child.intensity = ambientIntensity;
                        child.color.setHex(color);
                    } else if (child.type === 'DirectionalLight') {
                        child.intensity = directionalIntensity;
                        child.color.setHex(color);
                    }
                }
            });
        }


        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            if (controls) {
                controls.update();
            }
            
            // Animate water features
            waterFeatures.forEach(feature => {
                feature.children.forEach(child => {
                    if (child.material && child.material.color.getHex() === 0x006994) {
                        child.rotation.z += 0.001;
                    }
                });
            });
            
            // ANTI-BLINKING SYSTEM: Ensure no blinking/flashing effects in scene
            // This system continuously monitors and disables any blinking animations
            disableAllBlinkingEffects();
            
            // Render scene
            renderer.render(scene, camera);
        }

        // ============== ANTI-BLINKING SYSTEM ==============
        // Comprehensive system to eliminate all blinking/flashing effects
        function disableAllBlinkingEffects() {
            if (!scene) return;
            
            // Traverse entire scene to find and neutralize blinking effects
            scene.traverse((object) => {
                // Disable any interval-based blinking by checking userData
                if (object.userData && object.userData.blinkInterval) {
                    clearInterval(object.userData.blinkInterval);
                    clearTimeout(object.userData.blinkTimeout);
                    delete object.userData.blinkInterval;
                    delete object.userData.blinkTimeout;
                }
                
                // Ensure consistent material properties (no animated values)
                if (object.material) {
                    // Handle single material
                    stabilizeMaterial(object.material, object);
                } else if (object.materials) {
                    // Handle multiple materials
                    object.materials.forEach(material => stabilizeMaterial(material, object));
                }
                
                // Ensure object visibility is stable (not animated)
                if (object.userData && object.userData.originallyVisible !== undefined) {
                    object.visible = object.userData.originallyVisible;
                } else if (object.visible === false && !object.userData.intentionallyHidden) {
                    // Restore visibility for objects that might have been hidden by blinking
                    object.visible = true;
                }
            });
        }
        
        // Stabilize material properties to prevent blinking
        function stabilizeMaterial(material, object) {
            if (!material) return;
            
            // Set stable emissive intensity for lights and glowing objects
            if (material.emissive && material.emissive.getHex() !== 0x000000) {
                // Objects with emissive materials get stable, appropriate intensity
                if (material.emissiveIntensity === undefined || material.emissiveIntensity < 0.1) {
                    material.emissiveIntensity = 0.5; // Default stable intensity
                }
                
                // Clamp emissive intensity to reasonable range
                if (material.emissiveIntensity > 2.0) {
                    material.emissiveIntensity = 1.0; // Prevent over-bright flashing
                }
                
                // Store as stable value to prevent animation
                material.userData = material.userData || {};
                material.userData.stableEmissiveIntensity = material.emissiveIntensity;
            }
            
            // Ensure stable opacity (no transparency animations)
            if (material.transparent && material.opacity !== undefined) {
                if (material.opacity < 0.5) {
                    material.opacity = 0.8; // Restore visibility
                }
                // Store stable opacity
                material.userData = material.userData || {};
                material.userData.stableOpacity = material.opacity;
            }
            
            // Special handling for specific object types
            if (object.userData) {
                // Traffic lights: set stable emissive properties
                if (object.userData.type === 'traffic_light' || object.name.includes('traffic')) {
                    material.emissiveIntensity = 0.6;
                }
                
                // Street lights: consistent warm light
                if (object.userData.type === 'street_light' || object.name.includes('street')) {
                    material.emissive.setHex(0xffffcc);
                    material.emissiveIntensity = 0.5;
                }
                
                // LED displays: stable cyan glow  
                if (object.userData.type === 'led_display' || object.name.includes('led')) {
                    material.emissive.setHex(0x00ffff);
                    material.emissiveIntensity = 0.4;
                }
                
                // Building windows: gentle warm light
                if (object.userData.type === 'window' || object.name.includes('window')) {
                    if (material.emissive.getHex() !== 0x000000) {
                        material.emissiveIntensity = 0.2;
                    }
                }
            }
        }
        
        // Initialize anti-blinking system on scene load
        function initAntiBlinkingSystem() {
            console.log('🚫 Anti-Blinking System: Initializing...');
            
            // Clear any existing global intervals that might cause blinking
            // (This catches intervals created by external systems)
            if (window.blinkIntervals) {
                window.blinkIntervals.forEach(interval => clearInterval(interval));
                window.blinkIntervals = [];
            }
            
            // Override global functions that might be used for blinking
            const originalSetInterval = window.setInterval;
            window.setInterval = function(callback, delay, ...args) {
                // Allow necessary intervals but block rapid blinking intervals
                if (delay < 100) {
                    console.warn('🚫 Blocked rapid interval (potential blinking):', delay + 'ms');
                    return null;
                }
                return originalSetInterval.call(window, callback, delay, ...args);
            };
            
            // Disable any external blinking systems
            if (window.ledSystem && window.ledSystem.disable) {
                window.ledSystem.disable();
            }
            if (window.holographicSystem && window.holographicSystem.disable) {
                window.holographicSystem.disable();
            }
            if (window.quantumSystem && window.quantumSystem.disable) {
                window.quantumSystem.disable();
            }
            if (window.aiIntelligenceSystem && window.aiIntelligenceSystem.disable) {
                window.aiIntelligenceSystem.disable();
            }
            
            // Run initial cleanup
            disableAllBlinkingEffects();
            
            console.log('✅ Anti-Blinking System: All blinking effects disabled');
        }

        // ============== DATA CENTER CLUSTER FUNCTIONS ==============
        
        // Create Data Center Cluster (inspired by HUE HI TECH PARK)
        function createDataCenterCluster() {
            const dataCenterGroup = new THREE.Group();
            
            // Data Center positions - ON SOLID GROUND PLATFORM: Within boundaries (X:-300 to 500, Z:-300 to 300), avoiding river zone (x=160-240)
            const dataCenters = [
                { name: 'DATA CENTER 01', x: 350, z: -120, width: 60, height: 25, depth: 40, power: '100 MW', area: '22 HA' },
                { name: 'DATA CENTER 02', x: 350, z: 0, width: 55, height: 22, depth: 35, power: '100 MW', area: '20 HA' },
                { name: 'DATA CENTER 03', x: 350, z: 120, width: 45, height: 20, depth: 30, power: '100 MW', area: '17 HA' }
            ];
            
            // Create Data Center Ground/Foundation
            createDataCenterGround();
            
            // Create Data Center buildings
            dataCenters.forEach(dc => {
                const building = createDataCenterBuilding(dc);
                building.position.set(dc.x, 0, dc.z);
                console.log(`🏢 ${dc.name} created at: x=${dc.x}, z=${dc.z}, width=${dc.width}, depth=${dc.depth}`);
                dataCenterGroup.add(building);
                scene.add(building);
                
                // Add cooling water system around each data center - positioned much lower and farther
                const waterSystem = createWaterCoolingSystem(dc.width, dc.depth);
                waterSystem.position.set(dc.x, -0.5, dc.z); // Much lower to avoid visual overlap
                console.log(`💧 Water system for ${dc.name} positioned at: x=${dc.x}, y=-0.5, z=${dc.z}`);
                dataCenterGroup.add(waterSystem);
                scene.add(waterSystem);
            });
            
            // Create 500KV Substation - positioned on main platform
            const substation = create500KVSubstation();
            substation.position.set(400, 0, -120);
            dataCenterGroup.add(substation);
            scene.add(substation);
            
            // Create National Expressway - positioned on main platform  
            const expressway = createExpressway();
            expressway.position.set(350, 0.1, -150);
            dataCenterGroup.add(expressway);
            scene.add(expressway);
            
            // Add 500KV transmission lines
            create500KVTransmissionLines();
            
            // Add landscaping around data centers
            createDataCenterLandscaping();
            
            console.log('🏢 Data Center Cluster created successfully');
        }
        
        // Create Data Center Ground/Foundation
        function createDataCenterGround() {
            // Remove separate ground - data center now integrated with main smart city ground
            // Only create foundation pads and connecting infrastructure
            
            // Concrete foundation pads for each data center - ON MAIN GROUND PLATFORM
            const foundations = [
                { x: 350, z: -120, width: 70, depth: 50 },   // DC01 foundation
                { x: 350, z: 0, width: 65, depth: 45 },   // DC02 foundation
                { x: 350, z: 120, width: 55, depth: 40 }    // DC03 foundation
            ];
            
            foundations.forEach(foundation => {
                const foundationPad = new THREE.Mesh(
                    new THREE.BoxGeometry(foundation.width, 1, foundation.depth),
                    new THREE.MeshPhongMaterial({ color: 0xC0C0C0 })
                );
                foundationPad.position.set(foundation.x, 0.5, foundation.z);
                scene.add(foundationPad);
                
                // Foundation border
                const border = new THREE.Mesh(
                    new THREE.RingGeometry(
                        Math.max(foundation.width, foundation.depth) / 2,
                        Math.max(foundation.width, foundation.depth) / 2 + 2,
                        32
                    ),
                    new THREE.MeshPhongMaterial({ color: 0x404040 })
                );
                border.rotation.x = -Math.PI / 2;
                border.position.set(foundation.x, 1.1, foundation.z);
                scene.add(border);
            });
            
            // Access roads within data center compound AND connecting to smart city
            const roads = [
                // Main highway connecting smart city center to data center
                { x: 200, z: 0, width: 300, depth: 12 }, // Main highway from center to DC
                { x: 400, z: -20, width: 150, depth: 8 }, // Data center main access road
                { x: 320, z: 40, width: 8, depth: 80 },   // Connecting road
                { x: 470, z: 50, width: 8, depth: 60 },   // Service road
                // Additional connecting roads
                { x: 100, z: 50, width: 200, depth: 6 },  // Northern connecting route
                { x: 150, z: -50, width: 150, depth: 6 }  // Southern connecting route
            ];
            
            roads.forEach(road => {
                const roadMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(road.width, 0.2, road.depth),
                    new THREE.MeshPhongMaterial({ color: 0x333333 })
                );
                roadMesh.position.set(road.x, 0.1, road.z);
                scene.add(roadMesh);
                
                // Road markings
                const markings = new THREE.Mesh(
                    new THREE.BoxGeometry(road.width * 0.9, 0.3, 0.3),
                    new THREE.MeshBasicMaterial({ color: 0xffffff })
                );
                markings.position.set(road.x, 0.2, road.z);
                scene.add(markings);
            });
            
            // Individual security fences around each data center building (not entire compound)
            foundations.forEach(foundation => {
                const individualFence = createSecurityPerimeter(foundation.width + 20, foundation.depth + 20);
                individualFence.position.set(foundation.x, 0, foundation.z);
                scene.add(individualFence);
            });
            
            console.log('🏗️ Data Center ground and infrastructure created');
        }
        
        // Create individual Data Center building
        function createDataCenterBuilding(config) {
            const building = new THREE.Group();
            
            // Main building structure
            const mainBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(config.width, config.height, config.depth),
                new THREE.MeshPhongMaterial({ 
                    color: 0x404040,
                    specular: 0x111111,
                    shininess: 100
                })
            );
            mainBuilding.position.y = config.height / 2;
            building.add(mainBuilding);
            
            // Roof with cooling units
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(config.width + 2, 2, config.depth + 2),
                new THREE.MeshPhongMaterial({ color: 0x606060 })
            );
            roof.position.y = config.height + 1;
            building.add(roof);
            
            // Cooling units on roof (HVAC systems)
            for (let i = 0; i < 6; i++) {
                const coolingUnit = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 3, 6),
                    new THREE.MeshPhongMaterial({ color: 0x708090 })
                );
                coolingUnit.position.set(
                    (i % 3 - 1) * 15,
                    config.height + 3.5,
                    (Math.floor(i / 3) - 0.5) * 10
                );
                building.add(coolingUnit);
                
                // Cooling fans
                const fan = new THREE.Mesh(
                    new THREE.CylinderGeometry(2, 2, 0.5, 8),
                    new THREE.MeshPhongMaterial({ color: 0x2F4F4F })
                );
                fan.position.copy(coolingUnit.position);
                fan.position.y += 2;
                building.add(fan);
            }
            
            // Server room windows (glowing blue)
            for (let i = 0; i < 8; i++) {
                const window = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 3, 0.2),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x0066ff,
                        emissive: 0x003366,
                        emissiveIntensity: 0.5
                    })
                );
                window.position.set(
                    (i % 4 - 1.5) * 12,
                    5 + Math.floor(i / 4) * 8,
                    config.depth / 2 + 0.1
                );
                building.add(window);
            }
            
            // Security perimeter
            const perimeter = createSecurityPerimeter(config.width + 10, config.depth + 10);
            perimeter.position.y = 0;
            building.add(perimeter);
            
            // Info label
            const label = createDataCenterLabel(config);
            label.position.set(0, config.height + 10, config.depth / 2 + 5);
            building.add(label);
            
            return building;
        }
        
        // Create 500KV Substation
        function create500KVSubstation() {
            const substation = new THREE.Group();
            
            // Main transformer building
            const transformerBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(25, 15, 20),
                new THREE.MeshPhongMaterial({ color: 0x708090 })
            );
            transformerBuilding.position.y = 7.5;
            substation.add(transformerBuilding);
            
            // Power transformers (large cylinders)
            for (let i = 0; i < 3; i++) {
                const transformer = new THREE.Mesh(
                    new THREE.CylinderGeometry(4, 4, 12, 16),
                    new THREE.MeshPhongMaterial({ color: 0x4682B4 })
                );
                transformer.position.set((i - 1) * 15, 6, -15);
                substation.add(transformer);
                
                // Cooling fins
                for (let j = 0; j < 8; j++) {
                    const fin = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 10, 2),
                        new THREE.MeshPhongMaterial({ color: 0x2F4F4F })
                    );
                    const angle = (j / 8) * Math.PI * 2;
                    fin.position.set(
                        (i - 1) * 15 + Math.cos(angle) * 4.5,
                        6,
                        -15 + Math.sin(angle) * 4.5
                    );
                    fin.rotation.y = angle;
                    substation.add(fin);
                }
            }
            
            // High voltage towers
            for (let i = 0; i < 2; i++) {
                const tower = createTransmissionTower();
                tower.position.set((i - 0.5) * 40, 0, 25);
                substation.add(tower);
            }
            
            // Control house
            const controlHouse = new THREE.Mesh(
                new THREE.BoxGeometry(12, 8, 10),
                new THREE.MeshPhongMaterial({ color: 0x8FBC8F })
            );
            controlHouse.position.set(20, 4, 0);
            substation.add(controlHouse);
            
            // Security fence
            const fence = createSecurityPerimeter(60, 50);
            fence.position.y = 0;
            substation.add(fence);
            
            return substation;
        }
        
        // Create Water Cooling System
        function createWaterCoolingSystem(width, depth) {
            const waterSystem = new THREE.Group();
            
            // Cooling ponds/lakes around the data center - positioned much further away
            const pondPositions = [
                { x: width/2 + 60, z: 0, scale: 0.8 },      // Far east pond
                { x: -width/2 - 60, z: 0, scale: 0.7 },     // Far west pond  
                { x: 0, z: depth/2 + 55, scale: 0.6 },      // Far north pond
                { x: 0, z: -depth/2 - 55, scale: 0.7 }      // Far south pond
            ];
            
            pondPositions.forEach(pos => {
                const pond = createCoolingPond();
                pond.position.set(pos.x, 0, pos.z);
                pond.scale.setScalar(pos.scale);
                waterSystem.add(pond);
                console.log(`🌊 Pond created at: x=${pos.x}, z=${pos.z}, scale=${pos.scale}`);
            });
            
            // Water channels connecting ponds
            const channels = createWaterChannels(width, depth);
            waterSystem.add(channels);
            
            // Cooling towers - positioned much further away to avoid overlap with buildings
            for (let i = 0; i < 4; i++) {
                const coolingTower = createCoolingTower();
                const angle = (i / 4) * Math.PI * 2;
                const radius = Math.max(width, depth) / 2 + 80; // Much larger distance
                coolingTower.position.set(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
                console.log(`⚪ Cooling tower ${i} at: x=${Math.cos(angle) * radius}, z=${Math.sin(angle) * radius}, radius=${radius}`);
                waterSystem.add(coolingTower);
            }
            
            return waterSystem;
        }
        
        // Create Cooling Pond
        function createCoolingPond() {
            const pond = new THREE.Group();
            
            // Water surface with ripples
            const waterGeometry = new THREE.CircleGeometry(12, 32);
            const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.7,
                shininess: 100,
                reflectivity: 0.5
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -0.5; // Much lower water level to stay below data center foundation
            pond.add(water);
            
            // Pond bank
            const bankGeometry = new THREE.RingGeometry(12, 14, 32);
            const bankMaterial = new THREE.MeshPhongMaterial({ color: 0x8b7355 });
            const bank = new THREE.Mesh(bankGeometry, bankMaterial);
            bank.rotation.x = -Math.PI / 2;
            bank.position.y = -0.6; // Adjust bank to match much lower water level
            pond.add(bank);
            
            return pond;
        }
        
        // Create Water Channels
        function createWaterChannels(width, depth) {
            const channels = new THREE.Group();
            
            // Create channels connecting to much farther outer ponds - completely outside data center area
            // Horizontal channels (east-west connection) - much farther out
            const hChannel1 = new THREE.Mesh(
                new THREE.BoxGeometry(40, 0.5, 3),
                new THREE.MeshPhongMaterial({ 
                    color: 0x006994,
                    transparent: true,
                    opacity: 0.7
                })
            );
            hChannel1.position.set(width/2 + 40, 0.25, 0);
            channels.add(hChannel1);
            
            const hChannel2 = new THREE.Mesh(
                new THREE.BoxGeometry(40, 0.5, 3),
                new THREE.MeshPhongMaterial({ 
                    color: 0x006994,
                    transparent: true,
                    opacity: 0.7
                })
            );
            hChannel2.position.set(-width/2 - 40, 0.25, 0);
            channels.add(hChannel2);
            
            // Vertical channels (north-south connection) - much farther out
            const vChannel1 = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.5, 35),
                new THREE.MeshPhongMaterial({ 
                    color: 0x006994,
                    transparent: true,
                    opacity: 0.7
                })
            );
            vChannel1.position.set(0, 0.25, depth/2 + 37);
            channels.add(vChannel1);
            
            const vChannel2 = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.5, 35),
                new THREE.MeshPhongMaterial({ 
                    color: 0x006994,
                    transparent: true,
                    opacity: 0.7
                })
            );
            vChannel2.position.set(0, 0.25, -depth/2 - 37);
            channels.add(vChannel2);
            
            return channels;
        }
        
        // Create Cooling Tower
        function createCoolingTower() {
            const tower = new THREE.Group();
            
            // Main tower (hyperboloid shape approximated by cylinder) - made shorter
            const mainTower = new THREE.Mesh(
                new THREE.CylinderGeometry(6, 8, 20, 16), // Reduced height from 30 to 20
                new THREE.MeshPhongMaterial({ color: 0xC0C0C0 })
            );
            mainTower.position.y = 10; // Reduced from 15 to 10
            tower.add(mainTower);
            
            // Steam/vapor effect
            const steam = new THREE.Mesh(
                new THREE.CylinderGeometry(3, 6, 5, 16),
                new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3
                })
            );
            steam.position.y = 22.5; // Adjusted accordingly
            tower.add(steam);
            
            return tower;
        }
        
        // Create National Expressway
        function createExpressway() {
            const expressway = new THREE.Group();
            
            // Main road
            const road = new THREE.Mesh(
                new THREE.BoxGeometry(200, 0.2, 20),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            expressway.add(road);
            
            // Road markings
            for (let i = -8; i <= 8; i++) {
                const marking = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 0.3, 0.3),
                    new THREE.MeshBasicMaterial({ color: 0xffffff })
                );
                marking.position.set(i * 12, 0.1, 0);
                expressway.add(marking);
            }
            
            // Side barriers
            for (let side = -1; side <= 1; side += 2) {
                const barrier = new THREE.Mesh(
                    new THREE.BoxGeometry(200, 1, 0.5),
                    new THREE.MeshPhongMaterial({ color: 0x606060 })
                );
                barrier.position.set(0, 0.5, side * 10.5);
                expressway.add(barrier);
            }
            
            // Road signs
            const signPos = [-60, 60];
            signPos.forEach(x => {
                const signPost = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 8, 8),
                    new THREE.MeshPhongMaterial({ color: 0x404040 })
                );
                signPost.position.set(x, 4, 15);
                expressway.add(signPost);
                
                const sign = new THREE.Mesh(
                    new THREE.BoxGeometry(12, 4, 0.5),
                    new THREE.MeshPhongMaterial({ color: 0x0066cc })
                );
                sign.position.set(x, 6, 15);
                expressway.add(sign);
            });
            
            return expressway;
        }
        
        // Create Transmission Tower
        function createTransmissionTower() {
            const tower = new THREE.Group();
            
            // Main tower structure (simplified lattice)
            const mainStructure = new THREE.Mesh(
                new THREE.CylinderGeometry(1, 3, 40, 4),
                new THREE.MeshPhongMaterial({ color: 0x708090 })
            );
            mainStructure.position.y = 20;
            tower.add(mainStructure);
            
            // Cross arms for power lines
            for (let i = 0; i < 3; i++) {
                const crossArm = new THREE.Mesh(
                    new THREE.BoxGeometry(25, 1, 1),
                    new THREE.MeshPhongMaterial({ color: 0x708090 })
                );
                crossArm.position.y = 35 - i * 5;
                tower.add(crossArm);
                
                // Insulators and power lines
                for (let j = -1; j <= 1; j++) {
                    const insulator = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.5, 2, 8),
                        new THREE.MeshPhongMaterial({ color: 0x8B4513 })
                    );
                    insulator.position.set(j * 8, 35 - i * 5 - 1.5, 0);
                    tower.add(insulator);
                }
            }
            
            return tower;
        }
        
        // Create 500KV Transmission Lines
        function create500KVTransmissionLines() {
            const lineGroup = new THREE.Group();
            
            // Transmission lines connecting substation to data centers - on main platform
            const linePoints = [
                new THREE.Vector3(400, 35, -120),  // From substation
                new THREE.Vector3(350, 35, -50),   // Route to DC area
                new THREE.Vector3(350, 35, -120),   // To DC01
                new THREE.Vector3(350, 35, 0),   // To DC02
                new THREE.Vector3(350, 35, 120)    // To DC03
            ];
            
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x404040, linewidth: 3 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            
            scene.add(line);
        }
        
        // Create Security Perimeter
        function createSecurityPerimeter(width, depth) {
            const perimeter = new THREE.Group();
            
            // Fence posts
            const postPositions = [];
            const spacing = 8;
            
            // Calculate fence posts around perimeter
            for (let x = -width/2; x <= width/2; x += spacing) {
                postPositions.push({ x: x, z: -depth/2 });
                postPositions.push({ x: x, z: depth/2 });
            }
            for (let z = -depth/2; z <= depth/2; z += spacing) {
                postPositions.push({ x: -width/2, z: z });
                postPositions.push({ x: width/2, z: z });
            }
            
            postPositions.forEach(pos => {
                const post = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 3, 8),
                    new THREE.MeshPhongMaterial({ color: 0x404040 })
                );
                post.position.set(pos.x, 1.5, pos.z);
                perimeter.add(post);
            });
            
            // Fence mesh (simplified)
            const fenceGeometry = new THREE.BoxGeometry(width, 3, 0.1);
            const fenceMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x606060,
                transparent: true,
                opacity: 0.7
            });
            
            // Four fence sides
            const fenceSides = [
                { pos: [0, 1.5, -depth/2], rot: [0, 0, 0] },
                { pos: [0, 1.5, depth/2], rot: [0, 0, 0] },
                { pos: [-width/2, 1.5, 0], rot: [0, Math.PI/2, 0] },
                { pos: [width/2, 1.5, 0], rot: [0, Math.PI/2, 0] }
            ];
            
            fenceSides.forEach(side => {
                const fence = new THREE.Mesh(fenceGeometry, fenceMaterial);
                fence.position.set(...side.pos);
                fence.rotation.set(...side.rot);
                perimeter.add(fence);
            });
            
            return perimeter;
        }
        
        // Create Data Center Label
        function createDataCenterLabel(config) {
            const labelGroup = new THREE.Group();
            
            // Label background
            const labelBg = new THREE.Mesh(
                new THREE.BoxGeometry(20, 5, 0.2),
                new THREE.MeshBasicMaterial({ color: 0x2C5530 })
            );
            labelGroup.add(labelBg);
            
            // Create simple text using geometry (since we can't easily use Canvas)
            // This is a simplified representation - in a real implementation you'd use TextGeometry
            const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            return labelGroup;
        }
        
        // Create Data Center Landscaping
        function createDataCenterLandscaping() {
            // Add trees and green areas connecting smart city to data centers
            const treePositions = [
                // Around data centers
                { x: 480, z: 0 }, { x: 485, z: -5 }, { x: 475, z: 5 },
                { x: 320, z: 80 }, { x: 315, z: 85 }, { x: 325, z: 75 },
                { x: 460, z: 90 }, { x: 465, z: 95 }, { x: 455, z: 85 },
                { x: 380, z: -10 }, { x: 385, z: -15 }, { x: 375, z: -5 },
                // Connecting corridor trees (between city and DC)
                { x: 150, z: 20 }, { x: 160, z: 25 }, { x: 140, z: 15 },
                { x: 200, z: 30 }, { x: 210, z: 35 }, { x: 190, z: 25 },
                { x: 250, z: 40 }, { x: 260, z: 45 }, { x: 240, z: 35 },
                { x: 300, z: 20 }, { x: 310, z: 25 }, { x: 290, z: 15 }
            ];
            
            treePositions.forEach(pos => {
                const tree = createTree();
                tree.position.set(pos.x, 0, pos.z);
                tree.scale.setScalar(1.2);
                trees.push(tree);
                scene.add(tree);
            });
            
            // Add grass areas creating connection between city and data centers - ON MAIN PLATFORM
            const grassPositions = [
                // Around data centers (on solid ground)
                { x: 350, z: -120, size: 30 },  // Around DC01
                { x: 350, z: 0, size: 25 },  // Around DC02
                { x: 350, z: 120, size: 20 },  // Around DC03
                { x: 350, z: 50, size: 35 },   // Additional green area
                // Connecting green corridor
                { x: 180, z: 20, size: 25 },
                { x: 220, z: 40, size: 30 },
                { x: 280, z: 30, size: 20 },
                { x: 120, z: 60, size: 15 }
            ];
            
            grassPositions.forEach(pos => {
                const grass = new THREE.Mesh(
                    new THREE.CircleGeometry(pos.size, 16),
                    new THREE.MeshPhongMaterial({ color: 0x228B22 })
                );
                grass.rotation.x = -Math.PI / 2;
                grass.position.set(pos.x, 0.05, pos.z);
                scene.add(grass);
            });
        }

        // Quick WebGL test function (add to window for console access)
        window.quickWebGLTest = function() {
            console.log('🧪 Quick WebGL Test');
            try {
                const testCanvas = document.createElement('canvas');
                const gl = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
                if (!gl) {
                    return '❌ WebGL NOT supported';
                }
                return `✅ WebGL supported - Version: ${gl.getParameter(gl.VERSION)}`;
            } catch (e) {
                return `❌ WebGL test failed: ${e.message}`;
            }
        };
        
        // Run quick test on page load
        window.addEventListener('DOMContentLoaded', () => {
            console.log(window.quickWebGLTest());
        });

        // Check WebGL support with detailed diagnostics
        // ENHANCED: Comprehensive WebGL validation with detailed diagnostics
        function checkWebGLSupport() {
            console.log('🔍 Starting comprehensive WebGL validation...');
            
            try {
                // Create test canvas
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                
                // Try WebGL 2 first, then WebGL 1
                let gl = canvas.getContext('webgl2', { failIfMajorPerformanceCaveat: false });
                let version = 2;
                
                if (!gl) {
                    gl = canvas.getContext('webgl', { failIfMajorPerformanceCaveat: false }) || 
                         canvas.getContext('experimental-webgl', { failIfMajorPerformanceCaveat: false });
                    version = 1;
                }
                
                if (!gl) {
                    throw new Error('WebGL không được hỗ trợ trên trình duyệt này');
                }
                
                // Test context immediately
                if (gl.isContextLost()) {
                    throw new Error('WebGL context bị mất ngay sau khi tạo');
                }
                
                // Get basic GPU info
                const renderer = gl.getParameter(gl.RENDERER) || 'Unknown GPU';
                const vendor = gl.getParameter(gl.VENDOR) || 'Unknown Vendor';
                const glVersion = gl.getParameter(gl.VERSION) || 'Unknown Version';
                
                console.log(`✅ WebGL ${version} context created successfully`);
                console.log(`   GPU: ${renderer}`);
                console.log(`   Vendor: ${vendor}`);
                console.log(`   Version: ${glVersion}`);
                
                // Check texture capabilities
                const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                const maxRenderbufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                const maxViewportDims = gl.getParameter(gl.MAX_VIEWPORT_DIMS);
                
                console.log(`   Max texture size: ${maxTextureSize}x${maxTextureSize}`);
                console.log(`   Max renderbuffer: ${maxRenderbufferSize}x${maxRenderbufferSize}`);
                console.log(`   Max viewport: ${maxViewportDims[0]}x${maxViewportDims[1]}`);
                
                // Check for critical extensions
                const criticalExtensions = [
                    'OES_texture_float',
                    'OES_standard_derivatives',
                    'WEBGL_depth_texture'
                ];
                
                const optionalExtensions = [
                    'EXT_texture_filter_anisotropic',
                    'WEBGL_compressed_texture_s3tc',
                    'OES_element_index_uint',
                    'OES_vertex_array_object'
                ];
                
                const missingCritical = [];
                const missingOptional = [];
                
                criticalExtensions.forEach(ext => {
                    const extension = gl.getExtension(ext) || 
                                    gl.getExtension('WEBKIT_' + ext) || 
                                    gl.getExtension('MOZ_' + ext);
                    if (!extension) {
                        missingCritical.push(ext);
                    } else {
                        console.log(`   ✅ ${ext} supported`);
                    }
                });
                
                optionalExtensions.forEach(ext => {
                    const extension = gl.getExtension(ext) || 
                                    gl.getExtension('WEBKIT_' + ext) || 
                                    gl.getExtension('MOZ_' + ext);
                    if (!extension) {
                        missingOptional.push(ext);
                    } else {
                        console.log(`   ✅ ${ext} supported`);
                    }
                });
                
                // Test basic WebGL operations
                try {
                    // Test shader compilation
                    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                    
                    const testVertexShader = `
                        attribute vec3 position;
                        void main() {
                            gl_Position = vec4(position, 1.0);
                        }
                    `;
                    
                    const testFragmentShader = `
                        precision mediump float;
                        void main() {
                            gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
                        }
                    `;
                    
                    gl.shaderSource(vertexShader, testVertexShader);
                    gl.shaderSource(fragmentShader, testFragmentShader);
                    gl.compileShader(vertexShader);
                    gl.compileShader(fragmentShader);
                    
                    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                        throw new Error('Vertex shader compilation failed');
                    }
                    
                    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                        throw new Error('Fragment shader compilation failed');
                    }
                    
                    // Test program linking
                    const program = gl.createProgram();
                    gl.attachShader(program, vertexShader);
                    gl.attachShader(program, fragmentShader);
                    gl.linkProgram(program);
                    
                    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                        throw new Error('Shader program linking failed');
                    }
                    
                    // Cleanup
                    gl.deleteShader(vertexShader);
                    gl.deleteShader(fragmentShader);
                    gl.deleteProgram(program);
                    
                    console.log('   ✅ Shader compilation and linking test passed');
                    
                } catch (shaderError) {
                    console.warn('   ⚠️ Shader test failed:', shaderError.message);
                }
                
                // Test texture creation
                try {
                    const texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                    gl.deleteTexture(texture);
                    console.log('   ✅ Texture creation test passed');
                } catch (textureError) {
                    console.warn('   ⚠️ Texture test failed:', textureError.message);
                }
                
                // Clean up test canvas
                canvas.remove();
                
                // Report results
                if (missingCritical.length > 0) {
                    console.warn('⚠️ Missing critical WebGL extensions:', missingCritical);
                    console.warn('   3D Smart City may not render correctly');
                }
                
                if (missingOptional.length > 0) {
                    console.warn('⚠️ Missing optional WebGL extensions:', missingOptional);
                    console.warn('   Some visual effects may be unavailable');
                }
                
                // Minimum requirements check
                if (maxTextureSize < 1024) {
                    console.warn('⚠️ Low texture size limit. Minimum 1024x1024 recommended.');
                }
                
                if (maxViewportDims[0] < 1024 || maxViewportDims[1] < 1024) {
                    console.warn('⚠️ Limited viewport size. May affect rendering on large screens.');
                }
                
                console.log('✅ WebGL validation completed successfully');
                
                // Store WebGL info globally for debugging
                window.webglInfo = {
                    version,
                    renderer,
                    vendor,
                    glVersion,
                    maxTextureSize,
                    maxRenderbufferSize,
                    maxViewportDims,
                    missingCritical,
                    missingOptional
                };
                
                return true;
                
            } catch (e) {
                console.error('❌ WebGL validation failed:', e);
                console.error('   Browser:', navigator.userAgent);
                console.error('   Hardware acceleration may be disabled');
                console.error('   Try: chrome://settings/system (enable hardware acceleration)');
                return false;
            }
        }

        // Enhanced THREE.js loading detection with timeout and retries
        function waitForTHREEJS(callback, maxAttempts = 50, attempt = 1) {
            console.log(`🔍 Checking THREE.js availability (attempt ${attempt}/${maxAttempts})`);
            
            // Check if THREE.js is fully loaded and functional
            if (typeof THREE !== 'undefined' && window.THREE_LOADED === true) {
                // Additional validation: check if THREE.js core objects are available
                try {
                    if (THREE.Scene && THREE.Camera && THREE.WebGLRenderer && THREE.Mesh) {
                        console.log('✅ THREE.js fully loaded and validated');
                        console.log(`   Version: ${THREE.REVISION}`);
                        console.log(`   Core objects verified: Scene, Camera, WebGLRenderer, Mesh`);
                        callback();
                        return;
                    }
                } catch (e) {
                    console.warn(`⚠️ THREE.js validation failed: ${e.message}`);
                }
            }
            
            if (attempt >= maxAttempts) {
                console.error('❌ THREE.js loading timeout after maximum attempts');
                showError('Không thể tải Three.js sau nhiều lần thử. Vui lòng tải lại trang.');
                return;
            }
            
            // Wait 100ms and try again
            setTimeout(() => {
                waitForTHREEJS(callback, maxAttempts, attempt + 1);
            }, 100);
        }

        // Initialize function to be called after THREE.js is ready
        function startApp() {
            console.log('🚀 Starting 3D Smart City application');
            
            if (!checkWebGLSupport()) {
                showError('Trình duyệt của bạn không hỗ trợ WebGL. Vui lòng sử dụng trình duyệt hiện đại.');
                return;
            }
            
            // Final THREE.js validation before initialization
            try {
                const testScene = new THREE.Scene();
                testScene.dispose && testScene.dispose();
                console.log('✅ THREE.js runtime validation successful');
            } catch (e) {
                console.error('❌ THREE.js runtime validation failed:', e);
                showError('Three.js không hoạt động đúng. Vui lòng tải lại trang.');
                return;
            }
            
            // Start async initialization
            initSmartCity();
        }

        // Initialize on load with enhanced THREE.js detection
        window.addEventListener('DOMContentLoaded', () => {
            console.log('📄 DOM Content Loaded - Starting initialization sequence');
            initializeLoading();
            
            // Listen for threejs-loaded event for immediate response
            const handleThreeJSLoaded = () => {
                console.log('⚡ Received threejs-loaded event');
                window.removeEventListener('threejs-loaded', handleThreeJSLoaded);
                // Small delay to ensure all THREE.js components are ready
                setTimeout(() => {
                    waitForTHREEJS(startApp);
                }, 50);
            };
            
            window.addEventListener('threejs-loaded', handleThreeJSLoaded);
            
            // Also check immediately in case THREE.js is already loaded
            if (window.THREE_LOADED === true && typeof THREE !== 'undefined') {
                console.log('⚡ THREE.js already loaded, proceeding immediately');
                window.removeEventListener('threejs-loaded', handleThreeJSLoaded);
                setTimeout(() => {
                    waitForTHREEJS(startApp);
                }, 50);
            } else {
                // Fallback: wait for THREE.js with timeout if event doesn't fire
                setTimeout(() => {
                    if (typeof THREE === 'undefined' || window.THREE_LOADED !== true) {
                        console.log('⏰ Fallback: waiting for THREE.js without event');
                        waitForTHREEJS(startApp);
                    }
                }, 1000);
            }
        });

        // Toggle info panel visibility
        function toggleInfoPanel() {
            const panel = document.getElementById('info-panel');
            const toggleBtn = document.querySelector('.panel-toggle');
            
            if (panel.classList.contains('hidden')) {
                // Show panel
                panel.classList.remove('hidden');
                toggleBtn.classList.remove('panel-hidden');
                toggleBtn.innerHTML = '✖';
                toggleBtn.title = 'Ẩn bảng thông tin';
            } else {
                // Hide panel
                panel.classList.add('hidden');
                toggleBtn.classList.add('panel-hidden');
                toggleBtn.innerHTML = '☰';
                toggleBtn.title = 'Hiện bảng thông tin';
            }
        }

        // Camera view positions and targets
        const cameraViews = {
            aerial: {
                position: { x: 300, y: 400, z: 200 },
                target: { x: 200, y: 0, z: 0 },
                name: 'Aerial View'
            },
            street: {
                position: { x: -50, y: 8, z: 50 },
                target: { x: 50, y: 5, z: -50 },
                name: 'Street View'
            },
            birdseye: {
                position: { x: 200, y: 600, z: 100 },
                target: { x: 200, y: 0, z: 0 },
                name: "Bird's Eye View"
            },
            overview: {
                position: { x: 200, y: 800, z: 100 },
                target: { x: 200, y: 0, z: 0 },
                name: "Complete Overview"
            },
            cinematic: {
                position: { x: 150, y: 100, z: 150 },
                target: { x: 0, y: 0, z: 0 },
                name: 'Cinematic View'
            }
        };

        // Smooth camera animation function
        function animateCamera(targetPos, targetLookAt, duration = 2000) {
            if (cameraAnimation) {
                cancelAnimationFrame(cameraAnimation);
            }
            
            const startPos = camera.position.clone();
            const startLookAt = controls.target.clone();
            const startTime = performance.now();
            
            function animate() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Smooth easing function
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                // Interpolate position
                camera.position.lerpVectors(startPos, targetPos, easeProgress);
                
                // Interpolate look-at target
                const currentTarget = new THREE.Vector3().lerpVectors(startLookAt, targetLookAt, easeProgress);
                controls.target.copy(currentTarget);
                controls.update();
                
                if (progress < 1) {
                    cameraAnimation = requestAnimationFrame(animate);
                } else {
                    cameraAnimation = null;
                }
            }
            
            animate();
        }

        // Set camera view function
        function setCameraView(viewName) {
            // Stop cinematic mode if active
            if (isCinematicMode) {
                isCinematicMode = false;
            }
            
            const view = cameraViews[viewName];
            if (!view) return;
            
            // Update button states
            document.querySelectorAll('.camera-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(viewName + 'ViewBtn').classList.add('active');
            
            currentCameraView = viewName;
            
            const targetPos = new THREE.Vector3(view.position.x, view.position.y, view.position.z);
            const targetLookAt = new THREE.Vector3(view.target.x, view.target.y, view.target.z);
            
            // Special handling for cinematic view
            if (viewName === 'cinematic') {
                startCinematicMode();
            } else {
                animateCamera(targetPos, targetLookAt);
            }
            
            console.log(`🎥 Switched to ${view.name}`);
        }

        // Cinematic mode with orbital rotation and dynamic targets
        function startCinematicMode() {
            isCinematicMode = true;
            cinematicRotation = 0;
            
            function cinematicLoop() {
                if (!isCinematicMode) return;
                
                cinematicRotation += 0.003; // Slower, more cinematic
                const radius = 180 + Math.sin(cinematicRotation * 0.3) * 50;
                const height = 100 + Math.sin(cinematicRotation * 0.7) * 30;
                
                const x = Math.cos(cinematicRotation) * radius;
                const z = Math.sin(cinematicRotation) * radius;
                const y = height;
                
                // Dynamic target points for more interesting shots
                const targetX = Math.sin(cinematicRotation * 0.5) * 50;
                const targetZ = Math.cos(cinematicRotation * 0.3) * 50;
                const targetY = Math.sin(cinematicRotation * 0.8) * 10;
                
                camera.position.set(x, y, z);
                controls.target.set(targetX, targetY, targetZ);
                controls.update();
                
                requestAnimationFrame(cinematicLoop);
            }
            
            cinematicLoop();
        }
        
        // Toggle building phase visibility
        function togglePhase(phaseName) {
            const phase = buildingPhases[phaseName];
            const button = document.getElementById(phaseName + 'Btn');
            
            // Toggle visibility
            phase.visible = !phase.visible;
            
            // Update button appearance
            if (phase.visible) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
            
            // Animate buildings visibility
            phase.buildings.forEach(building => {
                if (phase.visible) {
                    // Fade in
                    building.visible = true;
                    animateBuildingOpacity(building, 0, 1, 500);
                } else {
                    // Fade out
                    animateBuildingOpacity(building, 1, 0, 500, () => {
                        building.visible = false;
                    });
                }
            });
            
            console.log(`🏗️ ${phaseName} ${phase.visible ? 'shown' : 'hidden'}`);
        }
        
        // Animate building opacity
        function animateBuildingOpacity(building, fromOpacity, toOpacity, duration, callback) {
            const startTime = performance.now();
            
            function animate() {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const currentOpacity = fromOpacity + (toOpacity - fromOpacity) * progress;
                
                // Apply opacity to all materials in the building
                building.traverse(child => {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.transparent = true;
                                mat.opacity = currentOpacity;
                            });
                        } else {
                            child.material.transparent = true;
                            child.material.opacity = currentOpacity;
                        }
                    }
                });
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else if (callback) {
                    callback();
                }
            }
            
            animate();
        }
        
        // Show all building phases
        function showAllPhases() {
            const button = document.getElementById('showAllBtn');
            const allPhases = ['phase1', 'phase2', 'phase3'];
            
            // Check if all phases are currently visible
            const allVisible = allPhases.every(phase => buildingPhases[phase].visible);
            
            if (allVisible) {
                // Hide all phases
                allPhases.forEach(phaseName => {
                    const phase = buildingPhases[phaseName];
                    const phaseButton = document.getElementById(phaseName + 'Btn');
                    
                    phase.visible = false;
                    phaseButton.classList.remove('active');
                    
                    // Fade out buildings
                    phase.buildings.forEach(building => {
                        animateBuildingOpacity(building, 1, 0, 500, () => {
                            building.visible = false;
                        });
                    });
                });
                
                button.textContent = 'SHOW ALL PHASES';
                button.innerHTML = '<span class="phase-indicator phase-all" style="background: linear-gradient(to right, #4682B4 0%, #FF8C00 50%, #32CD32 100%); width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>SHOW ALL PHASES';
                button.classList.remove('active');
                console.log('🏗️ All phases hidden');
            } else {
                // Show all phases
                allPhases.forEach(phaseName => {
                    const phase = buildingPhases[phaseName];
                    const phaseButton = document.getElementById(phaseName + 'Btn');
                    
                    if (!phase.visible) {
                        phase.visible = true;
                        phaseButton.classList.add('active');
                        
                        // Fade in buildings
                        phase.buildings.forEach(building => {
                            building.visible = true;
                            animateBuildingOpacity(building, 0, 1, 500);
                        });
                    }
                });
                
                button.textContent = 'HIDE ALL PHASES';
                button.innerHTML = '<span class="phase-indicator phase-all" style="background: linear-gradient(to right, #4682B4 0%, #FF8C00 50%, #32CD32 100%); width: 8px; height: 8px; border-radius: 2px; display: inline-block; margin-right: 4px;"></span>HIDE ALL PHASES';
                button.classList.add('active');
                console.log('🏗️ All phases shown');
            }
        }

        // Global function references for onclick handlers
        window.setTimeOfDay = setTimeOfDay;
        window.toggleWireframe = toggleWireframe;
        window.toggleLandscapeMode = toggleLandscapeMode;
        window.toggleInfoPanel = toggleInfoPanel;
        window.setCameraView = setCameraView;
        window.togglePhase = togglePhase;
        window.showAllPhases = showAllPhases;

        // Data Centers Management Functions
        window.restoreOriginalDataCenters = function() {
            console.log("🔄 Restoring original data centers...");
            
            if (!window.scene) {
                console.error("❌ Scene not available");
                return false;
            }
            
            // Remove existing data centers
            const existingDataCenters = scene.children.filter(child => 
                child.userData && child.userData.type === 'dataCenter'
            );
            existingDataCenters.forEach(dc => scene.remove(dc));
            
            // Define original data centers positions (từ phía đông thành phố) - MOVED FURTHER RIGHT
            const dataCenters = [
                {x: 350, z: -120, name: "DATA CENTER 01"},
                {x: 350, z: 0, name: "DATA CENTER 02"}, 
                {x: 350, z: 120, name: "DATA CENTER 03"}
            ];
            
            dataCenters.forEach((dc, index) => {
                // Create geometry for data center
                const geometry = new THREE.BoxGeometry(25, 18, 30); // Bigger than normal buildings
                const material = new THREE.MeshLambertMaterial({
                    color: 0x2196F3, // Blue color for data centers
                    transparent: true,
                    opacity: 0.9
                });
                
                const dataCenter = new THREE.Mesh(geometry, material);
                dataCenter.position.set(dc.x, 9, dc.z); // Slightly elevated
                dataCenter.userData = {
                    type: 'dataCenter',
                    name: dc.name,
                    power: '100 MW mỗi tòa',
                    area: '17-22 HA',
                    cooling: 'Water cooling system',
                    buildingType: 'Data Center'
                };
                
                // Add to scene
                scene.add(dataCenter);
                console.log(`✅ Added ${dc.name} at position (${dc.x}, ${dc.z})`);
            });
            
            console.log(`🏢 Successfully restored ${dataCenters.length} data centers`);
            
            // Force render update
            if (window.renderer) {
                renderer.render(scene, camera);
            }
            
            return true;
        };

        // Initialize data centers restoration function - DISABLED
        // window.initializeThreeJS = function() {
        //     console.log("🔧 InitializeThreeJS called");
        //     if (window.restoreOriginalDataCenters) {
        //         return restoreOriginalDataCenters();
        //     }
        //     return false;
        // };

        // Force main scene load function
        window.forceMainSceneLoad = function() {
            console.log("🔄 Force loading main scene...");
            
            // Hide fallback scene
            const fallbackBanner = document.querySelector('.alert');
            if (fallbackBanner && fallbackBanner.textContent.includes('Fallback')) {
                fallbackBanner.style.display = 'none';
                console.log('✅ Fallback banner hidden');
            }
            
            // Check if scene exists and has proper content
            if (!window.scene) {
                console.error('❌ Main scene not initialized, attempting full init...');
                init(); // Re-initialize the whole scene
                return;
            }
            
            // Force restore data centers - DISABLED
            // if (window.restoreOriginalDataCenters) {
            //     const success = restoreOriginalDataCenters();
            //     if (success) {
            //         console.log('✅ Main scene restored successfully');
            //         
            //         // Force render
            //         if (window.renderer && window.camera) {
            //             renderer.render(scene, camera);
            //         }
            //         return true;
            //     }
            // }
            
            console.error('❌ Failed to restore main scene');
            return false;
        };

        // Debug scene objects function  
        window.debugSceneObjects = function() {
            if (!window.scene) {
                console.error('❌ Scene not available');
                return;
            }
            
            const datacenters = scene.children.filter(child => 
                child.userData && child.userData.type === 'dataCenter'
            );
            const buildings = scene.children.filter(child => 
                child.userData && child.userData.buildingType && child.userData.buildingType !== 'dataCenter'
            );
            const greenAreas = scene.children.filter(child => 
                child.material && child.material.color && child.material.color.getHex() === 0x4CAF50
            );
            
            console.log(`🏢 Data centers in scene: ${datacenters.length}`);
            console.log(`🏗️ Buildings in scene: ${buildings.length}`);  
            console.log(`🌿 Green areas in scene: ${greenAreas.length}`);
            console.log(`📊 Total scene children: ${scene.children.length}`);
            
            if (datacenters.length === 0) {
                console.log('❌ NO DATA CENTERS FOUND - This is expected as they are created by createDataCenterCluster');
                // DISABLED - Data centers are created properly by createDataCenterCluster
                // if (window.restoreOriginalDataCenters) {
                //     restoreOriginalDataCenters();
                // }
            }
            
            return {
                datacenters: datacenters.length,
                buildings: buildings.length,
                greenAreas: greenAreas.length,
                total: scene.children.length
            };
        };
        
        // Initialize popup close button
        document.addEventListener('DOMContentLoaded', () => {
            const popupCloseBtn = document.getElementById('popupCloseBtn');
            if (popupCloseBtn) {
                popupCloseBtn.addEventListener('click', hideBuildingInfo);
            }
            
            // Also close popup when clicking outside
            document.addEventListener('click', (event) => {
                const popup = document.getElementById('buildingInfoPopup');
                const isClickOnBuilding = event.target.tagName === 'CANVAS';
                const isClickInsidePopup = popup.contains(event.target);
                
                if (!isClickOnBuilding && !isClickInsidePopup && popup.classList.contains('show')) {
                    hideBuildingInfo();
                }
            });
        });

        // LAYOUT DEBUG: Function to visualize park and road boundaries 
        window.debugParkLayout = function() {
            console.log('🔍 DEBUGGING PARK LAYOUT - COLLISION ANALYSIS');
            console.log('='.repeat(60));
            
            // NEW PARK POSITIONS (Fixed Layout)
            const newLayout = [
                { name: 'Central Park', pos: [30, 35], size: [120, 80] },
                { name: 'Northwest Park', pos: [-160, 150], size: [50, 50] },
                { name: 'Southeast Park', pos: [170, -140], size: [40, 60] },
                { name: 'Southwest Park', pos: [-170, -150], size: [45, 45] },
                { name: 'Northeast Park', pos: [160, 140], size: [55, 40] },
                { name: 'South Park', pos: [-50, -160], size: [35, 50] }
            ];
            
            // ROAD NETWORK
            const roads = [
                { name: 'Main Vertical', bounds: { x: [-10, 10], z: [-250, 250] } },
                { name: 'Main Horizontal', bounds: { x: [-250, 250], z: [-10, 10] } },
                { name: 'East Vertical', bounds: { x: [92.5, 107.5], z: [-250, 250] } },
                { name: 'West Vertical', bounds: { x: [-107.5, -92.5], z: [-250, 250] } },
                { name: 'North Horizontal', bounds: { x: [-250, 250], z: [92.5, 107.5] } },
                { name: 'South Horizontal', bounds: { x: [-250, 250], z: [-107.5, -92.5] } }
            ];
            
            console.log('📍 NEW PARK POSITIONS:');
            newLayout.forEach((park, i) => {
                const [x, z] = park.pos;
                const [w, h] = park.size;
                const bounds = {
                    x: [x - w/2, x + w/2],
                    z: [z - h/2, z + h/2]
                };
                console.log(`   ${i}: ${park.name} at (${x}, ${z}) bounds: X[${bounds.x[0]}, ${bounds.x[1]}] Z[${bounds.z[0]}, ${bounds.z[1]}]`);
                
                // Check conflicts with each road
                let hasConflict = false;
                roads.forEach(road => {
                    if (bounds.x[0] < road.bounds.x[1] && bounds.x[1] > road.bounds.x[0] && 
                        bounds.z[0] < road.bounds.z[1] && bounds.z[1] > road.bounds.z[0]) {
                        console.log(`      ⚠️  CONFLICT with ${road.name}`);
                        hasConflict = true;
                    }
                });
                
                if (!hasConflict) {
                    console.log(`      ✅ Safe zone - no road conflicts`);
                }
            });
            
            console.log('\n🛣️  ROAD NETWORK COVERAGE:');
            roads.forEach(road => {
                console.log(`   ${road.name}: X[${road.bounds.x[0]}, ${road.bounds.x[1]}] Z[${road.bounds.z[0]}, ${road.bounds.z[1]}]`);
            });
            
            console.log('\n🎯 URBAN PLANNING VALIDATION:');
            console.log('✅ Parks moved to perimeter zones for realistic city layout');
            console.log('✅ Central area kept clear for main traffic arteries');
            console.log('✅ Each park positioned in distinct quadrant/zone');
            console.log('✅ Adequate spacing between parks and roads');
            console.log('✅ Maintains pedestrian accessibility via building footpaths');
            
            console.log('='.repeat(60));
            return 'Debug complete - check console for detailed analysis';
        };

        // Automatically run validation on page load
        window.addEventListener('load', () => {
            setTimeout(() => {
                if (typeof validateParkRoadLayout === 'function') {
                    console.log('\n🚀 AUTOMATIC LAYOUT VALIDATION:');
                    validateParkRoadLayout();
                }
            }, 2000);
        });

        // WEBGL DEBUG: Comprehensive diagnostic function
        window.debugWebGL = function() {
            console.log('🔧 WEBGL DIAGNOSTIC TOOLS');
            console.log('='.repeat(50));
            
            // 1. Show stored WebGL info
            if (window.webglInfo) {
                console.log('📊 WebGL System Information:');
                console.log(`   Version: WebGL ${window.webglInfo.version}`);
                console.log(`   GPU: ${window.webglInfo.renderer}`);
                console.log(`   Vendor: ${window.webglInfo.vendor}`);
                console.log(`   GL Version: ${window.webglInfo.glVersion}`);
                console.log(`   Max Texture: ${window.webglInfo.maxTextureSize}x${window.webglInfo.maxTextureSize}`);
                console.log(`   Max Viewport: ${window.webglInfo.maxViewportDims[0]}x${window.webglInfo.maxViewportDims[1]}`);
                
                if (window.webglInfo.missingCritical.length > 0) {
                    console.warn(`   ⚠️ Missing Critical: ${window.webglInfo.missingCritical.join(', ')}`);
                }
                if (window.webglInfo.missingOptional.length > 0) {
                    console.warn(`   ⚠️ Missing Optional: ${window.webglInfo.missingOptional.join(', ')}`);
                }
            }
            
            // 2. Check current renderer status
            if (window.renderer) {
                console.log('\n🎮 Current Renderer Status:');
                const gl = window.renderer.getContext();
                const info = window.renderer.info;
                
                console.log(`   Context Lost: ${gl.isContextLost()}`);
                console.log(`   Canvas Size: ${window.renderer.domElement.width}x${window.renderer.domElement.height}`);
                console.log(`   Pixel Ratio: ${window.renderer.getPixelRatio()}`);
                console.log(`   Memory - Geometries: ${info.memory.geometries}`);
                console.log(`   Memory - Textures: ${info.memory.textures}`);
                console.log(`   Render - Calls: ${info.render.calls}`);
                console.log(`   Render - Triangles: ${info.render.triangles}`);
                
                // Test a simple render
                try {
                    window.renderer.clear();
                    console.log('   ✅ Render test passed');
                } catch (e) {
                    console.error('   ❌ Render test failed:', e.message);
                }
            } else {
                console.error('❌ No renderer found!');
            }
            
            // 3. Check scene status
            if (window.scene) {
                console.log('\n🌍 Scene Status:');
                console.log(`   Children count: ${window.scene.children.length}`);
                console.log(`   Scene UUID: ${window.scene.uuid}`);
                
                const objects = {
                    meshes: 0,
                    lights: 0,
                    cameras: 0,
                    groups: 0
                };
                
                window.scene.traverse((child) => {
                    if (child.isMesh) objects.meshes++;
                    else if (child.isLight) objects.lights++;
                    else if (child.isCamera) objects.cameras++;
                    else if (child.isGroup) objects.groups++;
                });
                
                console.log(`   Meshes: ${objects.meshes}`);
                console.log(`   Lights: ${objects.lights}`);
                console.log(`   Groups: ${objects.groups}`);
            } else {
                console.error('❌ No scene found!');
            }
            
            // 4. Performance check
            console.log('\n⚡ Performance Check:');
            const start = performance.now();
            
            // Stress test: create and delete objects
            for (let i = 0; i < 100; i++) {
                const geo = new THREE.BoxGeometry(1, 1, 1);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const mesh = new THREE.Mesh(geo, mat);
                geo.dispose();
                mat.dispose();
            }
            
            const end = performance.now();
            console.log(`   100 object creation/deletion: ${(end - start).toFixed(2)}ms`);
            
            if (end - start < 50) {
                console.log('   ✅ Performance: Excellent');
            } else if (end - start < 100) {
                console.log('   ⚠️ Performance: Good');
            } else {
                console.log('   ❌ Performance: Poor - may indicate WebGL issues');
            }
            
            // 5. Browser compatibility
            console.log('\n🌐 Browser Compatibility:');
            console.log(`   User Agent: ${navigator.userAgent}`);
            console.log(`   Platform: ${navigator.platform}`);
            console.log(`   Hardware Concurrency: ${navigator.hardwareConcurrency || 'unknown'}`);
            console.log(`   Memory: ${navigator.deviceMemory || 'unknown'}GB`);
            
            console.log('\n' + '='.repeat(50));
            console.log('🎯 WebGL diagnostic complete!');
            
            return 'Diagnostic complete - check console for full report';
        };

        // Quick WebGL test function
        window.testWebGL = function() {
            console.log('🚀 Quick WebGL Test');
            
            if (!window.renderer) {
                return '❌ No renderer - WebGL initialization failed';
            }
            
            const gl = window.renderer.getContext();
            if (!gl) {
                return '❌ No WebGL context';
            }
            
            if (gl.isContextLost()) {
                return '❌ WebGL context is lost';
            }
            
            try {
                window.renderer.clear();
                return '✅ WebGL is working correctly';
            } catch (e) {
                return '❌ WebGL render failed: ' + e.message;
            }
        };

        // ENTERPRISE WEBGL TESTING SUITE
        window.testEnterpriseWebGL = async function() {
            console.log('🧪 ENTERPRISE WEBGL TESTING SUITE');
            console.log('='.repeat(60));
            
            const results = {
                timestamp: new Date().toISOString(),
                tests: [],
                summary: { passed: 0, failed: 0, warnings: 0 },
                performance: {},
                recommendations: []
            };
            
            // Test 1: WebGL Context Validation
            results.tests.push(await testWebGLContext());
            
            // Test 2: Advanced Features Testing
            results.tests.push(await testAdvancedFeatures());
            
            // Test 3: Performance Benchmarks
            results.tests.push(await testPerformanceBenchmarks());
            
            // Test 4: Memory Management
            results.tests.push(await testMemoryManagement());
            
            // Test 5: Error Recovery Systems
            results.tests.push(await testErrorRecovery());
            
            // Test 6: Quality Scaling Validation
            results.tests.push(await testQualityScaling());
            
            // Calculate summary
            results.tests.forEach(test => {
                if (test.status === 'PASS') results.summary.passed++;
                else if (test.status === 'FAIL') results.summary.failed++;
                else results.summary.warnings++;
            });
            
            // Generate recommendations
            generateRecommendations(results);
            
            // Output comprehensive report
            console.log('\n📊 TEST RESULTS SUMMARY:');
            console.log(`   ✅ Passed: ${results.summary.passed}/${results.tests.length}`);
            console.log(`   ❌ Failed: ${results.summary.failed}/${results.tests.length}`);
            console.log(`   ⚠️ Warnings: ${results.summary.warnings}/${results.tests.length}`);
            
            if (results.recommendations.length > 0) {
                console.log('\n💡 RECOMMENDATIONS:');
                results.recommendations.forEach((rec, i) => {
                    console.log(`   ${i + 1}. ${rec}`);
                });
            }
            
            console.log('\n' + '='.repeat(60));
            console.log('🎯 Enterprise WebGL testing complete!');
            
            return results;
            
            async function testWebGLContext() {
                const test = { name: 'WebGL Context Validation', status: 'PASS', details: [] };
                
                try {
                    if (!window.renderer) {
                        test.status = 'FAIL';
                        test.details.push('No renderer found');
                        return test;
                    }
                    
                    const gl = window.renderer.getContext();
                    if (!gl) {
                        test.status = 'FAIL';
                        test.details.push('No WebGL context available');
                        return test;
                    }
                    
                    if (gl.isContextLost()) {
                        test.status = 'FAIL';
                        test.details.push('WebGL context is lost');
                        return test;
                    }
                    
                    // Test basic WebGL operations
                    const originalColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
                    gl.clearColor(1.0, 0.0, 0.0, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    
                    // Test framebuffer status
                    const fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                    if (fbStatus !== gl.FRAMEBUFFER_COMPLETE) {
                        test.status = 'WARN';
                        test.details.push('Framebuffer not complete: ' + fbStatus);
                    }
                    
                    // Restore original state
                    gl.clearColor(...originalColor);
                    
                    test.details.push('WebGL context is healthy and operational');
                    
                } catch (error) {
                    test.status = 'FAIL';
                    test.details.push('Context test failed: ' + error.message);
                }
                
                return test;
            }
            
            async function testAdvancedFeatures() {
                const test = { name: 'Advanced Features Testing', status: 'PASS', details: [] };
                
                try {
                    if (!window.webglCapabilities) {
                        test.status = 'WARN';
                        test.details.push('WebGL capabilities not available');
                        return test;
                    }
                    
                    const caps = window.webglCapabilities;
                    const criticalFeatures = ['shadows', 'float_textures'];
                    const missingCritical = [];
                    
                    criticalFeatures.forEach(feature => {
                        if (!caps.enabledFeatures.includes(feature)) {
                            missingCritical.push(feature);
                        }
                    });
                    
                    if (missingCritical.length > 0) {
                        test.status = 'WARN';
                        test.details.push(`Missing critical features: ${missingCritical.join(', ')}`);
                    }
                    
                    // Test texture creation
                    const gl = window.renderer.getContext();
                    const testTexture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, testTexture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 256, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                    
                    if (gl.getError() !== gl.NO_ERROR) {
                        test.status = 'FAIL';
                        test.details.push('Texture creation failed');
                    } else {
                        test.details.push('Texture creation successful');
                    }
                    
                    gl.deleteTexture(testTexture);
                    
                    test.details.push(`Enabled features: ${caps.enabledFeatures.join(', ')}`);
                    
                } catch (error) {
                    test.status = 'FAIL';
                    test.details.push('Advanced features test failed: ' + error.message);
                }
                
                return test;
            }
            
            async function testPerformanceBenchmarks() {
                const test = { name: 'Performance Benchmarks', status: 'PASS', details: [] };
                
                try {
                    if (!window.renderer) {
                        test.status = 'FAIL';
                        test.details.push('No renderer for performance testing');
                        return test;
                    }
                    
                    const gl = window.renderer.getContext();
                    
                    // Render performance test
                    const renderStart = performance.now();
                    for (let i = 0; i < 100; i++) {
                        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    }
                    const renderEnd = performance.now();
                    const renderTime = renderEnd - renderStart;
                    
                    // Memory allocation test
                    const memStart = performance.now();
                    const testObjects = [];
                    for (let i = 0; i < 1000; i++) {
                        const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                        const mat = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
                        const mesh = new THREE.Mesh(geo, mat);
                        testObjects.push(mesh);
                    }
                    const memEnd = performance.now();
                    const memTime = memEnd - memStart;
                    
                    // Cleanup
                    testObjects.forEach(obj => {
                        obj.geometry.dispose();
                        obj.material.dispose();
                    });
                    
                    results.performance = {
                        renderTime: renderTime,
                        memoryAllocationTime: memTime,
                        renderFPS: Math.round(100000 / renderTime),
                        memoryScore: memTime < 50 ? 'excellent' : memTime < 100 ? 'good' : 'poor'
                    };
                    
                    if (renderTime > 100) {
                        test.status = 'WARN';
                        test.details.push(`Slow render performance: ${renderTime.toFixed(2)}ms`);
                    }
                    
                    test.details.push(`Render performance: ${renderTime.toFixed(2)}ms for 100 clears`);
                    test.details.push(`Memory allocation: ${memTime.toFixed(2)}ms for 1000 objects`);
                    
                } catch (error) {
                    test.status = 'FAIL';
                    test.details.push('Performance test failed: ' + error.message);
                }
                
                return test;
            }
            
            async function testMemoryManagement() {
                const test = { name: 'Memory Management', status: 'PASS', details: [] };
                
                try {
                    const gl = window.renderer.getContext();
                    const info = window.renderer.info;
                    
                    // Test resource creation and cleanup
                    const initialGeometries = info.memory.geometries;
                    const initialTextures = info.memory.textures;
                    
                    // Create and dispose resources
                    const geo = new THREE.BoxGeometry(1, 1, 1);
                    const tex = new THREE.DataTexture(new Uint8Array([255, 0, 0, 255]), 1, 1);
                    
                    geo.dispose();
                    tex.dispose();
                    
                    // Check if resources were properly cleaned up
                    setTimeout(() => {
                        const finalGeometries = info.memory.geometries;
                        const finalTextures = info.memory.textures;
                        
                        if (finalGeometries > initialGeometries + 1) {
                            test.status = 'WARN';
                            test.details.push('Geometry cleanup may be incomplete');
                        }
                        
                        if (finalTextures > initialTextures + 1) {
                            test.status = 'WARN';
                            test.details.push('Texture cleanup may be incomplete');
                        }
                    }, 100);
                    
                    // Test memory monitoring
                    if (window.safeWebGLOperation) {
                        test.details.push('Safe WebGL operation wrapper available');
                    } else {
                        test.status = 'WARN';
                        test.details.push('No safe WebGL operation wrapper');
                    }
                    
                    test.details.push(`Current geometries: ${info.memory.geometries}`);
                    test.details.push(`Current textures: ${info.memory.textures}`);
                    
                } catch (error) {
                    test.status = 'FAIL';
                    test.details.push('Memory management test failed: ' + error.message);
                }
                
                return test;
            }
            
            async function testErrorRecovery() {
                const test = { name: 'Error Recovery Systems', status: 'PASS', details: [] };
                
                try {
                    // Test safe operation wrapper
                    if (window.safeWebGLOperation) {
                        const result = window.safeWebGLOperation(() => {
                            return 'test successful';
                        });
                        
                        if (result === 'test successful') {
                            test.details.push('Safe operation wrapper working');
                        } else {
                            test.status = 'WARN';
                            test.details.push('Safe operation wrapper not functioning correctly');
                        }
                    } else {
                        test.status = 'FAIL';
                        test.details.push('No error recovery system found');
                    }
                    
                    // Test context loss detection
                    const canvas = window.renderer.domElement;
                    const hasContextLostListener = canvas.onwebglcontextlost !== null;
                    const hasContextRestoredListener = canvas.onwebglcontextrestored !== null;
                    
                    if (hasContextLostListener || hasContextRestoredListener) {
                        test.details.push('Context loss recovery listeners installed');
                    } else {
                        test.status = 'WARN';
                        test.details.push('No context loss recovery listeners');
                    }
                    
                } catch (error) {
                    test.status = 'FAIL';
                    test.details.push('Error recovery test failed: ' + error.message);
                }
                
                return test;
            }
            
            async function testQualityScaling() {
                const test = { name: 'Quality Scaling Validation', status: 'PASS', details: [] };
                
                try {
                    if (!window.renderQuality) {
                        test.status = 'WARN';
                        test.details.push('No quality scaling system detected');
                        return test;
                    }
                    
                    const quality = window.renderQuality;
                    
                    // Validate quality configuration
                    const requiredProps = ['level', 'shadows', 'antialiasing', 'pixelRatio'];
                    const missingProps = requiredProps.filter(prop => !(prop in quality));
                    
                    if (missingProps.length > 0) {
                        test.status = 'FAIL';
                        test.details.push(`Missing quality properties: ${missingProps.join(', ')}`);
                    }
                    
                    // Test quality level appropriateness
                    const deviceInfo = window.webglCapabilities.deviceInfo;
                    if (deviceInfo) {
                        const appropriateLevel = deviceInfo.isMobile ? ['low', 'medium'] : ['medium', 'high', 'ultra'];
                        if (!appropriateLevel.includes(quality.level)) {
                            test.status = 'WARN';
                            test.details.push(`Quality level ${quality.level} may not be optimal for ${deviceInfo.deviceClass} device`);
                        }
                    }
                    
                    test.details.push(`Quality level: ${quality.level}`);
                    test.details.push(`Shadows: ${quality.shadows ? 'enabled' : 'disabled'}`);
                    test.details.push(`Antialiasing: ${quality.antialiasing ? 'enabled' : 'disabled'}`);
                    test.details.push(`Pixel ratio: ${quality.pixelRatio}`);
                    
                } catch (error) {
                    test.status = 'FAIL';
                    test.details.push('Quality scaling test failed: ' + error.message);
                }
                
                return test;
            }
            
            function generateRecommendations(results) {
                const failed = results.tests.filter(t => t.status === 'FAIL');
                const warnings = results.tests.filter(t => t.status === 'WARN');
                
                if (failed.length > 0) {
                    results.recommendations.push('Critical WebGL failures detected - check browser compatibility and hardware acceleration');
                }
                
                if (warnings.length > 2) {
                    results.recommendations.push('Multiple warnings detected - consider updating graphics drivers or using a different browser');
                }
                
                if (results.performance.renderTime > 100) {
                    results.recommendations.push('Poor render performance detected - consider reducing quality settings or scene complexity');
                }
                
                if (!window.webglCapabilities.extensions['WEBGL_depth_texture']) {
                    results.recommendations.push('Depth texture extension not available - shadows will be disabled');
                }
                
                if (window.renderQuality && window.renderQuality.level === 'low') {
                    results.recommendations.push('Running in low quality mode - upgrade hardware for better visual experience');
                }
            }
        };
        
        }); // End of waitForThreeJs wrapper
        
    </script>
</body>
</html>