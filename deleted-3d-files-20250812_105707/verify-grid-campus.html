<!DOCTYPE html>
<html>
<head>
    <title>Grid Campus Verification</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; background: #f0f8ff; font-family: monospace; }
        #info { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 5px; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="info">
        <h3>üèóÔ∏è Grid Campus Layout Verification</h3>
        <div id="status">Initializing...</div>
        <div>Objects: <span id="objects">0</span></div>
        <div>Buildings: <span id="buildings">0</span></div>
        <div>Trees: <span id="trees">0</span></div>
    </div>
    <script>
        // Create scene, camera, renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f8ff);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(100, 100, 50);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Grid Campus Layout
        function createGridCampusLayout() {
            console.log('üèóÔ∏è Creating Grid Campus Layout...');
            
            const gridSize = 10;
            const cellSize = 20;
            const gridGroup = new THREE.Group();
            
            // White grid cells
            for (let x = 0; x < gridSize; x++) {
                for (let z = 0; z < gridSize; z++) {
                    const cellGeometry = new THREE.PlaneGeometry(cellSize - 1, cellSize - 1);
                    const cellMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const cell = new THREE.Mesh(cellGeometry, cellMaterial);
                    cell.rotation.x = -Math.PI / 2;
                    cell.position.set(
                        (x - gridSize/2) * cellSize,
                        0.1,
                        (z - gridSize/2) * cellSize
                    );
                    gridGroup.add(cell);
                }
            }
            
            // Gray grid lines
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x888888 });
            
            // Horizontal lines
            for (let i = 0; i <= gridSize; i++) {
                const points = [];
                points.push(new THREE.Vector3(-gridSize/2 * cellSize, 0.2, (i - gridSize/2) * cellSize));
                points.push(new THREE.Vector3(gridSize/2 * cellSize, 0.2, (i - gridSize/2) * cellSize));
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                gridGroup.add(line);
            }
            
            // Vertical lines
            for (let i = 0; i <= gridSize; i++) {
                const points = [];
                points.push(new THREE.Vector3((i - gridSize/2) * cellSize, 0.2, -gridSize/2 * cellSize));
                points.push(new THREE.Vector3((i - gridSize/2) * cellSize, 0.2, gridSize/2 * cellSize));
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                gridGroup.add(line);
            }
            
            scene.add(gridGroup);
            
            // Colorful buildings
            const buildingConfigs = [
                {x: 1, z: 3, color: 0x4a90e2, height: 25, width: 8, depth: 8},
                {x: 7, z: 1, color: 0x5dade2, height: 30, width: 6, depth: 12},
                {x: 3, z: 6, color: 0x3498db, height: 20, width: 10, depth: 6},
                {x: 5, z: 2, color: 0xe74c3c, height: 35, width: 12, depth: 8},
                {x: 1, z: 7, color: 0xf39c12, height: 15, width: 8, depth: 8},
                {x: 8, z: 4, color: 0xff6b9d, height: 20, width: 6, depth: 10},
                {x: 6, z: 8, color: 0x9b59b6, height: 28, width: 8, depth: 12},
                {x: 2, z: 8, color: 0x27ae60, height: 22, width: 10, depth: 8},
                {x: 8, z: 7, color: 0x2ecc71, height: 18, width: 8, depth: 8},
                {x: 9, z: 3, color: 0x34495e, height: 40, width: 8, depth: 6},
                {x: 4, z: 1, color: 0x7f8c8d, height: 25, width: 6, depth: 8},
                {x: 0, z: 5, color: 0x1abc9c, height: 30, width: 8, depth: 10},
                {x: 6, z: 6, color: 0x16a085, height: 25, width: 10, depth: 8}
            ];
            
            let buildingCount = 0;
            buildingConfigs.forEach(config => {
                const geometry = new THREE.BoxGeometry(config.width, config.height, config.depth);
                const material = new THREE.MeshLambertMaterial({ color: config.color });
                
                const building = new THREE.Mesh(geometry, material);
                building.position.set(
                    (config.x - gridSize/2) * cellSize,
                    config.height / 2,
                    (config.z - gridSize/2) * cellSize
                );
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
                buildingCount++;
            });
            
            // Green trees
            const treePositions = [
                {x: 0.5, z: 1.5}, {x: 2.5, z: 0.5}, {x: 4.5, z: 3.5}, {x: 1.5, z: 4.5},
                {x: 6.5, z: 2.5}, {x: 3.5, z: 7.5}, {x: 7.5, z: 6.5}, {x: 9.5, z: 8.5},
                {x: 0.5, z: 8.5}, {x: 5.5, z: 5.5}, {x: 8.5, z: 0.5}, {x: 2.5, z: 3.5},
                {x: 4.5, z: 9.5}, {x: 7.5, z: 4.5}, {x: 1.5, z: 6.5}, {x: 9.5, z: 1.5},
                {x: 3.5, z: 2.5}, {x: 6.5, z: 9.5}, {x: 0.5, z: 3.5}, {x: 8.5, z: 5.5}
            ];
            
            let treeCount = 0;
            treePositions.forEach(pos => {
                // Tree trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 4);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(
                    (pos.x - gridSize/2) * cellSize,
                    2,
                    (pos.z - gridSize/2) * cellSize
                );
                scene.add(trunk);
                
                // Tree leaves
                const leavesGeometry = new THREE.SphereGeometry(3, 8, 6);
                const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228b22 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.set(
                    (pos.x - gridSize/2) * cellSize,
                    6,
                    (pos.z - gridSize/2) * cellSize
                );
                scene.add(leaves);
                treeCount++;
            });
            
            // Set camera for aerial view
            camera.position.set(120, 100, 120);
            camera.lookAt(0, 0, 0);
            
            // Update stats
            document.getElementById('objects').textContent = scene.children.length;
            document.getElementById('buildings').textContent = buildingCount;
            document.getElementById('trees').textContent = treeCount;
            document.getElementById('status').textContent = '‚úÖ Grid Campus Layout created successfully!';
            
            console.log('‚úÖ Grid Campus Layout created with', scene.children.length, 'objects');
        }

        // Initialize
        createGridCampusLayout();

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>