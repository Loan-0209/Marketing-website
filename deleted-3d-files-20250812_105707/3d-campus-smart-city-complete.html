<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Smart City Campus - BULLETPROOF VERSION</title>
    
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #87CEEB 0%, #B0E0E6 50%, #F0F8FF 100%);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* BULLETPROOF CANVAS CONTAINER */
        #canvas-container {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 1 !important;
            overflow: hidden !important;
            background: transparent !important;
            pointer-events: all !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        #canvas-container canvas {
            display: block !important;
            width: 100% !important;
            height: 100% !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* UI OVERLAY */
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* HEADER */
        .header {
            background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            padding: 1rem 0;
            pointer-events: all;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .header-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2rem;
        }

        .logo {
            color: #fbbf24;
            font-size: 2rem;
            font-weight: 800;
            text-decoration: none;
        }

        .nav {
            display: flex;
            gap: 1rem;
        }

        .nav a {
            color: white;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-weight: 600;
            transition: background 0.3s;
        }

        .nav a:hover, .nav .active {
            background: rgba(255, 255, 255, 0.2);
        }

        /* CONTROL PANELS */
        .control-panel {
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 15px;
            padding: 20px;
            color: white;
            pointer-events: all;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .camera-controls {
            position: fixed;
            top: 100px;
            left: 20px;
            min-width: 200px;
        }

        .camera-controls h3 {
            color: #3b82f6;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .camera-btn {
            display: block;
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 8px;
            border: 1px solid rgba(59, 130, 246, 0.5);
            border-radius: 8px;
            background: rgba(59, 130, 246, 0.1);
            color: white;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
        }

        .camera-btn:hover {
            background: rgba(59, 130, 246, 0.3);
        }

        .camera-btn.active {
            background: #3b82f6;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.4);
        }

        .stats-panel {
            position: fixed;
            top: 100px;
            right: 20px;
            min-width: 200px;
        }

        .stats-panel h3 {
            color: #3b82f6;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 5px 0;
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
        }

        .stat-value {
            color: #10b981;
            font-weight: 600;
        }

        .phase-controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }

        .phase-btn {
            padding: 12px 25px;
            border: 2px solid rgba(59, 130, 246, 0.5);
            border-radius: 25px;
            background: rgba(59, 130, 246, 0.1);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .phase-btn:hover {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.3);
        }

        .phase-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
        }

        .info-panel {
            position: fixed;
            bottom: 30px;
            right: 20px;
            max-width: 300px;
        }

        .info-panel h3 {
            color: #3b82f6;
            margin-bottom: 15px;
        }

        .feature-list {
            list-style: none;
        }

        .feature-list li {
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .feature-list li::before {
            content: "‚ñ∂ ";
            color: #10b981;
        }

        /* ERROR MESSAGE */
        .error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(239, 68, 68, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 9999;
            font-size: 1.1em;
            max-width: 500px;
        }

        .loading-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(59, 130, 246, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 9999;
            font-size: 1.1em;
        }

        @media (max-width: 768px) {
            .camera-controls, .stats-panel {
                min-width: 160px;
                padding: 15px;
                font-size: 0.9em;
            }
            
            .phase-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .nav {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Message -->
    <div id="loading-message" class="loading-message">
        <h3>üöÄ ƒêang t·∫£i Th√†nh Ph·ªë Th√¥ng Minh 3D...</h3>
        <p>Vui l√≤ng ch·ªù trong gi√¢y l√°t</p>
    </div>

    <!-- Header Navigation -->
    <header class="header">
        <div class="header-container">
            <a href="index.html" class="logo">üöÄ HEART</a>
            <nav class="nav">
                <a href="index.html">Trang Ch·ªß</a>
                <a href="about.html">V·ªÅ Ch√∫ng T√¥i</a>
                <a href="master-plan.html">Quy Ho·∫°ch</a>
                <a href="#" class="active">Th√†nh Ph·ªë 3D</a>
                <a href="facilities.html">C∆° S·ªü</a>
                <a href="contact.html">Li√™n H·ªá</a>
            </nav>
        </div>
    </header>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div class="ui-overlay">
        <!-- Camera Controls -->
        <div class="control-panel camera-controls">
            <h3>üì∑ ƒêi·ªÅu Khi·ªÉn Camera</h3>
            <button class="camera-btn active" data-mode="overview" id="overview-btn">üåç T·ªïng Quan</button>
            <button class="camera-btn" data-mode="aerial" id="aerial-btn">üöÅ Nh√¨n T·ª´ Tr√™n</button>
            <button class="camera-btn" data-mode="ground" id="ground-btn">üö∂ T·∫ßm M·∫Øt Ng∆∞·ªùi</button>
            <button class="camera-btn" data-mode="orbit" id="orbit-btn">üîÑ Xoay T·ª± Do</button>
            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(59, 130, 246, 0.3);">
                <small style="color: #94a3b8;">Hi·ªán t·∫°i: <span id="current-view-mode">T·ªïng Quan</span></small>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="control-panel stats-panel">
            <h3>üìä Th·ªëng K√™ 3D</h3>
            <div class="stat-item">
                <span>FPS:</span>
                <span class="stat-value" id="fps-counter">60</span>
            </div>
            <div class="stat-item">
                <span>ƒê·ªëi t∆∞·ª£ng:</span>
                <span class="stat-value" id="object-counter">0</span>
            </div>
            <div class="stat-item">
                <span>Tam gi√°c:</span>
                <span class="stat-value" id="triangle-counter">0</span>
            </div>
            <div class="stat-item">
                <span>Giai ƒëo·∫°n:</span>
                <span class="stat-value" id="current-phase">1</span>
            </div>
            <div class="stat-item">
                <span>Camera:</span>
                <span class="stat-value" id="camera-mode">T·ªïng Quan</span>
            </div>
        </div>

        <!-- Phase Controls -->
        <div class="control-panel phase-controls">
            <button class="phase-btn active" data-phase="1">Giai ƒëo·∫°n 1: N·ªÅn T·∫£ng</button>
            <button class="phase-btn" data-phase="2">Giai ƒëo·∫°n 2: M·ªü R·ªông</button>
            <button class="phase-btn" data-phase="3">Giai ƒëo·∫°n 3: Th√¥ng Minh</button>
        </div>

        <!-- Info Panel -->
        <div class="control-panel info-panel">
            <h3>üèõÔ∏è Th√†nh Ph·ªë Th√¥ng Minh 3D</h3>
            <ul class="feature-list">
                <li>üèóÔ∏è Th√†nh ph·ªë 3D t∆∞∆°ng t√°c</li>
                <li>üéÆ K√©o chu·ªôt ƒë·ªÉ xoay camera</li>
                <li>üîç Cu·ªôn chu·ªôt ƒë·ªÉ zoom</li>
                <li>üè¢ Click t√≤a nh√† xem chi ti·∫øt</li>
                <li>‚ö° WebGL rendering realtime</li>
                <li>üåü √Ånh s√°ng v√† b√≥ng ƒë·ªï</li>
            </ul>
        </div>
    </div>

    <script>
        // BULLETPROOF 3D SMART CITY
        class BulletproofSmartCity {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.animationId = null;
                this.currentPhase = 1;
                this.currentView = 'overview';
                this.clickableObjects = [];
                this.isInitialized = false;
                this.frameCount = 0;
                
                // Camera positions
                this.cameraPositions = {
                    overview: { position: { x: 100, y: 80, z: 100 }, target: { x: 0, y: 0, z: 0 }, fov: 75 },
                    aerial: { position: { x: 0, y: 150, z: 50 }, target: { x: 0, y: 0, z: 0 }, fov: 60 },
                    ground: { position: { x: 80, y: 20, z: 80 }, target: { x: 0, y: 20, z: 0 }, fov: 85 },
                    orbit: { position: { x: 120, y: 100, z: 120 }, target: { x: 0, y: 0, z: 0 }, fov: 70 }
                };
            }

            // WebGL Detection
            detectWebGL() {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    return !!gl;
                } catch (e) {
                    return false;
                }
            }

            // Show error message
            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.innerHTML = `
                    <h3>‚ö†Ô∏è L·ªói Kh·ªüi T·∫°o 3D</h3>
                    <p>${message}</p>
                    <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; background: #3b82f6; color: white; border: none; border-radius: 8px; cursor: pointer;">üîÑ T·∫£i L·∫°i</button>
                `;
                document.body.appendChild(errorDiv);
            }

            // Hide loading message
            hideLoading() {
                const loading = document.getElementById('loading-message');
                if (loading) {
                    loading.style.display = 'none';
                }
            }

            // Initialize
            async init() {
                console.log('üöÄ BULLETPROOF Smart City initializing...');
                
                try {
                    // 1. Check WebGL support
                    if (!this.detectWebGL()) {
                        throw new Error('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ WebGL. Vui l√≤ng s·ª≠ d·ª•ng Chrome, Firefox ho·∫∑c Edge.');
                    }

                    // 2. Wait for Three.js to load
                    if (typeof THREE === 'undefined') {
                        await this.waitForThreeJS();
                    }

                    // 3. Create scene components
                    this.createScene();
                    this.setupLighting();
                    this.createCity();
                    this.setupControls();
                    this.setupUI();
                    this.startRenderLoop();
                    
                    // 4. Expose globally
                    window.campus = this;
                    window.scene = this.scene;
                    window.camera = this.camera;
                    window.renderer = this.renderer;
                    
                    this.isInitialized = true;
                    this.hideLoading();
                    
                    console.log('‚úÖ BULLETPROOF Smart City initialized successfully!');
                    
                } catch (error) {
                    console.error('‚ùå Initialization failed:', error);
                    this.showError(error.message);
                }
            }

            // Wait for Three.js to load
            waitForThreeJS() {
                return new Promise((resolve, reject) => {
                    let attempts = 0;
                    const maxAttempts = 50; // 5 seconds
                    
                    const check = () => {
                        if (typeof THREE !== 'undefined') {
                            resolve();
                        } else if (attempts >= maxAttempts) {
                            reject(new Error('Three.js failed to load'));
                        } else {
                            attempts++;
                            setTimeout(check, 100);
                        }
                    };
                    
                    check();
                });
            }

            // Create scene
            createScene() {
                const container = document.getElementById('canvas-container');
                if (!container) {
                    throw new Error('Canvas container not found');
                }

                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);

                // Camera
                const width = window.innerWidth;
                const height = window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                this.camera.position.set(100, 80, 100);
                this.camera.lookAt(0, 0, 0);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
                
                this.renderer.setSize(width, height);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setClearColor(0x87CEEB, 1.0);

                // Force canvas styling
                const canvas = this.renderer.domElement;
                canvas.style.cssText = `
                    display: block !important;
                    position: absolute !important;
                    top: 0 !important;
                    left: 0 !important;
                    width: 100% !important;
                    height: 100% !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                `;

                container.appendChild(canvas);
                
                // Immediate test render
                this.renderer.render(this.scene, this.camera);
                
                console.log('‚úÖ Scene created and test rendered');
            }

            // Setup lighting
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                // Directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(200, 200, 100);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -200;
                directionalLight.shadow.camera.right = 200;
                directionalLight.shadow.camera.top = 200;
                directionalLight.shadow.camera.bottom = -200;
                this.scene.add(directionalLight);

                console.log('‚úÖ Lighting setup complete');
            }

            // Create city
            createCity() {
                // Clear existing city
                const objectsToRemove = [];
                this.scene.traverse((child) => {
                    if (child.userData && (child.userData.type === 'building' || child.userData.type === 'ground' || child.userData.type === 'road' || child.userData.type === 'tree')) {
                        objectsToRemove.push(child);
                    }
                });
                objectsToRemove.forEach(obj => this.scene.remove(obj));

                // Create ground
                const groundGeometry = new THREE.PlaneGeometry(400, 400);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -2;
                ground.receiveShadow = true;
                ground.userData = { type: 'ground' };
                this.scene.add(ground);

                // Create roads
                this.createRoads();

                // Create buildings
                this.createBuildings();

                // Create trees
                this.createTrees();

                console.log(`‚úÖ City created with ${this.scene.children.length} objects`);
            }

            // Create roads
            createRoads() {
                const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x2c2c2c });

                // Main roads
                for (let i = -150; i <= 150; i += 50) {
                    // Horizontal roads
                    const roadH = new THREE.Mesh(
                        new THREE.PlaneGeometry(300, 8),
                        roadMaterial
                    );
                    roadH.rotation.x = -Math.PI / 2;
                    roadH.position.set(0, 0.1, i);
                    roadH.userData = { type: 'road' };
                    this.scene.add(roadH);

                    // Vertical roads
                    const roadV = new THREE.Mesh(
                        new THREE.PlaneGeometry(8, 300),
                        roadMaterial
                    );
                    roadV.rotation.x = -Math.PI / 2;
                    roadV.position.set(i, 0.1, 0);
                    roadV.userData = { type: 'road' };
                    this.scene.add(roadV);
                }
            }

            // Create buildings
            createBuildings() {
                const buildingColors = [0x8B7355, 0xA0A0A0, 0x6B8E23, 0x4682B4, 0x8B4513, 0x708090];
                let buildingCount = 0;
                const maxBuildings = this.currentPhase * 20;

                for (let x = -150; x <= 150; x += 40) {
                    for (let z = -150; z <= 150; z += 40) {
                        if (buildingCount >= maxBuildings) break;
                        
                        if (Math.random() > 0.6) { // 40% building density
                            const height = 20 + Math.random() * 60;
                            const width = 8 + Math.random() * 8;
                            const depth = 8 + Math.random() * 8;

                            const geometry = new THREE.BoxGeometry(width, height, depth);
                            const material = new THREE.MeshLambertMaterial({
                                color: buildingColors[Math.floor(Math.random() * buildingColors.length)]
                            });

                            const building = new THREE.Mesh(geometry, material);
                            building.position.set(
                                x + (Math.random() - 0.5) * 20,
                                height / 2,
                                z + (Math.random() - 0.5) * 20
                            );
                            building.castShadow = true;
                            building.receiveShadow = true;
                            building.userData = { 
                                type: 'building',
                                name: `Building ${buildingCount + 1}`,
                                phase: this.currentPhase
                            };

                            this.scene.add(building);
                            this.clickableObjects.push(building);
                            buildingCount++;
                        }
                    }
                    if (buildingCount >= maxBuildings) break;
                }

                console.log(`‚úÖ Created ${buildingCount} buildings for Phase ${this.currentPhase}`);
            }

            // Create trees
            createTrees() {
                const treeColors = [0x228B22, 0x32CD32, 0x006400];
                let treeCount = 0;

                for (let x = -180; x <= 180; x += 60) {
                    for (let z = -180; z <= 180; z += 60) {
                        if (Math.random() > 0.7 && treeCount < 30) {
                            // Tree trunk
                            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 8);
                            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);

                            // Tree foliage
                            const foliageGeometry = new THREE.SphereGeometry(4, 8, 6);
                            const foliageMaterial = new THREE.MeshLambertMaterial({
                                color: treeColors[Math.floor(Math.random() * treeColors.length)]
                            });
                            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);

                            // Position
                            const treeX = x + (Math.random() - 0.5) * 30;
                            const treeZ = z + (Math.random() - 0.5) * 30;

                            trunk.position.set(treeX, 4, treeZ);
                            foliage.position.set(treeX, 10, treeZ);

                            trunk.userData = { type: 'tree' };
                            foliage.userData = { type: 'tree' };

                            this.scene.add(trunk);
                            this.scene.add(foliage);
                            treeCount++;
                        }
                    }
                }

                console.log(`‚úÖ Created ${treeCount} trees`);
            }

            // Setup controls
            setupControls() {
                if (typeof THREE.OrbitControls !== 'undefined') {
                    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                    this.controls.enableDamping = true;
                    this.controls.dampingFactor = 0.05;
                    this.controls.maxDistance = 500;
                    this.controls.minDistance = 10;
                    this.controls.maxPolarAngle = Math.PI / 2;
                    this.controls.target.set(0, 0, 0);
                    console.log('‚úÖ Orbit controls enabled');
                } else {
                    console.warn('‚ö†Ô∏è OrbitControls not available');
                }
            }

            // Setup UI
            setupUI() {
                // Camera controls
                const cameraButtons = document.querySelectorAll('.camera-btn');
                cameraButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const mode = btn.dataset.mode;
                        this.setCameraView(mode);
                        
                        cameraButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        document.getElementById('current-view-mode').textContent = this.getViewName(mode);
                        document.getElementById('camera-mode').textContent = this.getViewName(mode);
                    });
                });

                // Phase controls
                const phaseButtons = document.querySelectorAll('.phase-btn');
                phaseButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const phase = parseInt(btn.dataset.phase);
                        this.switchPhase(phase);
                        
                        phaseButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        document.getElementById('current-phase').textContent = phase;
                    });
                });

                // Window resize
                window.addEventListener('resize', () => {
                    this.onWindowResize();
                });

                console.log('‚úÖ UI controls setup complete');
            }

            // Get view name in Vietnamese
            getViewName(mode) {
                const names = {
                    overview: 'T·ªïng Quan',
                    aerial: 'Nh√¨n T·ª´ Tr√™n',
                    ground: 'T·∫ßm M·∫Øt Ng∆∞·ªùi',
                    orbit: 'Xoay T·ª± Do'
                };
                return names[mode] || mode;
            }

            // Set camera view
            setCameraView(mode) {
                if (!this.cameraPositions[mode]) return;

                const pos = this.cameraPositions[mode];
                this.currentView = mode;

                this.camera.fov = pos.fov;
                this.camera.updateProjectionMatrix();

                if (this.controls) {
                    this.controls.enabled = false;

                    const startPos = this.camera.position.clone();
                    const startTarget = this.controls.target.clone();
                    const endPos = new THREE.Vector3(pos.position.x, pos.position.y, pos.position.z);
                    const endTarget = new THREE.Vector3(pos.target.x, pos.target.y, pos.target.z);

                    let progress = 0;
                    const duration = 1000;
                    const startTime = Date.now();

                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        progress = Math.min(elapsed / duration, 1);

                        const eased = this.easeInOutCubic(progress);

                        this.camera.position.lerpVectors(startPos, endPos, eased);
                        this.controls.target.lerpVectors(startTarget, endTarget, eased);
                        this.controls.update();

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            this.controls.enabled = mode === 'orbit';
                        }
                    };

                    animate();
                }

                console.log(`üì∑ Camera set to ${mode} view`);
            }

            // Easing function
            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
            }

            // Switch phase
            switchPhase(phase) {
                if (phase === this.currentPhase) return;
                
                this.currentPhase = phase;
                this.createCity(); // Recreate city with new phase
                console.log(`üèóÔ∏è Switched to Phase ${phase}`);
            }

            // Window resize
            onWindowResize() {
                const width = window.innerWidth;
                const height = window.innerHeight;

                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);

                console.log(`üîÑ Resized to ${width}x${height}`);
            }

            // Enhanced render loop with bulletproof error handling
            startRenderLoop() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }

                let lastTime = Date.now();
                let lastFPSUpdate = lastTime;
                let frames = 0;
                let renderErrors = 0;
                let maxErrors = 10;

                const animate = () => {
                    this.animationId = requestAnimationFrame(animate);
                    
                    try {
                        const currentTime = Date.now();
                        frames++;
                        this.frameCount++;

                        // Verify critical components exist
                        if (!this.renderer || !this.scene || !this.camera) {
                            console.warn('‚ö†Ô∏è Critical rendering components missing, attempting recovery...');
                            if (renderErrors < maxErrors) {
                                renderErrors++;
                                window.emergencyFix();
                                return;
                            }
                        }

                        // Update controls
                        if (this.controls) {
                            this.controls.update();
                        }

                        // Render scene with error handling
                        if (this.renderer && this.scene && this.camera) {
                            this.renderer.render(this.scene, this.camera);
                            
                            // Reset error counter on successful render
                            if (renderErrors > 0) {
                                renderErrors = Math.max(0, renderErrors - 1);
                            }
                        }

                        // Update FPS counter
                        if (currentTime - lastFPSUpdate >= 1000) {
                            const fps = Math.round(frames * 1000 / (currentTime - lastFPSUpdate));
                            const fpsElement = document.getElementById('fps-counter');
                            if (fpsElement) {
                                fpsElement.textContent = fps;
                            }
                            frames = 0;
                            lastFPSUpdate = currentTime;
                        }

                        // Update object counters
                        if (this.frameCount % 60 === 0) { // Every second at 60fps
                            const objectElement = document.getElementById('object-counter');
                            const triangleElement = document.getElementById('triangle-counter');
                            
                            if (objectElement && this.scene) {
                                objectElement.textContent = this.scene.children.length;
                            }
                            if (triangleElement) {
                                triangleElement.textContent = this.clickableObjects.length * 12;
                            }
                        }

                        // Enhanced debug logging every 5 seconds
                        if (this.frameCount % 300 === 0) {
                            console.log(`üé¨ Render loop: Frame ${this.frameCount}, Objects: ${this.scene?.children?.length || 0}, FPS: ${Math.round(1000/(currentTime - lastTime))}`);
                            
                            // Canvas visibility check
                            if (this.renderer?.domElement) {
                                const canvas = this.renderer.domElement;
                                const isVisible = canvas.offsetParent !== null && 
                                                window.getComputedStyle(canvas).display !== 'none' &&
                                                window.getComputedStyle(canvas).visibility !== 'hidden';
                                if (!isVisible) {
                                    console.warn('‚ö†Ô∏è Canvas not visible, forcing styles...');
                                    canvas.style.cssText = `
                                        display: block !important;
                                        position: absolute !important;
                                        top: 0 !important;
                                        left: 0 !important;
                                        width: 100% !important;
                                        height: 100% !important;
                                        visibility: visible !important;
                                        opacity: 1 !important;
                                        z-index: 1 !important;
                                    `;
                                }
                            }
                        }

                        lastTime = currentTime;

                    } catch (error) {
                        console.error('‚ùå Render loop error:', error);
                        renderErrors++;
                        
                        if (renderErrors >= maxErrors) {
                            console.error('üö® Too many render errors, stopping animation');
                            cancelAnimationFrame(this.animationId);
                            
                            // Attempt recovery after delay
                            setTimeout(() => {
                                console.log('üîÑ Attempting render loop recovery...');
                                renderErrors = 0;
                                this.startRenderLoop();
                            }, 2000);
                            return;
                        }
                    }
                };

                animate();
                console.log('‚úÖ BULLETPROOF render loop started with enhanced error handling');
                
                // Force first render
                setTimeout(() => {
                    if (this.renderer && this.scene && this.camera) {
                        for (let i = 0; i < 5; i++) {
                            this.renderer.render(this.scene, this.camera);
                        }
                        console.log('üöÄ Initial render burst completed');
                    }
                }, 100);
            }
        }

        // GLOBAL FUNCTIONS FOR DEBUGGING
        window.testWebGL = function() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            console.log('WebGL Support:', !!gl);
            if (gl) {
                console.log('WebGL Vendor:', gl.getParameter(gl.VENDOR));
                console.log('WebGL Renderer:', gl.getParameter(gl.RENDERER));
                console.log('WebGL Version:', gl.getParameter(gl.VERSION));
            }
            return !!gl;
        };

        window.diagnoseScene = function() {
            if (!window.campus) {
                console.log('‚ùå Campus not initialized');
                return;
            }
            
            console.log('üîç === SCENE DIAGNOSTIC ===');
            console.log('Scene children:', campus.scene.children.length);
            console.log('Camera position:', campus.camera.position);
            console.log('Renderer size:', campus.renderer.getSize(new THREE.Vector2()));
            console.log('Canvas in DOM:', document.body.contains(campus.renderer.domElement));
            console.log('Canvas display:', campus.renderer.domElement.style.display);
            
            // List objects by type
            const objects = {};
            campus.scene.traverse((child) => {
                const type = child.userData?.type || child.type || 'unknown';
                objects[type] = (objects[type] || 0) + 1;
            });
            console.log('Objects by type:', objects);
            console.log('üîç === END DIAGNOSTIC ===');
        };

        window.forceRender = function() {
            if (window.campus && campus.renderer && campus.scene && campus.camera) {
                for (let i = 0; i < 10; i++) {
                    campus.renderer.render(campus.scene, campus.camera);
                }
                console.log('‚úÖ Forced 10 renders');
            }
        };

        window.recreateCity = function() {
            if (window.campus) {
                campus.createCity();
                console.log('‚úÖ City recreated');
            }
        };

        // ENHANCED DIAGNOSTIC FUNCTIONS
        window.fullDiagnostic = function() {
            console.log('üîç === FULL DIAGNOSTIC REPORT ===');
            
            // 1. Basic checks
            console.log('üì¶ THREE.js loaded:', typeof THREE !== 'undefined');
            console.log('üèóÔ∏è Campus object exists:', !!window.campus);
            console.log('üì± Device pixel ratio:', window.devicePixelRatio);
            console.log('üìê Window size:', window.innerWidth + 'x' + window.innerHeight);
            
            // 2. DOM checks
            const container = document.getElementById('canvas-container');
            console.log('üì¶ Canvas container exists:', !!container);
            if (container) {
                console.log('üì¶ Container computed style:', window.getComputedStyle(container).display);
                console.log('üì¶ Container dimensions:', container.clientWidth + 'x' + container.clientHeight);
            }
            
            // 3. Campus checks
            if (window.campus) {
                console.log('üé≠ Scene exists:', !!campus.scene);
                console.log('üì∑ Camera exists:', !!campus.camera);
                console.log('üñºÔ∏è Renderer exists:', !!campus.renderer);
                console.log('üéÆ Controls exists:', !!campus.controls);
                console.log('‚úÖ Is initialized:', campus.isInitialized);
                console.log('üé¨ Frame count:', campus.frameCount);
                
                if (campus.scene) {
                    console.log('üìä Scene children:', campus.scene.children.length);
                    
                    // Count objects by type
                    const objects = {};
                    campus.scene.traverse((child) => {
                        const type = child.userData?.type || child.type || 'unknown';
                        objects[type] = (objects[type] || 0) + 1;
                    });
                    console.log('üèóÔ∏è Objects by type:', objects);
                }
                
                if (campus.camera) {
                    console.log('üì∑ Camera position:', campus.camera.position);
                    console.log('üì∑ Camera rotation:', campus.camera.rotation);
                    console.log('üì∑ Camera FOV:', campus.camera.fov);
                    console.log('üì∑ Camera aspect:', campus.camera.aspect);
                }
                
                if (campus.renderer) {
                    const size = campus.renderer.getSize(new THREE.Vector2());
                    console.log('üñºÔ∏è Renderer size:', size.x + 'x' + size.y);
                    console.log('üñºÔ∏è Renderer pixel ratio:', campus.renderer.getPixelRatio());
                    console.log('üñºÔ∏è Renderer clear color:', '#' + campus.renderer.getClearColor().getHexString());
                    
                    const canvas = campus.renderer.domElement;
                    if (canvas) {
                        console.log('üñºÔ∏è Canvas exists:', !!canvas);
                        console.log('üñºÔ∏è Canvas in DOM:', document.body.contains(canvas));
                        console.log('üñºÔ∏è Canvas display style:', canvas.style.display || 'default');
                        console.log('üñºÔ∏è Canvas visibility:', canvas.style.visibility || 'default');
                        console.log('üñºÔ∏è Canvas opacity:', canvas.style.opacity || 'default');
                        console.log('üñºÔ∏è Canvas dimensions:', canvas.width + 'x' + canvas.height);
                        console.log('üñºÔ∏è Canvas client dimensions:', canvas.clientWidth + 'x' + canvas.clientHeight);
                    }
                }
            }
            
            console.log('üîç === END DIAGNOSTIC REPORT ===');
        };

        window.emergencyFix = function() {
            console.log('üö® === EMERGENCY FIX PROCEDURE ===');
            
            if (!window.campus) {
                console.error('‚ùå No campus object, attempting initialization...');
                attemptInitialization();
                return;
            }
            
            // 1. Fix renderer size
            if (campus.renderer) {
                console.log('üîß Fixing renderer size...');
                campus.renderer.setSize(window.innerWidth, window.innerHeight);
                campus.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            }
            
            // 2. Fix camera
            if (campus.camera) {
                console.log('üîß Fixing camera...');
                campus.camera.aspect = window.innerWidth / window.innerHeight;
                campus.camera.updateProjectionMatrix();
                campus.camera.position.set(100, 80, 100);
                campus.camera.lookAt(0, 0, 0);
            }
            
            // 3. Fix canvas styling
            if (campus.renderer && campus.renderer.domElement) {
                console.log('üîß Forcing canvas styling...');
                const canvas = campus.renderer.domElement;
                const container = document.getElementById('canvas-container');
                
                // Remove from current parent
                if (canvas.parentNode) {
                    canvas.parentNode.removeChild(canvas);
                }
                
                // Force styling
                canvas.style.cssText = `
                    display: block !important;
                    position: absolute !important;
                    top: 0 !important;
                    left: 0 !important;
                    width: 100% !important;
                    height: 100% !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                    z-index: 1 !important;
                    pointer-events: all !important;
                `;
                
                // Re-append to container
                if (container) {
                    container.appendChild(canvas);
                    console.log('‚úÖ Canvas re-attached to container');
                }
            }
            
            // 4. Recreate city if empty
            if (campus.scene && campus.scene.children.length < 5) {
                console.log('üîß Recreating city (scene appears empty)...');
                campus.createCity();
            }
            
            // 5. Force multiple renders
            console.log('üîß Forcing renders...');
            for (let i = 0; i < 20; i++) {
                if (campus.renderer && campus.scene && campus.camera) {
                    campus.renderer.render(campus.scene, campus.camera);
                }
            }
            
            // 6. Update controls
            if (campus.controls) {
                campus.controls.target.set(0, 0, 0);
                campus.controls.update();
            }
            
            console.log('üö® === EMERGENCY FIX COMPLETE ===');
            
            // Run diagnostic after fix
            setTimeout(() => {
                window.fullDiagnostic();
            }, 1000);
        };

        // INITIALIZATION
        let smartCity;

        function initializeSmartCity() {
            console.log('üéØ Starting BULLETPROOF Smart City initialization...');
            
            try {
                smartCity = new BulletproofSmartCity();
                smartCity.init();
            } catch (error) {
                console.error('‚ùå Critical initialization error:', error);
                document.getElementById('loading-message').innerHTML = `
                    <h3>‚ö†Ô∏è L·ªói Kh·ªüi T·∫°o</h3>
                    <p>${error.message}</p>
                    <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; background: #ef4444; color: white; border: none; border-radius: 8px; cursor: pointer;">üîÑ T·∫£i L·∫°i</button>
                `;
            }
        }

        // ENHANCED INITIALIZATION SEQUENCE WITH COMPREHENSIVE CHECKS
        function attemptInitialization() {
            console.log('üîÑ Attempting initialization...');
            
            // 1. Check if Three.js is loaded
            if (typeof THREE === 'undefined') {
                console.warn('‚ö†Ô∏è Three.js not loaded yet, retrying...');
                setTimeout(attemptInitialization, 500);
                return;
            }
            
            // 2. Check if OrbitControls is available
            if (typeof THREE.OrbitControls === 'undefined') {
                console.warn('‚ö†Ô∏è OrbitControls not loaded yet, retrying...');
                setTimeout(attemptInitialization, 500);
                return;
            }
            
            // 3. Check if DOM is ready
            if (!document.getElementById('canvas-container')) {
                console.warn('‚ö†Ô∏è Canvas container not found, retrying...');
                setTimeout(attemptInitialization, 100);
                return;
            }
            
            // 4. WebGL support check
            if (!window.testWebGL()) {
                console.error('‚ùå WebGL not supported on this device');
                document.getElementById('loading-message').innerHTML = `
                    <h3>‚ö†Ô∏è WebGL Kh√¥ng ƒê∆∞·ª£c H·ªó Tr·ª£</h3>
                    <p>Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ WebGL. Vui l√≤ng c·∫≠p nh·∫≠t tr√¨nh duy·ªát ho·∫∑c s·ª≠ d·ª•ng tr√¨nh duy·ªát kh√°c.</p>
                `;
                return;
            }
            
            // 5. Check if already initialized
            if (window.smartCity && smartCity.isInitialized) {
                console.log('‚úÖ Smart City already initialized');
                return;
            }
            
            console.log('‚úÖ All prerequisites met, initializing Smart City...');
            initializeSmartCity();
        }
        
        // Enhanced canvas visibility checker
        window.checkCanvasVisibility = function() {
            console.log('üîç === CANVAS VISIBILITY CHECK ===');
            
            const container = document.getElementById('canvas-container');
            if (!container) {
                console.error('‚ùå Canvas container not found');
                return false;
            }
            
            const containerStyle = window.getComputedStyle(container);
            console.log('üì¶ Container display:', containerStyle.display);
            console.log('üì¶ Container visibility:', containerStyle.visibility);
            console.log('üì¶ Container opacity:', containerStyle.opacity);
            console.log('üì¶ Container z-index:', containerStyle.zIndex);
            
            if (window.campus && campus.renderer && campus.renderer.domElement) {
                const canvas = campus.renderer.domElement;
                const canvasStyle = window.getComputedStyle(canvas);
                
                console.log('üñºÔ∏è Canvas display:', canvasStyle.display);
                console.log('üñºÔ∏è Canvas visibility:', canvasStyle.visibility);
                console.log('üñºÔ∏è Canvas opacity:', canvasStyle.opacity);
                console.log('üñºÔ∏è Canvas position:', canvasStyle.position);
                console.log('üñºÔ∏è Canvas z-index:', canvasStyle.zIndex);
                console.log('üñºÔ∏è Canvas in DOM:', document.body.contains(canvas));
                console.log('üñºÔ∏è Canvas parent:', canvas.parentElement?.id || 'none');
                
                const rect = canvas.getBoundingClientRect();
                console.log('üñºÔ∏è Canvas rect:', rect);
                
                const isVisible = rect.width > 0 && rect.height > 0 && 
                                canvasStyle.display !== 'none' && 
                                canvasStyle.visibility !== 'hidden' &&
                                parseFloat(canvasStyle.opacity) > 0;
                
                console.log('‚úÖ Canvas is visible:', isVisible);
                return isVisible;
            } else {
                console.error('‚ùå Canvas element not found');
                return false;
            }
        };

        // Start initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', attemptInitialization);
        } else {
            attemptInitialization();
        }

        // MULTIPLE BACKUP ATTEMPTS
        setTimeout(attemptInitialization, 500);
        setTimeout(attemptInitialization, 1000);
        setTimeout(attemptInitialization, 2000);

        // AGGRESSIVE AUTO-FIX: Force render and check after 3 seconds
        setTimeout(() => {
            console.log('üîß Running aggressive auto-fix...');
            
            if (window.campus && campus.isInitialized) {
                console.log('‚úÖ Campus initialized, forcing render check...');
                window.forceRender();
                
                // Force canvas visibility
                if (campus.renderer && campus.renderer.domElement) {
                    const canvas = campus.renderer.domElement;
                    canvas.style.cssText = `
                        display: block !important;
                        position: absolute !important;
                        top: 0 !important;
                        left: 0 !important;
                        width: 100% !important;
                        height: 100% !important;
                        visibility: visible !important;
                        opacity: 1 !important;
                        z-index: 1 !important;
                    `;
                    console.log('üîß Forced canvas styling');
                }
                
            } else {
                console.error('‚ùå Campus not initialized after 3 seconds, attempting emergency init...');
                attemptInitialization();
            }
        }, 3000);

        // FINAL BACKUP: Emergency initialization after 5 seconds
        setTimeout(() => {
            if (!window.campus || !campus.isInitialized) {
                console.error('üö® EMERGENCY: Final initialization attempt...');
                attemptInitialization();
            }
        }, 5000);
    </script>
</body>
</html>